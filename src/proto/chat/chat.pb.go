// Code generated by protoc-gen-gogo.
// source: chat.proto
// DO NOT EDIT!

/*
	Package chat is a generated protocol buffer package.

	It is generated from these files:
		chat.proto

	It has these top-level messages:
		NewChatRequest
		ChatReply
		ChatsReply
		ChatsRequest
		JoinChatRequest
		LeaveChatRequest
		SendMessageRequest
		SendMessageReply
		Chat
		Member
		Error
		Message
		MessagePart
		ChatHistoryRequest
		ChatHistoryReply
		MarkAsReadedRequest
		MarkAsReadedReply
		AppendMessageRequest
		AppendMessageReply
		NewMessageRequest
		NewMessageReply
		MessageReadedRequest
		MessageReadedReply
		NewChatMemberRequest
		MessageAppendedRequest
		NewChatMemberReply
		TotalCountUnreadRequest
		TotalCountUnreadReply
		SetStatusMessage
		EnableSyncRequest
		EnableSyncReply
*/
package chat

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type SyncStatus int32

const (
	// sync disabled
	SyncStatus_NONE SyncStatus = 0
	// request was sended, but there is no responce yet
	SyncStatus_PENDING SyncStatus = 1
	SyncStatus_SYNCED  SyncStatus = 2
	// sync was disabled after error
	SyncStatus_ERROR SyncStatus = 3
	// old direct thread is attached to another chat now
	// new thread will be created after next message will be send hire
	SyncStatus_DETACHED SyncStatus = 4
)

var SyncStatus_name = map[int32]string{
	0: "NONE",
	1: "PENDING",
	2: "SYNCED",
	3: "ERROR",
	4: "DETACHED",
}
var SyncStatus_value = map[string]int32{
	"NONE":     0,
	"PENDING":  1,
	"SYNCED":   2,
	"ERROR":    3,
	"DETACHED": 4,
}

func (x SyncStatus) String() string {
	return proto.EnumName(SyncStatus_name, int32(x))
}
func (SyncStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorChat, []int{0} }

type MemberRole int32

const (
	MemberRole_UNKNOWN      MemberRole = 0
	MemberRole_CUSTOMER     MemberRole = 1
	MemberRole_SUPPLIER     MemberRole = 2
	MemberRole_SELLER       MemberRole = 3
	MemberRole_SUPER_SELLER MemberRole = 4
	MemberRole_SYSTEM       MemberRole = 5
)

var MemberRole_name = map[int32]string{
	0: "UNKNOWN",
	1: "CUSTOMER",
	2: "SUPPLIER",
	3: "SELLER",
	4: "SUPER_SELLER",
	5: "SYSTEM",
}
var MemberRole_value = map[string]int32{
	"UNKNOWN":      0,
	"CUSTOMER":     1,
	"SUPPLIER":     2,
	"SELLER":       3,
	"SUPER_SELLER": 4,
	"SYSTEM":       5,
}

func (x MemberRole) String() string {
	return proto.EnumName(MemberRole_name, int32(x))
}
func (MemberRole) EnumDescriptor() ([]byte, []int) { return fileDescriptorChat, []int{1} }

type ErrorCode int32

const (
	ErrorCode_NO_ERRORS  ErrorCode = 0
	ErrorCode_NOT_EXISTS ErrorCode = 1
	ErrorCode_FORBIDDEN  ErrorCode = 2
)

var ErrorCode_name = map[int32]string{
	0: "NO_ERRORS",
	1: "NOT_EXISTS",
	2: "FORBIDDEN",
}
var ErrorCode_value = map[string]int32{
	"NO_ERRORS":  0,
	"NOT_EXISTS": 1,
	"FORBIDDEN":  2,
}

func (x ErrorCode) String() string {
	return proto.EnumName(ErrorCode_name, int32(x))
}
func (ErrorCode) EnumDescriptor() ([]byte, []int) { return fileDescriptorChat, []int{2} }

type NewChatRequest struct {
	Chat *Chat `protobuf:"bytes,1,opt,name=chat" json:"chat,omitempty"`
	// instagram id of supplier
	PrimaryInstagram uint64 `protobuf:"varint,2,opt,name=primary_instagram,json=primaryInstagram,proto3" json:"primary_instagram,omitempty"`
	EnableSync       bool   `protobuf:"varint,3,opt,name=enable_sync,json=enableSync,proto3" json:"enable_sync,omitempty"`
}

func (m *NewChatRequest) Reset()                    { *m = NewChatRequest{} }
func (m *NewChatRequest) String() string            { return proto.CompactTextString(m) }
func (*NewChatRequest) ProtoMessage()               {}
func (*NewChatRequest) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{0} }

func (m *NewChatRequest) GetChat() *Chat {
	if m != nil {
		return m.Chat
	}
	return nil
}

type ChatReply struct {
	Chat  *Chat  `protobuf:"bytes,1,opt,name=chat" json:"chat,omitempty"`
	Error *Error `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
}

func (m *ChatReply) Reset()                    { *m = ChatReply{} }
func (m *ChatReply) String() string            { return proto.CompactTextString(m) }
func (*ChatReply) ProtoMessage()               {}
func (*ChatReply) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{1} }

func (m *ChatReply) GetChat() *Chat {
	if m != nil {
		return m.Chat
	}
	return nil
}

func (m *ChatReply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type ChatsReply struct {
	Chats []*Chat `protobuf:"bytes,1,rep,name=chats" json:"chats,omitempty"`
}

func (m *ChatsReply) Reset()                    { *m = ChatsReply{} }
func (m *ChatsReply) String() string            { return proto.CompactTextString(m) }
func (*ChatsReply) ProtoMessage()               {}
func (*ChatsReply) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{2} }

func (m *ChatsReply) GetChats() []*Chat {
	if m != nil {
		return m.Chats
	}
	return nil
}

type ChatsRequest struct {
	Id     []uint64 `protobuf:"varint,1,rep,packed,name=id" json:"id,omitempty"`
	UserId uint64   `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *ChatsRequest) Reset()                    { *m = ChatsRequest{} }
func (m *ChatsRequest) String() string            { return proto.CompactTextString(m) }
func (*ChatsRequest) ProtoMessage()               {}
func (*ChatsRequest) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{3} }

type JoinChatRequest struct {
	ConversationId uint64    `protobuf:"varint,1,opt,name=conversation_id,json=conversationId,proto3" json:"conversation_id,omitempty"`
	Members        []*Member `protobuf:"bytes,2,rep,name=members" json:"members,omitempty"`
}

func (m *JoinChatRequest) Reset()                    { *m = JoinChatRequest{} }
func (m *JoinChatRequest) String() string            { return proto.CompactTextString(m) }
func (*JoinChatRequest) ProtoMessage()               {}
func (*JoinChatRequest) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{4} }

func (m *JoinChatRequest) GetMembers() []*Member {
	if m != nil {
		return m.Members
	}
	return nil
}

type LeaveChatRequest struct {
	ConversationId uint64   `protobuf:"varint,1,opt,name=conversation_id,json=conversationId,proto3" json:"conversation_id,omitempty"`
	UserIds        []uint64 `protobuf:"varint,2,rep,packed,name=user_ids,json=userIds" json:"user_ids,omitempty"`
}

func (m *LeaveChatRequest) Reset()                    { *m = LeaveChatRequest{} }
func (m *LeaveChatRequest) String() string            { return proto.CompactTextString(m) }
func (*LeaveChatRequest) ProtoMessage()               {}
func (*LeaveChatRequest) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{5} }

type SendMessageRequest struct {
	ConversationId uint64     `protobuf:"varint,1,opt,name=conversation_id,json=conversationId,proto3" json:"conversation_id,omitempty"`
	Messages       []*Message `protobuf:"bytes,2,rep,name=messages" json:"messages,omitempty"`
}

func (m *SendMessageRequest) Reset()                    { *m = SendMessageRequest{} }
func (m *SendMessageRequest) String() string            { return proto.CompactTextString(m) }
func (*SendMessageRequest) ProtoMessage()               {}
func (*SendMessageRequest) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{6} }

func (m *SendMessageRequest) GetMessages() []*Message {
	if m != nil {
		return m.Messages
	}
	return nil
}

type SendMessageReply struct {
	Chat     *Chat      `protobuf:"bytes,1,opt,name=chat" json:"chat,omitempty"`
	Error    *Error     `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	Messages []*Message `protobuf:"bytes,3,rep,name=messages" json:"messages,omitempty"`
}

func (m *SendMessageReply) Reset()                    { *m = SendMessageReply{} }
func (m *SendMessageReply) String() string            { return proto.CompactTextString(m) }
func (*SendMessageReply) ProtoMessage()               {}
func (*SendMessageReply) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{7} }

func (m *SendMessageReply) GetChat() *Chat {
	if m != nil {
		return m.Chat
	}
	return nil
}

func (m *SendMessageReply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *SendMessageReply) GetMessages() []*Message {
	if m != nil {
		return m.Messages
	}
	return nil
}

type Chat struct {
	Id            uint64     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Members       []*Member  `protobuf:"bytes,2,rep,name=members" json:"members,omitempty"`
	Name          string     `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	UnreadCount   uint64     `protobuf:"varint,4,opt,name=unread_count,json=unreadCount,proto3" json:"unread_count,omitempty"`
	RecentMessage *Message   `protobuf:"bytes,5,opt,name=recent_message,json=recentMessage" json:"recent_message,omitempty"`
	DirectThread  string     `protobuf:"bytes,6,opt,name=direct_thread,json=directThread,proto3" json:"direct_thread,omitempty"`
	Caption       string     `protobuf:"bytes,8,opt,name=caption,proto3" json:"caption,omitempty"`
	SyncStatus    SyncStatus `protobuf:"varint,9,opt,name=sync_status,json=syncStatus,proto3,enum=chat.SyncStatus" json:"sync_status,omitempty"`
}

func (m *Chat) Reset()                    { *m = Chat{} }
func (m *Chat) String() string            { return proto.CompactTextString(m) }
func (*Chat) ProtoMessage()               {}
func (*Chat) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{8} }

func (m *Chat) GetMembers() []*Member {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *Chat) GetRecentMessage() *Message {
	if m != nil {
		return m.RecentMessage
	}
	return nil
}

type Member struct {
	Id     uint64     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	UserId uint64     `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Role   MemberRole `protobuf:"varint,3,opt,name=role,proto3,enum=chat.MemberRole" json:"role,omitempty"`
	// display name for the member
	Name          string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	LastMessageId uint64 `protobuf:"varint,5,opt,name=last_message_id,json=lastMessageId,proto3" json:"last_message_id,omitempty"`
	InstagramId   uint64 `protobuf:"varint,6,opt,name=instagram_id,json=instagramId,proto3" json:"instagram_id,omitempty"`
}

func (m *Member) Reset()                    { *m = Member{} }
func (m *Member) String() string            { return proto.CompactTextString(m) }
func (*Member) ProtoMessage()               {}
func (*Member) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{9} }

type Error struct {
	Code    ErrorCode `protobuf:"varint,1,opt,name=code,proto3,enum=chat.ErrorCode" json:"code,omitempty"`
	Message string    `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *Error) Reset()                    { *m = Error{} }
func (m *Error) String() string            { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{10} }

type Message struct {
	ConversationId uint64         `protobuf:"varint,1,opt,name=conversation_id,json=conversationId,proto3" json:"conversation_id,omitempty"`
	UserId         uint64         `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Parts          []*MessagePart `protobuf:"bytes,3,rep,name=parts" json:"parts,omitempty"`
	CreatedAt      int64          `protobuf:"varint,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	Id             uint64         `protobuf:"varint,5,opt,name=id,proto3" json:"id,omitempty"`
	User           *Member        `protobuf:"bytes,6,opt,name=user" json:"user,omitempty"`
	SyncStatus     SyncStatus     `protobuf:"varint,8,opt,name=sync_status,json=syncStatus,proto3,enum=chat.SyncStatus" json:"sync_status,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{11} }

func (m *Message) GetParts() []*MessagePart {
	if m != nil {
		return m.Parts
	}
	return nil
}

func (m *Message) GetUser() *Member {
	if m != nil {
		return m.User
	}
	return nil
}

type MessagePart struct {
	Content   string `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	MimeType  string `protobuf:"bytes,2,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	ContentId string `protobuf:"bytes,3,opt,name=content_id,json=contentId,proto3" json:"content_id,omitempty"`
}

func (m *MessagePart) Reset()                    { *m = MessagePart{} }
func (m *MessagePart) String() string            { return proto.CompactTextString(m) }
func (*MessagePart) ProtoMessage()               {}
func (*MessagePart) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{12} }

type ChatHistoryRequest struct {
	// from_message_id start message_id for query. Set 0 for get entire history
	FromMessageId  uint64 `protobuf:"varint,1,opt,name=from_message_id,json=fromMessageId,proto3" json:"from_message_id,omitempty"`
	ConversationId uint64 `protobuf:"varint,2,opt,name=conversation_id,json=conversationId,proto3" json:"conversation_id,omitempty"`
	Limit          uint64 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	// We must know, has user access to the chat or not
	UserId uint64 `protobuf:"varint,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// true - asc, false - desc
	Direction bool `protobuf:"varint,5,opt,name=direction,proto3" json:"direction,omitempty"`
}

func (m *ChatHistoryRequest) Reset()                    { *m = ChatHistoryRequest{} }
func (m *ChatHistoryRequest) String() string            { return proto.CompactTextString(m) }
func (*ChatHistoryRequest) ProtoMessage()               {}
func (*ChatHistoryRequest) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{13} }

type ChatHistoryReply struct {
	Messages      []*Message `protobuf:"bytes,1,rep,name=messages" json:"messages,omitempty"`
	Chat          *Chat      `protobuf:"bytes,2,opt,name=chat" json:"chat,omitempty"`
	TotalMessages uint64     `protobuf:"varint,3,opt,name=total_messages,json=totalMessages,proto3" json:"total_messages,omitempty"`
	Error         *Error     `protobuf:"bytes,4,opt,name=error" json:"error,omitempty"`
}

func (m *ChatHistoryReply) Reset()                    { *m = ChatHistoryReply{} }
func (m *ChatHistoryReply) String() string            { return proto.CompactTextString(m) }
func (*ChatHistoryReply) ProtoMessage()               {}
func (*ChatHistoryReply) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{14} }

func (m *ChatHistoryReply) GetMessages() []*Message {
	if m != nil {
		return m.Messages
	}
	return nil
}

func (m *ChatHistoryReply) GetChat() *Chat {
	if m != nil {
		return m.Chat
	}
	return nil
}

func (m *ChatHistoryReply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type MarkAsReadedRequest struct {
	ConversationId uint64 `protobuf:"varint,1,opt,name=conversation_id,json=conversationId,proto3" json:"conversation_id,omitempty"`
	UserId         uint64 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	MessageId      uint64 `protobuf:"varint,3,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
}

func (m *MarkAsReadedRequest) Reset()                    { *m = MarkAsReadedRequest{} }
func (m *MarkAsReadedRequest) String() string            { return proto.CompactTextString(m) }
func (*MarkAsReadedRequest) ProtoMessage()               {}
func (*MarkAsReadedRequest) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{15} }

type MarkAsReadedReply struct {
	Error *Error `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
}

func (m *MarkAsReadedReply) Reset()                    { *m = MarkAsReadedReply{} }
func (m *MarkAsReadedReply) String() string            { return proto.CompactTextString(m) }
func (*MarkAsReadedReply) ProtoMessage()               {}
func (*MarkAsReadedReply) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{16} }

func (m *MarkAsReadedReply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type AppendMessageRequest struct {
	MessageId uint64         `protobuf:"varint,1,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	Parts     []*MessagePart `protobuf:"bytes,2,rep,name=parts" json:"parts,omitempty"`
}

func (m *AppendMessageRequest) Reset()                    { *m = AppendMessageRequest{} }
func (m *AppendMessageRequest) String() string            { return proto.CompactTextString(m) }
func (*AppendMessageRequest) ProtoMessage()               {}
func (*AppendMessageRequest) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{17} }

func (m *AppendMessageRequest) GetParts() []*MessagePart {
	if m != nil {
		return m.Parts
	}
	return nil
}

type AppendMessageReply struct {
	Error   *Error   `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	Message *Message `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *AppendMessageReply) Reset()                    { *m = AppendMessageReply{} }
func (m *AppendMessageReply) String() string            { return proto.CompactTextString(m) }
func (*AppendMessageReply) ProtoMessage()               {}
func (*AppendMessageReply) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{18} }

func (m *AppendMessageReply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *AppendMessageReply) GetMessage() *Message {
	if m != nil {
		return m.Message
	}
	return nil
}

type NewMessageRequest struct {
	Chat     *Chat      `protobuf:"bytes,1,opt,name=chat" json:"chat,omitempty"`
	Messages []*Message `protobuf:"bytes,2,rep,name=messages" json:"messages,omitempty"`
}

func (m *NewMessageRequest) Reset()                    { *m = NewMessageRequest{} }
func (m *NewMessageRequest) String() string            { return proto.CompactTextString(m) }
func (*NewMessageRequest) ProtoMessage()               {}
func (*NewMessageRequest) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{19} }

func (m *NewMessageRequest) GetChat() *Chat {
	if m != nil {
		return m.Chat
	}
	return nil
}

func (m *NewMessageRequest) GetMessages() []*Message {
	if m != nil {
		return m.Messages
	}
	return nil
}

type NewMessageReply struct {
}

func (m *NewMessageReply) Reset()                    { *m = NewMessageReply{} }
func (m *NewMessageReply) String() string            { return proto.CompactTextString(m) }
func (*NewMessageReply) ProtoMessage()               {}
func (*NewMessageReply) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{20} }

type MessageReadedRequest struct {
	Chat      *Chat  `protobuf:"bytes,1,opt,name=chat" json:"chat,omitempty"`
	UserId    uint64 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	MessageId uint64 `protobuf:"varint,3,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
}

func (m *MessageReadedRequest) Reset()                    { *m = MessageReadedRequest{} }
func (m *MessageReadedRequest) String() string            { return proto.CompactTextString(m) }
func (*MessageReadedRequest) ProtoMessage()               {}
func (*MessageReadedRequest) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{21} }

func (m *MessageReadedRequest) GetChat() *Chat {
	if m != nil {
		return m.Chat
	}
	return nil
}

type MessageReadedReply struct {
}

func (m *MessageReadedReply) Reset()                    { *m = MessageReadedReply{} }
func (m *MessageReadedReply) String() string            { return proto.CompactTextString(m) }
func (*MessageReadedReply) ProtoMessage()               {}
func (*MessageReadedReply) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{22} }

type NewChatMemberRequest struct {
	Chat *Chat   `protobuf:"bytes,1,opt,name=chat" json:"chat,omitempty"`
	User *Member `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
}

func (m *NewChatMemberRequest) Reset()                    { *m = NewChatMemberRequest{} }
func (m *NewChatMemberRequest) String() string            { return proto.CompactTextString(m) }
func (*NewChatMemberRequest) ProtoMessage()               {}
func (*NewChatMemberRequest) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{23} }

func (m *NewChatMemberRequest) GetChat() *Chat {
	if m != nil {
		return m.Chat
	}
	return nil
}

func (m *NewChatMemberRequest) GetUser() *Member {
	if m != nil {
		return m.User
	}
	return nil
}

type MessageAppendedRequest struct {
	Chat    *Chat    `protobuf:"bytes,1,opt,name=chat" json:"chat,omitempty"`
	Message *Message `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *MessageAppendedRequest) Reset()                    { *m = MessageAppendedRequest{} }
func (m *MessageAppendedRequest) String() string            { return proto.CompactTextString(m) }
func (*MessageAppendedRequest) ProtoMessage()               {}
func (*MessageAppendedRequest) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{24} }

func (m *MessageAppendedRequest) GetChat() *Chat {
	if m != nil {
		return m.Chat
	}
	return nil
}

func (m *MessageAppendedRequest) GetMessage() *Message {
	if m != nil {
		return m.Message
	}
	return nil
}

type NewChatMemberReply struct {
}

func (m *NewChatMemberReply) Reset()                    { *m = NewChatMemberReply{} }
func (m *NewChatMemberReply) String() string            { return proto.CompactTextString(m) }
func (*NewChatMemberReply) ProtoMessage()               {}
func (*NewChatMemberReply) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{25} }

type TotalCountUnreadRequest struct {
	UserId uint64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *TotalCountUnreadRequest) Reset()                    { *m = TotalCountUnreadRequest{} }
func (m *TotalCountUnreadRequest) String() string            { return proto.CompactTextString(m) }
func (*TotalCountUnreadRequest) ProtoMessage()               {}
func (*TotalCountUnreadRequest) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{26} }

type TotalCountUnreadReply struct {
	Count uint64 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *TotalCountUnreadReply) Reset()                    { *m = TotalCountUnreadReply{} }
func (m *TotalCountUnreadReply) String() string            { return proto.CompactTextString(m) }
func (*TotalCountUnreadReply) ProtoMessage()               {}
func (*TotalCountUnreadReply) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{27} }

type SetStatusMessage struct {
	ConversationId uint64 `protobuf:"varint,1,opt,name=conversation_id,json=conversationId,proto3" json:"conversation_id,omitempty"`
	Status         string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *SetStatusMessage) Reset()                    { *m = SetStatusMessage{} }
func (m *SetStatusMessage) String() string            { return proto.CompactTextString(m) }
func (*SetStatusMessage) ProtoMessage()               {}
func (*SetStatusMessage) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{28} }

type EnableSyncRequest struct {
	ChatId uint64 `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	// if not zero changes primary instagram
	PrimaryInstagram uint64 `protobuf:"varint,2,opt,name=primary_instagram,json=primaryInstagram,proto3" json:"primary_instagram,omitempty"`
	// if not empty change current related thread
	ThreadId string `protobuf:"bytes,3,opt,name=thread_id,json=threadId,proto3" json:"thread_id,omitempty"`
	// creater new thread even if chat already have one
	ForceNewThread bool `protobuf:"varint,4,opt,name=force_new_thread,json=forceNewThread,proto3" json:"force_new_thread,omitempty"`
}

func (m *EnableSyncRequest) Reset()                    { *m = EnableSyncRequest{} }
func (m *EnableSyncRequest) String() string            { return proto.CompactTextString(m) }
func (*EnableSyncRequest) ProtoMessage()               {}
func (*EnableSyncRequest) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{29} }

type EnableSyncReply struct {
	Error string `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *EnableSyncReply) Reset()                    { *m = EnableSyncReply{} }
func (m *EnableSyncReply) String() string            { return proto.CompactTextString(m) }
func (*EnableSyncReply) ProtoMessage()               {}
func (*EnableSyncReply) Descriptor() ([]byte, []int) { return fileDescriptorChat, []int{30} }

func init() {
	proto.RegisterType((*NewChatRequest)(nil), "chat.NewChatRequest")
	proto.RegisterType((*ChatReply)(nil), "chat.ChatReply")
	proto.RegisterType((*ChatsReply)(nil), "chat.ChatsReply")
	proto.RegisterType((*ChatsRequest)(nil), "chat.ChatsRequest")
	proto.RegisterType((*JoinChatRequest)(nil), "chat.JoinChatRequest")
	proto.RegisterType((*LeaveChatRequest)(nil), "chat.LeaveChatRequest")
	proto.RegisterType((*SendMessageRequest)(nil), "chat.SendMessageRequest")
	proto.RegisterType((*SendMessageReply)(nil), "chat.SendMessageReply")
	proto.RegisterType((*Chat)(nil), "chat.Chat")
	proto.RegisterType((*Member)(nil), "chat.Member")
	proto.RegisterType((*Error)(nil), "chat.Error")
	proto.RegisterType((*Message)(nil), "chat.Message")
	proto.RegisterType((*MessagePart)(nil), "chat.MessagePart")
	proto.RegisterType((*ChatHistoryRequest)(nil), "chat.ChatHistoryRequest")
	proto.RegisterType((*ChatHistoryReply)(nil), "chat.ChatHistoryReply")
	proto.RegisterType((*MarkAsReadedRequest)(nil), "chat.MarkAsReadedRequest")
	proto.RegisterType((*MarkAsReadedReply)(nil), "chat.MarkAsReadedReply")
	proto.RegisterType((*AppendMessageRequest)(nil), "chat.AppendMessageRequest")
	proto.RegisterType((*AppendMessageReply)(nil), "chat.AppendMessageReply")
	proto.RegisterType((*NewMessageRequest)(nil), "chat.NewMessageRequest")
	proto.RegisterType((*NewMessageReply)(nil), "chat.NewMessageReply")
	proto.RegisterType((*MessageReadedRequest)(nil), "chat.MessageReadedRequest")
	proto.RegisterType((*MessageReadedReply)(nil), "chat.MessageReadedReply")
	proto.RegisterType((*NewChatMemberRequest)(nil), "chat.NewChatMemberRequest")
	proto.RegisterType((*MessageAppendedRequest)(nil), "chat.MessageAppendedRequest")
	proto.RegisterType((*NewChatMemberReply)(nil), "chat.NewChatMemberReply")
	proto.RegisterType((*TotalCountUnreadRequest)(nil), "chat.TotalCountUnreadRequest")
	proto.RegisterType((*TotalCountUnreadReply)(nil), "chat.TotalCountUnreadReply")
	proto.RegisterType((*SetStatusMessage)(nil), "chat.SetStatusMessage")
	proto.RegisterType((*EnableSyncRequest)(nil), "chat.EnableSyncRequest")
	proto.RegisterType((*EnableSyncReply)(nil), "chat.EnableSyncReply")
	proto.RegisterEnum("chat.SyncStatus", SyncStatus_name, SyncStatus_value)
	proto.RegisterEnum("chat.MemberRole", MemberRole_name, MemberRole_value)
	proto.RegisterEnum("chat.ErrorCode", ErrorCode_name, ErrorCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ChatService service

type ChatServiceClient interface {
	// creates new chat
	CreateChat(ctx context.Context, in *NewChatRequest, opts ...grpc.CallOption) (*ChatReply, error)
	// returns exists chat
	GetChats(ctx context.Context, in *ChatsRequest, opts ...grpc.CallOption) (*ChatsReply, error)
	// add users to the chat
	JoinChat(ctx context.Context, in *JoinChatRequest, opts ...grpc.CallOption) (*ChatReply, error)
	// remove users from the chat
	LeaveChat(ctx context.Context, in *LeaveChatRequest, opts ...grpc.CallOption) (*ChatReply, error)
	// sends new message from the user to the chat
	SendNewMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageReply, error)
	// returns chat history
	GetChatHistory(ctx context.Context, in *ChatHistoryRequest, opts ...grpc.CallOption) (*ChatHistoryReply, error)
	// updated last message id for member
	MarkAsReaded(ctx context.Context, in *MarkAsReadedRequest, opts ...grpc.CallOption) (*MarkAsReadedReply, error)
	// returns total count of unread messages
	GetTotalCountUnread(ctx context.Context, in *TotalCountUnreadRequest, opts ...grpc.CallOption) (*TotalCountUnreadReply, error)
	// append message part
	AppendMessage(ctx context.Context, in *AppendMessageRequest, opts ...grpc.CallOption) (*AppendMessageReply, error)
	EnableSync(ctx context.Context, in *EnableSyncRequest, opts ...grpc.CallOption) (*EnableSyncReply, error)
}

type chatServiceClient struct {
	cc *grpc.ClientConn
}

func NewChatServiceClient(cc *grpc.ClientConn) ChatServiceClient {
	return &chatServiceClient{cc}
}

func (c *chatServiceClient) CreateChat(ctx context.Context, in *NewChatRequest, opts ...grpc.CallOption) (*ChatReply, error) {
	out := new(ChatReply)
	err := grpc.Invoke(ctx, "/chat.ChatService/CreateChat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) GetChats(ctx context.Context, in *ChatsRequest, opts ...grpc.CallOption) (*ChatsReply, error) {
	out := new(ChatsReply)
	err := grpc.Invoke(ctx, "/chat.ChatService/GetChats", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) JoinChat(ctx context.Context, in *JoinChatRequest, opts ...grpc.CallOption) (*ChatReply, error) {
	out := new(ChatReply)
	err := grpc.Invoke(ctx, "/chat.ChatService/JoinChat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) LeaveChat(ctx context.Context, in *LeaveChatRequest, opts ...grpc.CallOption) (*ChatReply, error) {
	out := new(ChatReply)
	err := grpc.Invoke(ctx, "/chat.ChatService/LeaveChat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) SendNewMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageReply, error) {
	out := new(SendMessageReply)
	err := grpc.Invoke(ctx, "/chat.ChatService/SendNewMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) GetChatHistory(ctx context.Context, in *ChatHistoryRequest, opts ...grpc.CallOption) (*ChatHistoryReply, error) {
	out := new(ChatHistoryReply)
	err := grpc.Invoke(ctx, "/chat.ChatService/GetChatHistory", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) MarkAsReaded(ctx context.Context, in *MarkAsReadedRequest, opts ...grpc.CallOption) (*MarkAsReadedReply, error) {
	out := new(MarkAsReadedReply)
	err := grpc.Invoke(ctx, "/chat.ChatService/MarkAsReaded", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) GetTotalCountUnread(ctx context.Context, in *TotalCountUnreadRequest, opts ...grpc.CallOption) (*TotalCountUnreadReply, error) {
	out := new(TotalCountUnreadReply)
	err := grpc.Invoke(ctx, "/chat.ChatService/GetTotalCountUnread", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) AppendMessage(ctx context.Context, in *AppendMessageRequest, opts ...grpc.CallOption) (*AppendMessageReply, error) {
	out := new(AppendMessageReply)
	err := grpc.Invoke(ctx, "/chat.ChatService/AppendMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) EnableSync(ctx context.Context, in *EnableSyncRequest, opts ...grpc.CallOption) (*EnableSyncReply, error) {
	out := new(EnableSyncReply)
	err := grpc.Invoke(ctx, "/chat.ChatService/EnableSync", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ChatService service

type ChatServiceServer interface {
	// creates new chat
	CreateChat(context.Context, *NewChatRequest) (*ChatReply, error)
	// returns exists chat
	GetChats(context.Context, *ChatsRequest) (*ChatsReply, error)
	// add users to the chat
	JoinChat(context.Context, *JoinChatRequest) (*ChatReply, error)
	// remove users from the chat
	LeaveChat(context.Context, *LeaveChatRequest) (*ChatReply, error)
	// sends new message from the user to the chat
	SendNewMessage(context.Context, *SendMessageRequest) (*SendMessageReply, error)
	// returns chat history
	GetChatHistory(context.Context, *ChatHistoryRequest) (*ChatHistoryReply, error)
	// updated last message id for member
	MarkAsReaded(context.Context, *MarkAsReadedRequest) (*MarkAsReadedReply, error)
	// returns total count of unread messages
	GetTotalCountUnread(context.Context, *TotalCountUnreadRequest) (*TotalCountUnreadReply, error)
	// append message part
	AppendMessage(context.Context, *AppendMessageRequest) (*AppendMessageReply, error)
	EnableSync(context.Context, *EnableSyncRequest) (*EnableSyncReply, error)
}

func RegisterChatServiceServer(s *grpc.Server, srv ChatServiceServer) {
	s.RegisterService(&_ChatService_serviceDesc, srv)
}

func _ChatService_CreateChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).CreateChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chat.ChatService/CreateChat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).CreateChat(ctx, req.(*NewChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_GetChats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).GetChats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chat.ChatService/GetChats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).GetChats(ctx, req.(*ChatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_JoinChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).JoinChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chat.ChatService/JoinChat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).JoinChat(ctx, req.(*JoinChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_LeaveChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaveChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).LeaveChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chat.ChatService/LeaveChat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).LeaveChat(ctx, req.(*LeaveChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_SendNewMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).SendNewMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chat.ChatService/SendNewMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).SendNewMessage(ctx, req.(*SendMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_GetChatHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChatHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).GetChatHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chat.ChatService/GetChatHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).GetChatHistory(ctx, req.(*ChatHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_MarkAsReaded_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkAsReadedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).MarkAsReaded(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chat.ChatService/MarkAsReaded",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).MarkAsReaded(ctx, req.(*MarkAsReadedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_GetTotalCountUnread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TotalCountUnreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).GetTotalCountUnread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chat.ChatService/GetTotalCountUnread",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).GetTotalCountUnread(ctx, req.(*TotalCountUnreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_AppendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppendMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).AppendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chat.ChatService/AppendMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).AppendMessage(ctx, req.(*AppendMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_EnableSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableSyncRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).EnableSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chat.ChatService/EnableSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).EnableSync(ctx, req.(*EnableSyncRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ChatService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "chat.ChatService",
	HandlerType: (*ChatServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateChat",
			Handler:    _ChatService_CreateChat_Handler,
		},
		{
			MethodName: "GetChats",
			Handler:    _ChatService_GetChats_Handler,
		},
		{
			MethodName: "JoinChat",
			Handler:    _ChatService_JoinChat_Handler,
		},
		{
			MethodName: "LeaveChat",
			Handler:    _ChatService_LeaveChat_Handler,
		},
		{
			MethodName: "SendNewMessage",
			Handler:    _ChatService_SendNewMessage_Handler,
		},
		{
			MethodName: "GetChatHistory",
			Handler:    _ChatService_GetChatHistory_Handler,
		},
		{
			MethodName: "MarkAsReaded",
			Handler:    _ChatService_MarkAsReaded_Handler,
		},
		{
			MethodName: "GetTotalCountUnread",
			Handler:    _ChatService_GetTotalCountUnread_Handler,
		},
		{
			MethodName: "AppendMessage",
			Handler:    _ChatService_AppendMessage_Handler,
		},
		{
			MethodName: "EnableSync",
			Handler:    _ChatService_EnableSync_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "chat.proto",
}

// Client API for Notifier service

type NotifierClient interface {
	// notifies about a new message in the chat
	NewMessage(ctx context.Context, in *NewMessageRequest, opts ...grpc.CallOption) (*NewMessageReply, error)
	// notifies about a message was read by user
	MessageReaded(ctx context.Context, in *MessageReadedRequest, opts ...grpc.CallOption) (*MessageReadedReply, error)
	// notifies about a new member in the chat
	NewChatMember(ctx context.Context, in *NewChatMemberRequest, opts ...grpc.CallOption) (*NewChatMemberReply, error)
}

type notifierClient struct {
	cc *grpc.ClientConn
}

func NewNotifierClient(cc *grpc.ClientConn) NotifierClient {
	return &notifierClient{cc}
}

func (c *notifierClient) NewMessage(ctx context.Context, in *NewMessageRequest, opts ...grpc.CallOption) (*NewMessageReply, error) {
	out := new(NewMessageReply)
	err := grpc.Invoke(ctx, "/chat.Notifier/NewMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifierClient) MessageReaded(ctx context.Context, in *MessageReadedRequest, opts ...grpc.CallOption) (*MessageReadedReply, error) {
	out := new(MessageReadedReply)
	err := grpc.Invoke(ctx, "/chat.Notifier/MessageReaded", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifierClient) NewChatMember(ctx context.Context, in *NewChatMemberRequest, opts ...grpc.CallOption) (*NewChatMemberReply, error) {
	out := new(NewChatMemberReply)
	err := grpc.Invoke(ctx, "/chat.Notifier/NewChatMember", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Notifier service

type NotifierServer interface {
	// notifies about a new message in the chat
	NewMessage(context.Context, *NewMessageRequest) (*NewMessageReply, error)
	// notifies about a message was read by user
	MessageReaded(context.Context, *MessageReadedRequest) (*MessageReadedReply, error)
	// notifies about a new member in the chat
	NewChatMember(context.Context, *NewChatMemberRequest) (*NewChatMemberReply, error)
}

func RegisterNotifierServer(s *grpc.Server, srv NotifierServer) {
	s.RegisterService(&_Notifier_serviceDesc, srv)
}

func _Notifier_NewMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifierServer).NewMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chat.Notifier/NewMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifierServer).NewMessage(ctx, req.(*NewMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notifier_MessageReaded_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageReadedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifierServer).MessageReaded(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chat.Notifier/MessageReaded",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifierServer).MessageReaded(ctx, req.(*MessageReadedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notifier_NewChatMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewChatMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifierServer).NewChatMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chat.Notifier/NewChatMember",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifierServer).NewChatMember(ctx, req.(*NewChatMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Notifier_serviceDesc = grpc.ServiceDesc{
	ServiceName: "chat.Notifier",
	HandlerType: (*NotifierServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NewMessage",
			Handler:    _Notifier_NewMessage_Handler,
		},
		{
			MethodName: "MessageReaded",
			Handler:    _Notifier_MessageReaded_Handler,
		},
		{
			MethodName: "NewChatMember",
			Handler:    _Notifier_NewChatMember_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "chat.proto",
}

func (m *NewChatRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewChatRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Chat != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Chat.Size()))
		n1, err := m.Chat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.PrimaryInstagram != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.PrimaryInstagram))
	}
	if m.EnableSync {
		dAtA[i] = 0x18
		i++
		if m.EnableSync {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ChatReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Chat != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Chat.Size()))
		n2, err := m.Chat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Error.Size()))
		n3, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *ChatsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Chats) > 0 {
		for _, msg := range m.Chats {
			dAtA[i] = 0xa
			i++
			i = encodeVarintChat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ChatsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA5 := make([]byte, len(m.Id)*10)
		var j4 int
		for _, num := range m.Id {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintChat(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *JoinChatRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JoinChatRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConversationId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.ConversationId))
	}
	if len(m.Members) > 0 {
		for _, msg := range m.Members {
			dAtA[i] = 0x12
			i++
			i = encodeVarintChat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LeaveChatRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaveChatRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConversationId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.ConversationId))
	}
	if len(m.UserIds) > 0 {
		dAtA7 := make([]byte, len(m.UserIds)*10)
		var j6 int
		for _, num := range m.UserIds {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintChat(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	return i, nil
}

func (m *SendMessageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendMessageRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConversationId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.ConversationId))
	}
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0x12
			i++
			i = encodeVarintChat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SendMessageReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendMessageReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Chat != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Chat.Size()))
		n8, err := m.Chat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Error.Size()))
		n9, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintChat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Chat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Id))
	}
	if len(m.Members) > 0 {
		for _, msg := range m.Members {
			dAtA[i] = 0x12
			i++
			i = encodeVarintChat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.UnreadCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.UnreadCount))
	}
	if m.RecentMessage != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.RecentMessage.Size()))
		n10, err := m.RecentMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.DirectThread) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(m.DirectThread)))
		i += copy(dAtA[i:], m.DirectThread)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if m.SyncStatus != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.SyncStatus))
	}
	return i, nil
}

func (m *Member) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Member) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Id))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
	}
	if m.Role != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Role))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.LastMessageId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.LastMessageId))
	}
	if m.InstagramId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.InstagramId))
	}
	return i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConversationId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.ConversationId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
	}
	if len(m.Parts) > 0 {
		for _, msg := range m.Parts {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintChat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CreatedAt != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.CreatedAt))
	}
	if m.Id != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Id))
	}
	if m.User != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.User.Size()))
		n11, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.SyncStatus != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.SyncStatus))
	}
	return i, nil
}

func (m *MessagePart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessagePart) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Content) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if len(m.MimeType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(m.MimeType)))
		i += copy(dAtA[i:], m.MimeType)
	}
	if len(m.ContentId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(m.ContentId)))
		i += copy(dAtA[i:], m.ContentId)
	}
	return i, nil
}

func (m *ChatHistoryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatHistoryRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromMessageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.FromMessageId))
	}
	if m.ConversationId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.ConversationId))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Limit))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
	}
	if m.Direction {
		dAtA[i] = 0x28
		i++
		if m.Direction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ChatHistoryReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatHistoryReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0xa
			i++
			i = encodeVarintChat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Chat != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Chat.Size()))
		n12, err := m.Chat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.TotalMessages != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.TotalMessages))
	}
	if m.Error != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Error.Size()))
		n13, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *MarkAsReadedRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkAsReadedRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConversationId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.ConversationId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.MessageId))
	}
	return i, nil
}

func (m *MarkAsReadedReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkAsReadedReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Error.Size()))
		n14, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *AppendMessageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendMessageRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MessageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.MessageId))
	}
	if len(m.Parts) > 0 {
		for _, msg := range m.Parts {
			dAtA[i] = 0x12
			i++
			i = encodeVarintChat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AppendMessageReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendMessageReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Error.Size()))
		n15, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Message != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Message.Size()))
		n16, err := m.Message.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *NewMessageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewMessageRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Chat != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Chat.Size()))
		n17, err := m.Chat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0x12
			i++
			i = encodeVarintChat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NewMessageReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewMessageReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MessageReadedRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageReadedRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Chat != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Chat.Size()))
		n18, err := m.Chat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.MessageId))
	}
	return i, nil
}

func (m *MessageReadedReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageReadedReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *NewChatMemberRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewChatMemberRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Chat != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Chat.Size()))
		n19, err := m.Chat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.User != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.User.Size()))
		n20, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *MessageAppendedRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageAppendedRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Chat != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Chat.Size()))
		n21, err := m.Chat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Message != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Message.Size()))
		n22, err := m.Message.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *NewChatMemberReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewChatMemberReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TotalCountUnreadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TotalCountUnreadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *TotalCountUnreadReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TotalCountUnreadReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func (m *SetStatusMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetStatusMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConversationId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.ConversationId))
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	return i, nil
}

func (m *EnableSyncRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnableSyncRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChatId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.ChatId))
	}
	if m.PrimaryInstagram != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.PrimaryInstagram))
	}
	if len(m.ThreadId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(m.ThreadId)))
		i += copy(dAtA[i:], m.ThreadId)
	}
	if m.ForceNewThread {
		dAtA[i] = 0x20
		i++
		if m.ForceNewThread {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *EnableSyncReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnableSyncReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func encodeFixed64Chat(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Chat(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintChat(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *NewChatRequest) Size() (n int) {
	var l int
	_ = l
	if m.Chat != nil {
		l = m.Chat.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	if m.PrimaryInstagram != 0 {
		n += 1 + sovChat(uint64(m.PrimaryInstagram))
	}
	if m.EnableSync {
		n += 2
	}
	return n
}

func (m *ChatReply) Size() (n int) {
	var l int
	_ = l
	if m.Chat != nil {
		l = m.Chat.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	return n
}

func (m *ChatsReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Chats) > 0 {
		for _, e := range m.Chats {
			l = e.Size()
			n += 1 + l + sovChat(uint64(l))
		}
	}
	return n
}

func (m *ChatsRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Id) > 0 {
		l = 0
		for _, e := range m.Id {
			l += sovChat(uint64(e))
		}
		n += 1 + sovChat(uint64(l)) + l
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	return n
}

func (m *JoinChatRequest) Size() (n int) {
	var l int
	_ = l
	if m.ConversationId != 0 {
		n += 1 + sovChat(uint64(m.ConversationId))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovChat(uint64(l))
		}
	}
	return n
}

func (m *LeaveChatRequest) Size() (n int) {
	var l int
	_ = l
	if m.ConversationId != 0 {
		n += 1 + sovChat(uint64(m.ConversationId))
	}
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovChat(uint64(e))
		}
		n += 1 + sovChat(uint64(l)) + l
	}
	return n
}

func (m *SendMessageRequest) Size() (n int) {
	var l int
	_ = l
	if m.ConversationId != 0 {
		n += 1 + sovChat(uint64(m.ConversationId))
	}
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovChat(uint64(l))
		}
	}
	return n
}

func (m *SendMessageReply) Size() (n int) {
	var l int
	_ = l
	if m.Chat != nil {
		l = m.Chat.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovChat(uint64(l))
		}
	}
	return n
}

func (m *Chat) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovChat(uint64(m.Id))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovChat(uint64(l))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovChat(uint64(l))
	}
	if m.UnreadCount != 0 {
		n += 1 + sovChat(uint64(m.UnreadCount))
	}
	if m.RecentMessage != nil {
		l = m.RecentMessage.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	l = len(m.DirectThread)
	if l > 0 {
		n += 1 + l + sovChat(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovChat(uint64(l))
	}
	if m.SyncStatus != 0 {
		n += 1 + sovChat(uint64(m.SyncStatus))
	}
	return n
}

func (m *Member) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovChat(uint64(m.Id))
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if m.Role != 0 {
		n += 1 + sovChat(uint64(m.Role))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovChat(uint64(l))
	}
	if m.LastMessageId != 0 {
		n += 1 + sovChat(uint64(m.LastMessageId))
	}
	if m.InstagramId != 0 {
		n += 1 + sovChat(uint64(m.InstagramId))
	}
	return n
}

func (m *Error) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovChat(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovChat(uint64(l))
	}
	return n
}

func (m *Message) Size() (n int) {
	var l int
	_ = l
	if m.ConversationId != 0 {
		n += 1 + sovChat(uint64(m.ConversationId))
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if len(m.Parts) > 0 {
		for _, e := range m.Parts {
			l = e.Size()
			n += 1 + l + sovChat(uint64(l))
		}
	}
	if m.CreatedAt != 0 {
		n += 1 + sovChat(uint64(m.CreatedAt))
	}
	if m.Id != 0 {
		n += 1 + sovChat(uint64(m.Id))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	if m.SyncStatus != 0 {
		n += 1 + sovChat(uint64(m.SyncStatus))
	}
	return n
}

func (m *MessagePart) Size() (n int) {
	var l int
	_ = l
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovChat(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovChat(uint64(l))
	}
	l = len(m.ContentId)
	if l > 0 {
		n += 1 + l + sovChat(uint64(l))
	}
	return n
}

func (m *ChatHistoryRequest) Size() (n int) {
	var l int
	_ = l
	if m.FromMessageId != 0 {
		n += 1 + sovChat(uint64(m.FromMessageId))
	}
	if m.ConversationId != 0 {
		n += 1 + sovChat(uint64(m.ConversationId))
	}
	if m.Limit != 0 {
		n += 1 + sovChat(uint64(m.Limit))
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if m.Direction {
		n += 2
	}
	return n
}

func (m *ChatHistoryReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovChat(uint64(l))
		}
	}
	if m.Chat != nil {
		l = m.Chat.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	if m.TotalMessages != 0 {
		n += 1 + sovChat(uint64(m.TotalMessages))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	return n
}

func (m *MarkAsReadedRequest) Size() (n int) {
	var l int
	_ = l
	if m.ConversationId != 0 {
		n += 1 + sovChat(uint64(m.ConversationId))
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if m.MessageId != 0 {
		n += 1 + sovChat(uint64(m.MessageId))
	}
	return n
}

func (m *MarkAsReadedReply) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	return n
}

func (m *AppendMessageRequest) Size() (n int) {
	var l int
	_ = l
	if m.MessageId != 0 {
		n += 1 + sovChat(uint64(m.MessageId))
	}
	if len(m.Parts) > 0 {
		for _, e := range m.Parts {
			l = e.Size()
			n += 1 + l + sovChat(uint64(l))
		}
	}
	return n
}

func (m *AppendMessageReply) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	return n
}

func (m *NewMessageRequest) Size() (n int) {
	var l int
	_ = l
	if m.Chat != nil {
		l = m.Chat.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovChat(uint64(l))
		}
	}
	return n
}

func (m *NewMessageReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MessageReadedRequest) Size() (n int) {
	var l int
	_ = l
	if m.Chat != nil {
		l = m.Chat.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if m.MessageId != 0 {
		n += 1 + sovChat(uint64(m.MessageId))
	}
	return n
}

func (m *MessageReadedReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *NewChatMemberRequest) Size() (n int) {
	var l int
	_ = l
	if m.Chat != nil {
		l = m.Chat.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	return n
}

func (m *MessageAppendedRequest) Size() (n int) {
	var l int
	_ = l
	if m.Chat != nil {
		l = m.Chat.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	return n
}

func (m *NewChatMemberReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *TotalCountUnreadRequest) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	return n
}

func (m *TotalCountUnreadReply) Size() (n int) {
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovChat(uint64(m.Count))
	}
	return n
}

func (m *SetStatusMessage) Size() (n int) {
	var l int
	_ = l
	if m.ConversationId != 0 {
		n += 1 + sovChat(uint64(m.ConversationId))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovChat(uint64(l))
	}
	return n
}

func (m *EnableSyncRequest) Size() (n int) {
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovChat(uint64(m.ChatId))
	}
	if m.PrimaryInstagram != 0 {
		n += 1 + sovChat(uint64(m.PrimaryInstagram))
	}
	l = len(m.ThreadId)
	if l > 0 {
		n += 1 + l + sovChat(uint64(l))
	}
	if m.ForceNewThread {
		n += 2
	}
	return n
}

func (m *EnableSyncReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovChat(uint64(l))
	}
	return n
}

func sovChat(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozChat(x uint64) (n int) {
	return sovChat(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NewChatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewChatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewChatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chat == nil {
				m.Chat = &Chat{}
			}
			if err := m.Chat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryInstagram", wireType)
			}
			m.PrimaryInstagram = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryInstagram |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableSync", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableSync = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chat == nil {
				m.Chat = &Chat{}
			}
			if err := m.Chat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chats = append(m.Chats, &Chat{})
			if err := m.Chats[len(m.Chats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthChat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Id = append(m.Id, v)
				}
			} else if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Id = append(m.Id, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JoinChatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JoinChatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JoinChatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConversationId", wireType)
			}
			m.ConversationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConversationId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &Member{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaveChatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaveChatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaveChatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConversationId", wireType)
			}
			m.ConversationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConversationId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthChat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendMessageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendMessageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendMessageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConversationId", wireType)
			}
			m.ConversationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConversationId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &Message{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendMessageReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendMessageReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendMessageReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chat == nil {
				m.Chat = &Chat{}
			}
			if err := m.Chat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &Message{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &Member{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnreadCount", wireType)
			}
			m.UnreadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnreadCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecentMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecentMessage == nil {
				m.RecentMessage = &Message{}
			}
			if err := m.RecentMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectThread", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectThread = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncStatus", wireType)
			}
			m.SyncStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyncStatus |= (SyncStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= (MemberRole(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMessageId", wireType)
			}
			m.LastMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastMessageId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramId", wireType)
			}
			m.InstagramId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstagramId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConversationId", wireType)
			}
			m.ConversationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConversationId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parts = append(m.Parts, &MessagePart{})
			if err := m.Parts[len(m.Parts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &Member{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncStatus", wireType)
			}
			m.SyncStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyncStatus |= (SyncStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessagePart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessagePart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessagePart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatHistoryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatHistoryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatHistoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromMessageId", wireType)
			}
			m.FromMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromMessageId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConversationId", wireType)
			}
			m.ConversationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConversationId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Direction = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatHistoryReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatHistoryReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatHistoryReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &Message{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chat == nil {
				m.Chat = &Chat{}
			}
			if err := m.Chat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMessages", wireType)
			}
			m.TotalMessages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalMessages |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkAsReadedRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkAsReadedRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkAsReadedRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConversationId", wireType)
			}
			m.ConversationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConversationId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkAsReadedReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkAsReadedReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkAsReadedReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendMessageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendMessageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendMessageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parts = append(m.Parts, &MessagePart{})
			if err := m.Parts[len(m.Parts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendMessageReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendMessageReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendMessageReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &Message{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewMessageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewMessageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewMessageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chat == nil {
				m.Chat = &Chat{}
			}
			if err := m.Chat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &Message{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewMessageReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewMessageReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewMessageReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageReadedRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageReadedRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageReadedRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chat == nil {
				m.Chat = &Chat{}
			}
			if err := m.Chat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageReadedReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageReadedReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageReadedReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewChatMemberRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewChatMemberRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewChatMemberRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chat == nil {
				m.Chat = &Chat{}
			}
			if err := m.Chat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &Member{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageAppendedRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageAppendedRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageAppendedRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chat == nil {
				m.Chat = &Chat{}
			}
			if err := m.Chat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &Message{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewChatMemberReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewChatMemberReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewChatMemberReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TotalCountUnreadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TotalCountUnreadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TotalCountUnreadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TotalCountUnreadReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TotalCountUnreadReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TotalCountUnreadReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetStatusMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetStatusMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetStatusMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConversationId", wireType)
			}
			m.ConversationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConversationId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnableSyncRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnableSyncRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnableSyncRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryInstagram", wireType)
			}
			m.PrimaryInstagram = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryInstagram |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreadId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThreadId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceNewThread", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceNewThread = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnableSyncReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnableSyncReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnableSyncReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipChat(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowChat
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthChat
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowChat
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipChat(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthChat = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowChat   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("chat.proto", fileDescriptorChat) }

var fileDescriptorChat = []byte{
	// 1501 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x58, 0xcf, 0x72, 0xdb, 0x54,
	0x17, 0x8f, 0x1c, 0xd9, 0xb1, 0x8e, 0xff, 0x29, 0xb7, 0x4e, 0xa2, 0xba, 0x5f, 0xf3, 0xb9, 0xea,
	0xf7, 0x35, 0xa1, 0x0c, 0x9d, 0xc1, 0x94, 0x32, 0x6c, 0x98, 0x49, 0x6d, 0x35, 0x35, 0x24, 0x72,
	0x46, 0x72, 0xa0, 0x6c, 0x2a, 0x14, 0xe9, 0xb6, 0xd1, 0x60, 0x4b, 0x46, 0x52, 0x92, 0xf1, 0x86,
	0xe1, 0x11, 0x58, 0xb1, 0x63, 0x86, 0x1d, 0x7b, 0x16, 0x3c, 0x03, 0x4b, 0x1e, 0x80, 0x05, 0x53,
	0x5e, 0x82, 0x25, 0x73, 0xef, 0x95, 0x64, 0x49, 0xb6, 0x5b, 0xa7, 0xc3, 0xce, 0xf7, 0x9c, 0x7b,
	0xcf, 0xff, 0xf3, 0x3b, 0x47, 0x06, 0xb0, 0xce, 0xcd, 0xf0, 0xc1, 0xc4, 0xf7, 0x42, 0x0f, 0xf1,
	0xe4, 0xb7, 0xfc, 0x2d, 0xd4, 0x55, 0x7c, 0xd5, 0x3d, 0x37, 0x43, 0x0d, 0x7f, 0x73, 0x81, 0x83,
	0x10, 0xed, 0x02, 0xe5, 0x48, 0x5c, 0x9b, 0xdb, 0xaf, 0x74, 0xe0, 0x01, 0x7d, 0x42, 0x2f, 0x50,
	0x3a, 0x7a, 0x17, 0x36, 0x27, 0xbe, 0x33, 0x36, 0xfd, 0xa9, 0xe1, 0xb8, 0x41, 0x68, 0xbe, 0xf4,
	0xcd, 0xb1, 0x54, 0x68, 0x73, 0xfb, 0xbc, 0x26, 0x46, 0x8c, 0x7e, 0x4c, 0x47, 0xff, 0x85, 0x0a,
	0x76, 0xcd, 0xb3, 0x11, 0x36, 0x82, 0xa9, 0x6b, 0x49, 0xeb, 0x6d, 0x6e, 0xbf, 0xac, 0x01, 0x23,
	0xe9, 0x53, 0xd7, 0x92, 0x55, 0x10, 0x98, 0xf2, 0xc9, 0x68, 0xfa, 0x46, 0xd5, 0x77, 0xa0, 0x88,
	0x7d, 0xdf, 0xf3, 0xa9, 0xba, 0x4a, 0xa7, 0xc2, 0x2e, 0x28, 0x84, 0xa4, 0x31, 0x8e, 0xfc, 0x00,
	0x80, 0x3c, 0x08, 0x98, 0xc0, 0x36, 0x14, 0xc9, 0x95, 0x40, 0xe2, 0xda, 0xeb, 0x39, 0x89, 0x8c,
	0x21, 0x7f, 0x04, 0xd5, 0xe8, 0x3e, 0xf3, 0xbe, 0x0e, 0x05, 0xc7, 0xa6, 0xd7, 0x79, 0xad, 0xe0,
	0xd8, 0x68, 0x07, 0x36, 0x2e, 0x02, 0xec, 0x1b, 0x8e, 0x1d, 0xf9, 0x58, 0x22, 0xc7, 0xbe, 0x2d,
	0x9f, 0x41, 0xe3, 0x53, 0xcf, 0x71, 0xd3, 0x91, 0xdb, 0x83, 0x86, 0xe5, 0xb9, 0x97, 0xd8, 0x0f,
	0xcc, 0xd0, 0xf1, 0x5c, 0x83, 0x0a, 0x22, 0x6f, 0xea, 0x69, 0x72, 0xdf, 0x46, 0xf7, 0x60, 0x63,
	0x8c, 0xc7, 0x67, 0xd8, 0x0f, 0xa4, 0x02, 0x35, 0xac, 0xca, 0x0c, 0x3b, 0xa6, 0x44, 0x2d, 0x66,
	0xca, 0x9f, 0x83, 0x78, 0x84, 0xcd, 0x4b, 0xfc, 0x56, 0x4a, 0x6e, 0x42, 0x39, 0xb2, 0x9c, 0x69,
	0xe1, 0xb5, 0x0d, 0x66, 0x7a, 0x20, 0x9f, 0x03, 0xd2, 0xb1, 0x6b, 0x1f, 0xe3, 0x20, 0x30, 0x5f,
	0xe2, 0x6b, 0x4b, 0x7e, 0x07, 0xca, 0x63, 0xf6, 0x34, 0xb6, 0xbf, 0x16, 0xdb, 0xcf, 0x04, 0x26,
	0x6c, 0xf9, 0x3b, 0x0e, 0xc4, 0x8c, 0xaa, 0x7f, 0x27, 0xcd, 0x19, 0x13, 0xd6, 0x5f, 0x6f, 0xc2,
	0x8f, 0x05, 0xe0, 0x89, 0xf0, 0x24, 0xb5, 0x5c, 0x94, 0xda, 0x15, 0xb3, 0x80, 0x10, 0xf0, 0xae,
	0x39, 0xc6, 0xb4, 0x78, 0x05, 0x8d, 0xfe, 0x46, 0x77, 0xa0, 0x7a, 0xe1, 0xfa, 0xd8, 0xb4, 0x0d,
	0xcb, 0xbb, 0x70, 0x43, 0x89, 0xa7, 0x52, 0x2b, 0x8c, 0xd6, 0x25, 0x24, 0xf4, 0x10, 0xea, 0x3e,
	0xb6, 0xb0, 0x1b, 0x1a, 0x91, 0x29, 0x52, 0x91, 0xba, 0x93, 0x33, 0xb4, 0xc6, 0x2e, 0x45, 0x47,
	0x74, 0x17, 0x6a, 0xb6, 0xe3, 0x63, 0x2b, 0x34, 0xc2, 0x73, 0x22, 0x4b, 0x2a, 0x51, 0xad, 0x55,
	0x46, 0x1c, 0x52, 0x1a, 0x92, 0x60, 0xc3, 0x32, 0x27, 0x24, 0x1b, 0x52, 0x99, 0xb2, 0xe3, 0x23,
	0x7a, 0x1f, 0x2a, 0xa4, 0xd1, 0x8c, 0x20, 0x34, 0xc3, 0x8b, 0x40, 0x12, 0xda, 0xdc, 0x7e, 0xbd,
	0x23, 0x32, 0x8d, 0xa4, 0xdf, 0x74, 0x4a, 0xd7, 0x20, 0x48, 0x7e, 0xcb, 0xbf, 0x72, 0x50, 0x62,
	0x2e, 0xcf, 0x45, 0x68, 0x59, 0xf1, 0xa3, 0xff, 0x01, 0xef, 0x7b, 0x23, 0x16, 0x92, 0x44, 0x7e,
	0x14, 0x37, 0x6f, 0x84, 0x35, 0xca, 0x4d, 0x02, 0xc7, 0xa7, 0x02, 0x77, 0x0f, 0x1a, 0x23, 0x33,
	0x48, 0x62, 0x42, 0x44, 0x17, 0xa9, 0xe8, 0x1a, 0x21, 0x47, 0x51, 0xe8, 0xdb, 0x24, 0xc0, 0x09,
	0xba, 0x90, 0x4b, 0x25, 0x16, 0xe0, 0x84, 0xd6, 0xb7, 0xe5, 0x27, 0x50, 0xa4, 0x35, 0x81, 0xee,
	0x02, 0x6f, 0x79, 0x36, 0xa6, 0x86, 0xd7, 0x3b, 0x8d, 0x54, 0xb9, 0x74, 0x3d, 0x1b, 0x6b, 0x94,
	0x49, 0x62, 0x16, 0xe7, 0xa1, 0xc0, 0x62, 0x16, 0x1d, 0xe5, 0xbf, 0x39, 0xd8, 0x88, 0xc3, 0xbf,
	0x72, 0x0f, 0x2c, 0x0d, 0xcd, 0x1e, 0x14, 0x27, 0xa6, 0x1f, 0xc6, 0x65, 0xb9, 0x99, 0xc9, 0xf6,
	0x89, 0xe9, 0x87, 0x1a, 0xe3, 0xa3, 0xdb, 0x00, 0x96, 0x8f, 0xcd, 0x10, 0xdb, 0x86, 0xc9, 0x0a,
	0x68, 0x5d, 0x13, 0x22, 0xca, 0x41, 0x5c, 0xad, 0xc5, 0x24, 0x17, 0x6d, 0xe0, 0x89, 0x06, 0x1a,
	0x88, 0x7c, 0xa9, 0x52, 0x4e, 0x3e, 0xf7, 0xe5, 0x15, 0x72, 0x6f, 0x41, 0x25, 0x65, 0x19, 0xad,
	0x2b, 0xcf, 0x0d, 0xb1, 0xcb, 0x7a, 0x93, 0xd4, 0x15, 0x3b, 0xa2, 0x5b, 0x20, 0x8c, 0x9d, 0x31,
	0x36, 0xc2, 0xe9, 0x24, 0x8e, 0x5f, 0x99, 0x10, 0x86, 0xd3, 0x09, 0xa6, 0x9e, 0xb0, 0x7b, 0x24,
	0x1c, 0xac, 0x4d, 0x84, 0x88, 0xd2, 0xb7, 0xe5, 0x5f, 0x38, 0x40, 0xa4, 0x01, 0x9f, 0x3a, 0x41,
	0xe8, 0xf9, 0xd3, 0x18, 0x6e, 0xee, 0x41, 0xe3, 0x85, 0xef, 0x8d, 0xd3, 0x95, 0xc0, 0x42, 0x5d,
	0x23, 0xe4, 0x59, 0x25, 0x2c, 0x48, 0x49, 0x61, 0x61, 0x4a, 0x9a, 0x50, 0x1c, 0x39, 0x63, 0x27,
	0xa4, 0x16, 0xf0, 0x1a, 0x3b, 0xa4, 0x13, 0xc5, 0x67, 0x12, 0xf5, 0x1f, 0x10, 0x58, 0x53, 0x91,
	0x36, 0x2a, 0xd2, 0xc1, 0x34, 0x23, 0xc8, 0x3f, 0x73, 0x20, 0x66, 0x8c, 0x26, 0xc0, 0x95, 0x46,
	0x1d, 0xee, 0xb5, 0xa8, 0x93, 0x60, 0x5c, 0x61, 0x09, 0xc6, 0xfd, 0x1f, 0xea, 0xa1, 0x17, 0x9a,
	0x23, 0x23, 0x05, 0x63, 0xd4, 0x79, 0x4a, 0x3d, 0x8e, 0xc5, 0x24, 0x50, 0xc8, 0x2f, 0x9d, 0x78,
	0x97, 0x70, 0xe3, 0xd8, 0xf4, 0xbf, 0x3e, 0x08, 0x34, 0x6c, 0xda, 0xd8, 0xbe, 0x36, 0x9a, 0x2f,
	0xad, 0xe4, 0xdb, 0x00, 0xa9, 0xdc, 0x30, 0xf3, 0x84, 0x71, 0x9c, 0x17, 0xf9, 0x11, 0x6c, 0x66,
	0xf5, 0x92, 0x08, 0x25, 0xf6, 0x72, 0x4b, 0xed, 0x7d, 0x0e, 0xcd, 0x83, 0xc9, 0x64, 0x7e, 0xfc,
	0x64, 0xd5, 0x71, 0x39, 0x75, 0xb3, 0xbe, 0x2a, 0xbc, 0xbe, 0xaf, 0xe4, 0xaf, 0x00, 0xe5, 0xe4,
	0xaf, 0x66, 0x18, 0xda, 0xcb, 0x22, 0xc4, 0x5c, 0x72, 0x13, 0xc0, 0x78, 0x0e, 0x9b, 0x2a, 0xbe,
	0xca, 0x99, 0xff, 0xa6, 0xa1, 0x76, 0x8d, 0xa1, 0xb9, 0x09, 0x8d, 0xb4, 0xfc, 0xc9, 0x68, 0x2a,
	0xbb, 0xd0, 0x4c, 0xce, 0xe9, 0x2c, 0xbf, 0x49, 0xeb, 0xdb, 0x26, 0xb7, 0x09, 0x28, 0xa7, 0x8f,
	0x58, 0xf1, 0x0c, 0x9a, 0xd1, 0xb2, 0x18, 0x01, 0xcf, 0x8a, 0x56, 0xc4, 0xd8, 0x55, 0x58, 0x86,
	0x5d, 0xb2, 0x09, 0xdb, 0x91, 0x3e, 0x96, 0xbb, 0xd5, 0x3d, 0x5c, 0x39, 0x6b, 0x4d, 0x40, 0x39,
	0xe3, 0x89, 0x4b, 0x1d, 0xd8, 0x19, 0x92, 0x8e, 0xa3, 0x33, 0xfb, 0x94, 0x8e, 0xef, 0x58, 0x73,
	0x2a, 0x76, 0x5c, 0x66, 0xf5, 0x7b, 0x0f, 0xb6, 0xe6, 0xdf, 0x90, 0x22, 0x6b, 0x42, 0x91, 0xad,
	0x03, 0xec, 0x3e, 0x3b, 0xc8, 0x3a, 0x59, 0x81, 0x42, 0x86, 0xb8, 0xd7, 0x9e, 0x33, 0xdb, 0x50,
	0x8a, 0xf0, 0x9c, 0xa1, 0x6e, 0x74, 0x92, 0x7f, 0xe2, 0x60, 0x53, 0x49, 0xd6, 0xe8, 0x94, 0xc9,
	0xc4, 0xf9, 0x94, 0xc9, 0xe4, 0xd8, 0xb7, 0xaf, 0xb7, 0xb4, 0xdf, 0x02, 0x81, 0x2d, 0x1f, 0x33,
	0x38, 0x2f, 0x33, 0x42, 0xdf, 0x46, 0xfb, 0x20, 0xbe, 0xf0, 0x7c, 0x0b, 0x1b, 0x2e, 0xbe, 0x8a,
	0x77, 0x14, 0x9e, 0xa2, 0x67, 0x9d, 0xd2, 0x55, 0x7c, 0xc5, 0xb6, 0x14, 0x79, 0x0f, 0x1a, 0x69,
	0x0b, 0xa3, 0x00, 0xcd, 0xba, 0x50, 0x88, 0x1a, 0xef, 0xfe, 0x53, 0x80, 0xd9, 0x7c, 0x42, 0x65,
	0xe0, 0xd5, 0x81, 0xaa, 0x88, 0x6b, 0xa8, 0x02, 0x1b, 0x27, 0x8a, 0xda, 0xeb, 0xab, 0x87, 0x22,
	0x87, 0x00, 0x4a, 0xfa, 0x97, 0x6a, 0x57, 0xe9, 0x89, 0x05, 0x24, 0x40, 0x51, 0xd1, 0xb4, 0x81,
	0x26, 0xae, 0xa3, 0x2a, 0x94, 0x7b, 0xca, 0xf0, 0xa0, 0xfb, 0x54, 0xe9, 0x89, 0xfc, 0x7d, 0x03,
	0x60, 0xb6, 0x85, 0x90, 0xf7, 0xa7, 0xea, 0x67, 0xea, 0xe0, 0x0b, 0x55, 0x5c, 0x23, 0x17, 0xbb,
	0xa7, 0xfa, 0x70, 0x70, 0xac, 0x68, 0x22, 0x47, 0x4e, 0xfa, 0xe9, 0xc9, 0xc9, 0x51, 0x5f, 0xd1,
	0xc4, 0x02, 0x95, 0xad, 0x1c, 0x1d, 0x29, 0x44, 0xa0, 0x08, 0x55, 0xfd, 0xf4, 0x44, 0xd1, 0x8c,
	0x88, 0xc2, 0x33, 0xcd, 0xfa, 0x50, 0x39, 0x16, 0x8b, 0xf7, 0x3f, 0x06, 0x21, 0x59, 0x2c, 0x50,
	0x0d, 0x04, 0x75, 0x60, 0x50, 0x4b, 0x74, 0x71, 0x0d, 0xd5, 0x01, 0xd4, 0xc1, 0xd0, 0x50, 0x9e,
	0xf5, 0xf5, 0xa1, 0x2e, 0x72, 0x84, 0xfd, 0x64, 0xa0, 0x3d, 0xee, 0xf7, 0x7a, 0x8a, 0x2a, 0x16,
	0x3a, 0x3f, 0x14, 0xa1, 0x42, 0xaa, 0x4f, 0xc7, 0xfe, 0xa5, 0x63, 0x61, 0xf4, 0x21, 0x40, 0x97,
	0x4e, 0x7b, 0xba, 0x9c, 0x36, 0x59, 0xd5, 0x66, 0xbf, 0xc5, 0x5a, 0x8d, 0x54, 0xb9, 0xd3, 0x72,
	0x5d, 0x43, 0x1d, 0x28, 0x1f, 0xe2, 0x90, 0x7e, 0xb3, 0x20, 0x34, 0x63, 0xc7, 0x1f, 0x30, 0x2d,
	0x31, 0x43, 0x63, 0x6f, 0x1e, 0x42, 0x39, 0xfe, 0x56, 0x41, 0x5b, 0x8c, 0x9f, 0xfb, 0x76, 0x59,
	0xa4, 0xe9, 0x11, 0x08, 0xc9, 0xd7, 0x07, 0xda, 0x66, 0xfc, 0xfc, 0xe7, 0xc8, 0xa2, 0x77, 0x3d,
	0xa8, 0x93, 0x95, 0x7f, 0x06, 0x61, 0x48, 0x8a, 0x96, 0x90, 0x39, 0xd0, 0x6f, 0x6d, 0x2f, 0xe0,
	0x24, 0x52, 0x22, 0x3f, 0xa3, 0x11, 0x1c, 0x4b, 0x99, 0x5f, 0x25, 0x62, 0x29, 0xf9, 0x79, 0x4d,
	0xa5, 0x54, 0xd3, 0x43, 0x0a, 0xdd, 0x8c, 0xc0, 0x61, 0x7e, 0x60, 0xb6, 0x76, 0x16, 0xb1, 0x98,
	0x14, 0x1d, 0x6e, 0x1c, 0xe2, 0x30, 0xdf, 0xf3, 0xe8, 0x36, 0x7b, 0xb1, 0x04, 0x3f, 0x5a, 0xb7,
	0x96, 0xb1, 0x99, 0xd0, 0x43, 0xa8, 0x65, 0xe6, 0x14, 0x6a, 0xb1, 0xfb, 0x8b, 0x86, 0x63, 0x4b,
	0x5a, 0xc8, 0x63, 0x82, 0x3e, 0x01, 0x98, 0xf5, 0x19, 0x8a, 0xdc, 0x98, 0xc3, 0x86, 0xd6, 0xd6,
	0x3c, 0x83, 0xbe, 0xef, 0xfc, 0xc1, 0x41, 0x59, 0xf5, 0x42, 0xe7, 0x85, 0x83, 0x7d, 0x22, 0x2c,
	0x95, 0xb8, 0x9d, 0xa4, 0x2a, 0x73, 0xf6, 0x6c, 0xcd, 0x33, 0x12, 0xaf, 0x32, 0x83, 0x23, 0xf6,
	0x6a, 0xd1, 0xf4, 0x8a, 0xbd, 0x5a, 0x30, 0x69, 0xa8, 0xa0, 0x0c, 0x5c, 0xc7, 0x82, 0x16, 0x0d,
	0xa0, 0x58, 0xd0, 0x02, 0x7c, 0x5f, 0x7b, 0x2c, 0xfe, 0xf6, 0x6a, 0x97, 0xfb, 0xfd, 0xd5, 0x2e,
	0xf7, 0xe7, 0xab, 0x5d, 0xee, 0xfb, 0xbf, 0x76, 0xd7, 0xce, 0x4a, 0xf4, 0x0f, 0x90, 0x0f, 0xfe,
	0x09, 0x00, 0x00, 0xff, 0xff, 0x63, 0xc1, 0x2a, 0x13, 0x0e, 0x11, 0x00, 0x00,
}
