// Code generated by protoc-gen-gogo.
// source: core.proto
// DO NOT EDIT!

/*
	Package core is a generated protocol buffer package.

	It is generated from these files:
		core.proto

	It has these top-level messages:
		ReadLeadRequest
		ReadLeadResult
		Lead
		CreateLeadResult
		UserLeadsRequest
		UserLeadsReply
		LeadInfo
		LeadEventMessage
		SetLeadStatusRequest
		SetLeadStatusReply
		CallSupplierRequest
		CallSupplierReply
		CallCustomerRequest
		CallCustomerReply
		GetLeadRequest
		GetLeadReply
		GetCancelReasonsRequest
		CancelReason
		GetCancelReasonsReply
		GetUserRoleRequest
		GetUserRoleReply
		GetPlanRequest
		MonezationPlan
		GetPlanReply
		GetPlansListRequest
		GetPlansListReply
		CoinsOffer
		GetCoinsOffersRequest
		GetCoinsOffersReply
		SubscribeRequest
		SubscribeReply
		SetAutorefillRequest
		SetAutorefillReply
		GetProductRequest
		SearchProductRequest
		ProductSearchResult
		ProductReadResult
		CreateProductRequest
		CreateProductResult
		Product
		ProductItem
		ImageCandidate
		GetLikedByRequest
		GetLikedByReply
		LikeProductRequest
		LikeProductReply
		GetSpecialProductsRequest
		SpecialProductInfo
		GetSpecialProductsReply
		GetLastProductIDRequest
		GetLastProductIDReply
		DelProductRequest
		DelProductReply
		TokenInfo
		AddTokenRequest
		DelTokenRequest
		ErrorResult
		GetTokensRequest
		GetTokensResult
		InvalidateTokensRequest
		InvalidateTokensResult
		UpdateTokenRequest
		UpdateTokenResult
		ShopCard
		CreateCardRequest
		CreateCardReply
		DeleteCardRequest
		DeleteCardReply
		GetCardsRequest
		GetCardsReply
		GetCardByIDRequest
		GetCardReply
		Shop
		ShopProfileRequest
		ShopProfileReply
		FindOrCreateShopForSupplierRequest
		FindOrCreateShopForSupplierReply
		FindOrCreateAttachedShopRequest
		FindOrCreateAttachedShopReply
		GetMainTagsRequest
		GetRelatedTagsRequest
		TagSearchResult
		Tag
		CreateUserRequest
		ReadUserRequest
		SearchUserReply
		ReadUserReply
		User
		SetEmailRequest
		SetEmailReply
		SetDataRequest
		SetDataReply
		AddTelegramRequest
		AddTelegramReply
		Telegram
		ListTelegramsRequest
		ListTelegramsReply
		ConfirmTelegramRequest
		ConfirmTelegramReply
		DelTelegramRequest
		DelTelegramReply
*/
package core

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type LeadAction int32

const (
	LeadAction_BUY LeadAction = 0
	// we don't want add item to lead for now
	// just send info to conversation instead
	LeadAction_INFO LeadAction = 1
	LeadAction_SKIP LeadAction = 2
)

var LeadAction_name = map[int32]string{
	0: "BUY",
	1: "INFO",
	2: "SKIP",
}
var LeadAction_value = map[string]int32{
	"BUY":  0,
	"INFO": 1,
	"SKIP": 2,
}

func (x LeadAction) String() string {
	return proto.EnumName(LeadAction_name, int32(x))
}
func (LeadAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorCore, []int{0} }

type LeadUserRole int32

const (
	LeadUserRole_UNKNOWN      LeadUserRole = 0
	LeadUserRole_CUSTOMER     LeadUserRole = 1
	LeadUserRole_SUPPLIER     LeadUserRole = 2
	LeadUserRole_SELLER       LeadUserRole = 3
	LeadUserRole_SUPER_SELLER LeadUserRole = 4
)

var LeadUserRole_name = map[int32]string{
	0: "UNKNOWN",
	1: "CUSTOMER",
	2: "SUPPLIER",
	3: "SELLER",
	4: "SUPER_SELLER",
}
var LeadUserRole_value = map[string]int32{
	"UNKNOWN":      0,
	"CUSTOMER":     1,
	"SUPPLIER":     2,
	"SELLER":       3,
	"SUPER_SELLER": 4,
}

func (x LeadUserRole) String() string {
	return proto.EnumName(LeadUserRole_name, int32(x))
}
func (LeadUserRole) EnumDescriptor() ([]byte, []int) { return fileDescriptorCore, []int{1} }

type LeadStatus int32

const (
	// this status means we created a lead in db, but did not perform any predefined actions
	LeadStatus_EMPTY       LeadStatus = 0
	LeadStatus_NEW         LeadStatus = 1
	LeadStatus_IN_PROGRESS LeadStatus = 2
	LeadStatus_SUBMITTED   LeadStatus = 3
	LeadStatus_ON_DELIVERY LeadStatus = 4
	LeadStatus_COMPLETED   LeadStatus = 5
	LeadStatus_CANCELLED   LeadStatus = 6
)

var LeadStatus_name = map[int32]string{
	0: "EMPTY",
	1: "NEW",
	2: "IN_PROGRESS",
	3: "SUBMITTED",
	4: "ON_DELIVERY",
	5: "COMPLETED",
	6: "CANCELLED",
}
var LeadStatus_value = map[string]int32{
	"EMPTY":       0,
	"NEW":         1,
	"IN_PROGRESS": 2,
	"SUBMITTED":   3,
	"ON_DELIVERY": 4,
	"COMPLETED":   5,
	"CANCELLED":   6,
}

func (x LeadStatus) String() string {
	return proto.EnumName(LeadStatus_name, int32(x))
}
func (LeadStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorCore, []int{2} }

type LeadStatusEvent int32

const (
	LeadStatusEvent_CREATE   LeadStatusEvent = 0
	LeadStatusEvent_PROGRESS LeadStatusEvent = 1
	LeadStatusEvent_SUBMIT   LeadStatusEvent = 2
	LeadStatusEvent_DELIVERY LeadStatusEvent = 3
	LeadStatusEvent_COMPLETE LeadStatusEvent = 4
	LeadStatusEvent_CANCEL   LeadStatusEvent = 5
)

var LeadStatusEvent_name = map[int32]string{
	0: "CREATE",
	1: "PROGRESS",
	2: "SUBMIT",
	3: "DELIVERY",
	4: "COMPLETE",
	5: "CANCEL",
}
var LeadStatusEvent_value = map[string]int32{
	"CREATE":   0,
	"PROGRESS": 1,
	"SUBMIT":   2,
	"DELIVERY": 3,
	"COMPLETE": 4,
	"CANCEL":   5,
}

func (x LeadStatusEvent) String() string {
	return proto.EnumName(LeadStatusEvent_name, int32(x))
}
func (LeadStatusEvent) EnumDescriptor() ([]byte, []int) { return fileDescriptorCore, []int{3} }

type TokenType int32

const (
	TokenType_Android TokenType = 0
	TokenType_Iphone  TokenType = 1
)

var TokenType_name = map[int32]string{
	0: "Android",
	1: "Iphone",
}
var TokenType_value = map[string]int32{
	"Android": 0,
	"Iphone":  1,
}

func (x TokenType) String() string {
	return proto.EnumName(TokenType_name, int32(x))
}
func (TokenType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCore, []int{4} }

type ReadLeadRequest struct {
	// Types that are valid to be assigned to SearchBy:
	//	*ReadLeadRequest_Id
	//	*ReadLeadRequest_InstagramPk
	//	*ReadLeadRequest_ConversationId
	SearchBy isReadLeadRequest_SearchBy `protobuf_oneof:"search_by"`
}

func (m *ReadLeadRequest) Reset()                    { *m = ReadLeadRequest{} }
func (m *ReadLeadRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadLeadRequest) ProtoMessage()               {}
func (*ReadLeadRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{0} }

type isReadLeadRequest_SearchBy interface {
	isReadLeadRequest_SearchBy()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReadLeadRequest_Id struct {
	Id int64 `protobuf:"varint,1,opt,name=id,proto3,oneof"`
}
type ReadLeadRequest_InstagramPk struct {
	InstagramPk string `protobuf:"bytes,2,opt,name=instagram_pk,json=instagramPk,proto3,oneof"`
}
type ReadLeadRequest_ConversationId struct {
	ConversationId uint64 `protobuf:"varint,3,opt,name=conversation_id,json=conversationId,proto3,oneof"`
}

func (*ReadLeadRequest_Id) isReadLeadRequest_SearchBy()             {}
func (*ReadLeadRequest_InstagramPk) isReadLeadRequest_SearchBy()    {}
func (*ReadLeadRequest_ConversationId) isReadLeadRequest_SearchBy() {}

func (m *ReadLeadRequest) GetSearchBy() isReadLeadRequest_SearchBy {
	if m != nil {
		return m.SearchBy
	}
	return nil
}

func (m *ReadLeadRequest) GetId() int64 {
	if x, ok := m.GetSearchBy().(*ReadLeadRequest_Id); ok {
		return x.Id
	}
	return 0
}

func (m *ReadLeadRequest) GetInstagramPk() string {
	if x, ok := m.GetSearchBy().(*ReadLeadRequest_InstagramPk); ok {
		return x.InstagramPk
	}
	return ""
}

func (m *ReadLeadRequest) GetConversationId() uint64 {
	if x, ok := m.GetSearchBy().(*ReadLeadRequest_ConversationId); ok {
		return x.ConversationId
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ReadLeadRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ReadLeadRequest_OneofMarshaler, _ReadLeadRequest_OneofUnmarshaler, _ReadLeadRequest_OneofSizer, []interface{}{
		(*ReadLeadRequest_Id)(nil),
		(*ReadLeadRequest_InstagramPk)(nil),
		(*ReadLeadRequest_ConversationId)(nil),
	}
}

func _ReadLeadRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ReadLeadRequest)
	// search_by
	switch x := m.SearchBy.(type) {
	case *ReadLeadRequest_Id:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Id))
	case *ReadLeadRequest_InstagramPk:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.InstagramPk)
	case *ReadLeadRequest_ConversationId:
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.ConversationId))
	case nil:
	default:
		return fmt.Errorf("ReadLeadRequest.SearchBy has unexpected type %T", x)
	}
	return nil
}

func _ReadLeadRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ReadLeadRequest)
	switch tag {
	case 1: // search_by.id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.SearchBy = &ReadLeadRequest_Id{int64(x)}
		return true, err
	case 2: // search_by.instagram_pk
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.SearchBy = &ReadLeadRequest_InstagramPk{x}
		return true, err
	case 3: // search_by.conversation_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.SearchBy = &ReadLeadRequest_ConversationId{x}
		return true, err
	default:
		return false, nil
	}
}

func _ReadLeadRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ReadLeadRequest)
	// search_by
	switch x := m.SearchBy.(type) {
	case *ReadLeadRequest_Id:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Id))
	case *ReadLeadRequest_InstagramPk:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.InstagramPk)))
		n += len(x.InstagramPk)
	case *ReadLeadRequest_ConversationId:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.ConversationId))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ReadLeadResult struct {
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *ReadLeadResult) Reset()                    { *m = ReadLeadResult{} }
func (m *ReadLeadResult) String() string            { return proto.CompactTextString(m) }
func (*ReadLeadResult) ProtoMessage()               {}
func (*ReadLeadResult) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{1} }

func (m *ReadLeadResult) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

// representation of lead model
type Lead struct {
	Id     int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Source string `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	// source thread(if any)
	DirectThread     string     `protobuf:"bytes,9,opt,name=direct_thread,json=directThread,proto3" json:"direct_thread,omitempty"`
	Comment          string     `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
	CustomerId       int64      `protobuf:"varint,4,opt,name=customer_id,json=customerId,proto3" json:"customer_id,omitempty"`
	InstagramPk      string     `protobuf:"bytes,5,opt,name=instagram_pk,json=instagramPk,proto3" json:"instagram_pk,omitempty"`
	InstagramLink    string     `protobuf:"bytes,7,opt,name=instagram_link,json=instagramLink,proto3" json:"instagram_link,omitempty"`
	InstagramMediaId string     `protobuf:"bytes,10,opt,name=instagram_media_id,json=instagramMediaId,proto3" json:"instagram_media_id,omitempty"`
	ProductId        int64      `protobuf:"varint,6,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	Action           LeadAction `protobuf:"varint,8,opt,name=action,proto3,enum=core.LeadAction" json:"action,omitempty"`
}

func (m *Lead) Reset()                    { *m = Lead{} }
func (m *Lead) String() string            { return proto.CompactTextString(m) }
func (*Lead) ProtoMessage()               {}
func (*Lead) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{2} }

func (m *Lead) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Lead) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *Lead) GetDirectThread() string {
	if m != nil {
		return m.DirectThread
	}
	return ""
}

func (m *Lead) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *Lead) GetCustomerId() int64 {
	if m != nil {
		return m.CustomerId
	}
	return 0
}

func (m *Lead) GetInstagramPk() string {
	if m != nil {
		return m.InstagramPk
	}
	return ""
}

func (m *Lead) GetInstagramLink() string {
	if m != nil {
		return m.InstagramLink
	}
	return ""
}

func (m *Lead) GetInstagramMediaId() string {
	if m != nil {
		return m.InstagramMediaId
	}
	return ""
}

func (m *Lead) GetProductId() int64 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

func (m *Lead) GetAction() LeadAction {
	if m != nil {
		return m.Action
	}
	return LeadAction_BUY
}

type CreateLeadResult struct {
	Id   int64     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Lead *LeadInfo `protobuf:"bytes,2,opt,name=lead" json:"lead,omitempty"`
}

func (m *CreateLeadResult) Reset()                    { *m = CreateLeadResult{} }
func (m *CreateLeadResult) String() string            { return proto.CompactTextString(m) }
func (*CreateLeadResult) ProtoMessage()               {}
func (*CreateLeadResult) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{3} }

func (m *CreateLeadResult) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CreateLeadResult) GetLead() *LeadInfo {
	if m != nil {
		return m.Lead
	}
	return nil
}

type UserLeadsRequest struct {
	UserId uint64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// filter leads by user's role in the lead
	Role []LeadUserRole `protobuf:"varint,2,rep,packed,name=role,enum=core.LeadUserRole" json:"role,omitempty"`
	// todo: remove lead_id
	// also you can pass concrete lead_id
	LeadId uint64 `protobuf:"varint,3,opt,name=lead_id,json=leadId,proto3" json:"lead_id,omitempty"`
	Limit  uint64 `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	// if true - asc, false - desc
	Direction bool `protobuf:"varint,5,opt,name=direction,proto3" json:"direction,omitempty"`
	// shift to this time
	FromUpdatedAt int64 `protobuf:"varint,6,opt,name=from_updated_at,json=fromUpdatedAt,proto3" json:"from_updated_at,omitempty"`
}

func (m *UserLeadsRequest) Reset()                    { *m = UserLeadsRequest{} }
func (m *UserLeadsRequest) String() string            { return proto.CompactTextString(m) }
func (*UserLeadsRequest) ProtoMessage()               {}
func (*UserLeadsRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{4} }

func (m *UserLeadsRequest) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserLeadsRequest) GetRole() []LeadUserRole {
	if m != nil {
		return m.Role
	}
	return nil
}

func (m *UserLeadsRequest) GetLeadId() uint64 {
	if m != nil {
		return m.LeadId
	}
	return 0
}

func (m *UserLeadsRequest) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *UserLeadsRequest) GetDirection() bool {
	if m != nil {
		return m.Direction
	}
	return false
}

func (m *UserLeadsRequest) GetFromUpdatedAt() int64 {
	if m != nil {
		return m.FromUpdatedAt
	}
	return 0
}

type UserLeadsReply struct {
	Leads []*LeadInfo `protobuf:"bytes,1,rep,name=leads" json:"leads,omitempty"`
}

func (m *UserLeadsReply) Reset()                    { *m = UserLeadsReply{} }
func (m *UserLeadsReply) String() string            { return proto.CompactTextString(m) }
func (*UserLeadsReply) ProtoMessage()               {}
func (*UserLeadsReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{5} }

func (m *UserLeadsReply) GetLeads() []*LeadInfo {
	if m != nil {
		return m.Leads
	}
	return nil
}

type LeadInfo struct {
	Id               uint64       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Source           string       `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	Comment          string       `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
	CustomerId       uint64       `protobuf:"varint,4,opt,name=customer_id,json=customerId,proto3" json:"customer_id,omitempty"`
	Products         []*Product   `protobuf:"bytes,5,rep,name=products" json:"products,omitempty"`
	InstagramPk      string       `protobuf:"bytes,7,opt,name=instagram_pk,json=instagramPk,proto3" json:"instagram_pk,omitempty"`
	InstagramLink    string       `protobuf:"bytes,14,opt,name=instagram_link,json=instagramLink,proto3" json:"instagram_link,omitempty"`
	InstagramMediaId string       `protobuf:"bytes,18,opt,name=instagram_media_id,json=instagramMediaId,proto3" json:"instagram_media_id,omitempty"`
	Customer         *User        `protobuf:"bytes,8,opt,name=customer" json:"customer,omitempty"`
	Status           LeadStatus   `protobuf:"varint,9,opt,name=status,proto3,enum=core.LeadStatus" json:"status,omitempty"`
	UserRole         LeadUserRole `protobuf:"varint,10,opt,name=user_role,json=userRole,proto3,enum=core.LeadUserRole" json:"user_role,omitempty"`
	ConversationId   uint64       `protobuf:"varint,11,opt,name=conversation_id,json=conversationId,proto3" json:"conversation_id,omitempty"`
	Shop             *Shop        `protobuf:"bytes,12,opt,name=shop" json:"shop,omitempty"`
	UpdatedAt        int64        `protobuf:"varint,13,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	CancelReason     uint64       `protobuf:"varint,15,opt,name=cancel_reason,json=cancelReason,proto3" json:"cancel_reason,omitempty"`
	StatusComment    string       `protobuf:"bytes,16,opt,name=status_comment,json=statusComment,proto3" json:"status_comment,omitempty"`
	UpdatedAtAgo     int64        `protobuf:"varint,17,opt,name=updated_at_ago,json=updatedAtAgo,proto3" json:"updated_at_ago,omitempty"`
}

func (m *LeadInfo) Reset()                    { *m = LeadInfo{} }
func (m *LeadInfo) String() string            { return proto.CompactTextString(m) }
func (*LeadInfo) ProtoMessage()               {}
func (*LeadInfo) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{6} }

func (m *LeadInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LeadInfo) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *LeadInfo) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *LeadInfo) GetCustomerId() uint64 {
	if m != nil {
		return m.CustomerId
	}
	return 0
}

func (m *LeadInfo) GetProducts() []*Product {
	if m != nil {
		return m.Products
	}
	return nil
}

func (m *LeadInfo) GetInstagramPk() string {
	if m != nil {
		return m.InstagramPk
	}
	return ""
}

func (m *LeadInfo) GetInstagramLink() string {
	if m != nil {
		return m.InstagramLink
	}
	return ""
}

func (m *LeadInfo) GetInstagramMediaId() string {
	if m != nil {
		return m.InstagramMediaId
	}
	return ""
}

func (m *LeadInfo) GetCustomer() *User {
	if m != nil {
		return m.Customer
	}
	return nil
}

func (m *LeadInfo) GetStatus() LeadStatus {
	if m != nil {
		return m.Status
	}
	return LeadStatus_EMPTY
}

func (m *LeadInfo) GetUserRole() LeadUserRole {
	if m != nil {
		return m.UserRole
	}
	return LeadUserRole_UNKNOWN
}

func (m *LeadInfo) GetConversationId() uint64 {
	if m != nil {
		return m.ConversationId
	}
	return 0
}

func (m *LeadInfo) GetShop() *Shop {
	if m != nil {
		return m.Shop
	}
	return nil
}

func (m *LeadInfo) GetUpdatedAt() int64 {
	if m != nil {
		return m.UpdatedAt
	}
	return 0
}

func (m *LeadInfo) GetCancelReason() uint64 {
	if m != nil {
		return m.CancelReason
	}
	return 0
}

func (m *LeadInfo) GetStatusComment() string {
	if m != nil {
		return m.StatusComment
	}
	return ""
}

func (m *LeadInfo) GetUpdatedAtAgo() int64 {
	if m != nil {
		return m.UpdatedAtAgo
	}
	return 0
}

type LeadEventMessage struct {
	LeadId uint64   `protobuf:"varint,1,opt,name=lead_id,json=leadId,proto3" json:"lead_id,omitempty"`
	Event  string   `protobuf:"bytes,2,opt,name=event,proto3" json:"event,omitempty"`
	Users  []uint64 `protobuf:"varint,3,rep,packed,name=users" json:"users,omitempty"`
}

func (m *LeadEventMessage) Reset()                    { *m = LeadEventMessage{} }
func (m *LeadEventMessage) String() string            { return proto.CompactTextString(m) }
func (*LeadEventMessage) ProtoMessage()               {}
func (*LeadEventMessage) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{7} }

func (m *LeadEventMessage) GetLeadId() uint64 {
	if m != nil {
		return m.LeadId
	}
	return 0
}

func (m *LeadEventMessage) GetEvent() string {
	if m != nil {
		return m.Event
	}
	return ""
}

func (m *LeadEventMessage) GetUsers() []uint64 {
	if m != nil {
		return m.Users
	}
	return nil
}

type SetLeadStatusRequest struct {
	LeadId        uint64          `protobuf:"varint,1,opt,name=lead_id,json=leadId,proto3" json:"lead_id,omitempty"`
	Event         LeadStatusEvent `protobuf:"varint,2,opt,name=event,proto3,enum=core.LeadStatusEvent" json:"event,omitempty"`
	UserId        uint64          `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	CancelReason  uint64          `protobuf:"varint,4,opt,name=cancel_reason,json=cancelReason,proto3" json:"cancel_reason,omitempty"`
	StatusComment string          `protobuf:"bytes,5,opt,name=status_comment,json=statusComment,proto3" json:"status_comment,omitempty"`
}

func (m *SetLeadStatusRequest) Reset()                    { *m = SetLeadStatusRequest{} }
func (m *SetLeadStatusRequest) String() string            { return proto.CompactTextString(m) }
func (*SetLeadStatusRequest) ProtoMessage()               {}
func (*SetLeadStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{8} }

func (m *SetLeadStatusRequest) GetLeadId() uint64 {
	if m != nil {
		return m.LeadId
	}
	return 0
}

func (m *SetLeadStatusRequest) GetEvent() LeadStatusEvent {
	if m != nil {
		return m.Event
	}
	return LeadStatusEvent_CREATE
}

func (m *SetLeadStatusRequest) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SetLeadStatusRequest) GetCancelReason() uint64 {
	if m != nil {
		return m.CancelReason
	}
	return 0
}

func (m *SetLeadStatusRequest) GetStatusComment() string {
	if m != nil {
		return m.StatusComment
	}
	return ""
}

type SetLeadStatusReply struct {
	Lead *LeadInfo `protobuf:"bytes,1,opt,name=lead" json:"lead,omitempty"`
}

func (m *SetLeadStatusReply) Reset()                    { *m = SetLeadStatusReply{} }
func (m *SetLeadStatusReply) String() string            { return proto.CompactTextString(m) }
func (*SetLeadStatusReply) ProtoMessage()               {}
func (*SetLeadStatusReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{9} }

func (m *SetLeadStatusReply) GetLead() *LeadInfo {
	if m != nil {
		return m.Lead
	}
	return nil
}

type CallSupplierRequest struct {
	LeadId uint64 `protobuf:"varint,1,opt,name=lead_id,json=leadId,proto3" json:"lead_id,omitempty"`
}

func (m *CallSupplierRequest) Reset()                    { *m = CallSupplierRequest{} }
func (m *CallSupplierRequest) String() string            { return proto.CompactTextString(m) }
func (*CallSupplierRequest) ProtoMessage()               {}
func (*CallSupplierRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{10} }

func (m *CallSupplierRequest) GetLeadId() uint64 {
	if m != nil {
		return m.LeadId
	}
	return 0
}

type CallSupplierReply struct {
}

func (m *CallSupplierReply) Reset()                    { *m = CallSupplierReply{} }
func (m *CallSupplierReply) String() string            { return proto.CompactTextString(m) }
func (*CallSupplierReply) ProtoMessage()               {}
func (*CallSupplierReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{11} }

type CallCustomerRequest struct {
	LeadId uint64 `protobuf:"varint,1,opt,name=lead_id,json=leadId,proto3" json:"lead_id,omitempty"`
}

func (m *CallCustomerRequest) Reset()                    { *m = CallCustomerRequest{} }
func (m *CallCustomerRequest) String() string            { return proto.CompactTextString(m) }
func (*CallCustomerRequest) ProtoMessage()               {}
func (*CallCustomerRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{12} }

func (m *CallCustomerRequest) GetLeadId() uint64 {
	if m != nil {
		return m.LeadId
	}
	return 0
}

type CallCustomerReply struct {
}

func (m *CallCustomerReply) Reset()                    { *m = CallCustomerReply{} }
func (m *CallCustomerReply) String() string            { return proto.CompactTextString(m) }
func (*CallCustomerReply) ProtoMessage()               {}
func (*CallCustomerReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{13} }

type GetLeadRequest struct {
	UserId uint64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// Types that are valid to be assigned to SearchBy:
	//	*GetLeadRequest_Id
	//	*GetLeadRequest_ConversationId
	SearchBy isGetLeadRequest_SearchBy `protobuf_oneof:"search_by"`
}

func (m *GetLeadRequest) Reset()                    { *m = GetLeadRequest{} }
func (m *GetLeadRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLeadRequest) ProtoMessage()               {}
func (*GetLeadRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{14} }

type isGetLeadRequest_SearchBy interface {
	isGetLeadRequest_SearchBy()
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetLeadRequest_Id struct {
	Id uint64 `protobuf:"varint,2,opt,name=id,proto3,oneof"`
}
type GetLeadRequest_ConversationId struct {
	ConversationId uint64 `protobuf:"varint,3,opt,name=conversation_id,json=conversationId,proto3,oneof"`
}

func (*GetLeadRequest_Id) isGetLeadRequest_SearchBy()             {}
func (*GetLeadRequest_ConversationId) isGetLeadRequest_SearchBy() {}

func (m *GetLeadRequest) GetSearchBy() isGetLeadRequest_SearchBy {
	if m != nil {
		return m.SearchBy
	}
	return nil
}

func (m *GetLeadRequest) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GetLeadRequest) GetId() uint64 {
	if x, ok := m.GetSearchBy().(*GetLeadRequest_Id); ok {
		return x.Id
	}
	return 0
}

func (m *GetLeadRequest) GetConversationId() uint64 {
	if x, ok := m.GetSearchBy().(*GetLeadRequest_ConversationId); ok {
		return x.ConversationId
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetLeadRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetLeadRequest_OneofMarshaler, _GetLeadRequest_OneofUnmarshaler, _GetLeadRequest_OneofSizer, []interface{}{
		(*GetLeadRequest_Id)(nil),
		(*GetLeadRequest_ConversationId)(nil),
	}
}

func _GetLeadRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetLeadRequest)
	// search_by
	switch x := m.SearchBy.(type) {
	case *GetLeadRequest_Id:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Id))
	case *GetLeadRequest_ConversationId:
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.ConversationId))
	case nil:
	default:
		return fmt.Errorf("GetLeadRequest.SearchBy has unexpected type %T", x)
	}
	return nil
}

func _GetLeadRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetLeadRequest)
	switch tag {
	case 2: // search_by.id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.SearchBy = &GetLeadRequest_Id{x}
		return true, err
	case 3: // search_by.conversation_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.SearchBy = &GetLeadRequest_ConversationId{x}
		return true, err
	default:
		return false, nil
	}
}

func _GetLeadRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetLeadRequest)
	// search_by
	switch x := m.SearchBy.(type) {
	case *GetLeadRequest_Id:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Id))
	case *GetLeadRequest_ConversationId:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.ConversationId))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GetLeadReply struct {
	Lead *LeadInfo `protobuf:"bytes,1,opt,name=lead" json:"lead,omitempty"`
}

func (m *GetLeadReply) Reset()                    { *m = GetLeadReply{} }
func (m *GetLeadReply) String() string            { return proto.CompactTextString(m) }
func (*GetLeadReply) ProtoMessage()               {}
func (*GetLeadReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{15} }

func (m *GetLeadReply) GetLead() *LeadInfo {
	if m != nil {
		return m.Lead
	}
	return nil
}

type GetCancelReasonsRequest struct {
}

func (m *GetCancelReasonsRequest) Reset()                    { *m = GetCancelReasonsRequest{} }
func (m *GetCancelReasonsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetCancelReasonsRequest) ProtoMessage()               {}
func (*GetCancelReasonsRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{16} }

type CancelReason struct {
	Id   uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *CancelReason) Reset()                    { *m = CancelReason{} }
func (m *CancelReason) String() string            { return proto.CompactTextString(m) }
func (*CancelReason) ProtoMessage()               {}
func (*CancelReason) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{17} }

func (m *CancelReason) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CancelReason) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type GetCancelReasonsReply struct {
	Reasons []*CancelReason `protobuf:"bytes,1,rep,name=reasons" json:"reasons,omitempty"`
}

func (m *GetCancelReasonsReply) Reset()                    { *m = GetCancelReasonsReply{} }
func (m *GetCancelReasonsReply) String() string            { return proto.CompactTextString(m) }
func (*GetCancelReasonsReply) ProtoMessage()               {}
func (*GetCancelReasonsReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{18} }

func (m *GetCancelReasonsReply) GetReasons() []*CancelReason {
	if m != nil {
		return m.Reasons
	}
	return nil
}

type GetUserRoleRequest struct {
	UserId          uint64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	InstagramUserId uint64 `protobuf:"varint,2,opt,name=instagram_user_id,json=instagramUserId,proto3" json:"instagram_user_id,omitempty"`
	LeadId          uint64 `protobuf:"varint,5,opt,name=lead_id,json=leadId,proto3" json:"lead_id,omitempty"`
	ConversationId  uint64 `protobuf:"varint,6,opt,name=conversation_id,json=conversationId,proto3" json:"conversation_id,omitempty"`
}

func (m *GetUserRoleRequest) Reset()                    { *m = GetUserRoleRequest{} }
func (m *GetUserRoleRequest) String() string            { return proto.CompactTextString(m) }
func (*GetUserRoleRequest) ProtoMessage()               {}
func (*GetUserRoleRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{19} }

func (m *GetUserRoleRequest) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GetUserRoleRequest) GetInstagramUserId() uint64 {
	if m != nil {
		return m.InstagramUserId
	}
	return 0
}

func (m *GetUserRoleRequest) GetLeadId() uint64 {
	if m != nil {
		return m.LeadId
	}
	return 0
}

func (m *GetUserRoleRequest) GetConversationId() uint64 {
	if m != nil {
		return m.ConversationId
	}
	return 0
}

type GetUserRoleReply struct {
	Role  LeadUserRole `protobuf:"varint,1,opt,name=role,proto3,enum=core.LeadUserRole" json:"role,omitempty"`
	Error string       `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *GetUserRoleReply) Reset()                    { *m = GetUserRoleReply{} }
func (m *GetUserRoleReply) String() string            { return proto.CompactTextString(m) }
func (*GetUserRoleReply) ProtoMessage()               {}
func (*GetUserRoleReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{20} }

func (m *GetUserRoleReply) GetRole() LeadUserRole {
	if m != nil {
		return m.Role
	}
	return LeadUserRole_UNKNOWN
}

func (m *GetUserRoleReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type GetPlanRequest struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GetPlanRequest) Reset()                    { *m = GetPlanRequest{} }
func (m *GetPlanRequest) String() string            { return proto.CompactTextString(m) }
func (*GetPlanRequest) ProtoMessage()               {}
func (*GetPlanRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{21} }

func (m *GetPlanRequest) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type MonezationPlan struct {
	Id                    uint64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                  string  `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	About                 string  `protobuf:"bytes,3,opt,name=about,proto3" json:"about,omitempty"`
	PrimaryCurrency       string  `protobuf:"bytes,4,opt,name=primary_currency,json=primaryCurrency,proto3" json:"primary_currency,omitempty"`
	SubscriptionPeriod    uint64  `protobuf:"varint,5,opt,name=subscription_period,json=subscriptionPeriod,proto3" json:"subscription_period,omitempty"`
	SubscriptionPrice     uint64  `protobuf:"varint,6,opt,name=subscription_price,json=subscriptionPrice,proto3" json:"subscription_price,omitempty"`
	TransactionCommission float64 `protobuf:"fixed64,7,opt,name=transaction_commission,json=transactionCommission,proto3" json:"transaction_commission,omitempty"`
	CoinsExchangeRate     float64 `protobuf:"fixed64,8,opt,name=coins_exchange_rate,json=coinsExchangeRate,proto3" json:"coins_exchange_rate,omitempty"`
	Public                bool    `protobuf:"varint,9,opt,name=public,proto3" json:"public,omitempty"`
	DirectbotEnabled      bool    `protobuf:"varint,10,opt,name=directbot_enabled,json=directbotEnabled,proto3" json:"directbot_enabled,omitempty"`
}

func (m *MonezationPlan) Reset()                    { *m = MonezationPlan{} }
func (m *MonezationPlan) String() string            { return proto.CompactTextString(m) }
func (*MonezationPlan) ProtoMessage()               {}
func (*MonezationPlan) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{22} }

func (m *MonezationPlan) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MonezationPlan) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MonezationPlan) GetAbout() string {
	if m != nil {
		return m.About
	}
	return ""
}

func (m *MonezationPlan) GetPrimaryCurrency() string {
	if m != nil {
		return m.PrimaryCurrency
	}
	return ""
}

func (m *MonezationPlan) GetSubscriptionPeriod() uint64 {
	if m != nil {
		return m.SubscriptionPeriod
	}
	return 0
}

func (m *MonezationPlan) GetSubscriptionPrice() uint64 {
	if m != nil {
		return m.SubscriptionPrice
	}
	return 0
}

func (m *MonezationPlan) GetTransactionCommission() float64 {
	if m != nil {
		return m.TransactionCommission
	}
	return 0
}

func (m *MonezationPlan) GetCoinsExchangeRate() float64 {
	if m != nil {
		return m.CoinsExchangeRate
	}
	return 0
}

func (m *MonezationPlan) GetPublic() bool {
	if m != nil {
		return m.Public
	}
	return false
}

func (m *MonezationPlan) GetDirectbotEnabled() bool {
	if m != nil {
		return m.DirectbotEnabled
	}
	return false
}

type GetPlanReply struct {
	Plan  *MonezationPlan `protobuf:"bytes,1,opt,name=plan" json:"plan,omitempty"`
	Error string          `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *GetPlanReply) Reset()                    { *m = GetPlanReply{} }
func (m *GetPlanReply) String() string            { return proto.CompactTextString(m) }
func (*GetPlanReply) ProtoMessage()               {}
func (*GetPlanReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{23} }

func (m *GetPlanReply) GetPlan() *MonezationPlan {
	if m != nil {
		return m.Plan
	}
	return nil
}

func (m *GetPlanReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type GetPlansListRequest struct {
	Currency string `protobuf:"bytes,1,opt,name=currency,proto3" json:"currency,omitempty"`
	WithBot  bool   `protobuf:"varint,2,opt,name=with_bot,json=withBot,proto3" json:"with_bot,omitempty"`
}

func (m *GetPlansListRequest) Reset()                    { *m = GetPlansListRequest{} }
func (m *GetPlansListRequest) String() string            { return proto.CompactTextString(m) }
func (*GetPlansListRequest) ProtoMessage()               {}
func (*GetPlansListRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{24} }

func (m *GetPlansListRequest) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *GetPlansListRequest) GetWithBot() bool {
	if m != nil {
		return m.WithBot
	}
	return false
}

type GetPlansListReply struct {
	Plans []*MonezationPlan `protobuf:"bytes,1,rep,name=plans" json:"plans,omitempty"`
	Error string            `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *GetPlansListReply) Reset()                    { *m = GetPlansListReply{} }
func (m *GetPlansListReply) String() string            { return proto.CompactTextString(m) }
func (*GetPlansListReply) ProtoMessage()               {}
func (*GetPlansListReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{25} }

func (m *GetPlansListReply) GetPlans() []*MonezationPlan {
	if m != nil {
		return m.Plans
	}
	return nil
}

func (m *GetPlansListReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type CoinsOffer struct {
	Id       uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Amount   uint64 `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
	Price    uint64 `protobuf:"varint,3,opt,name=price,proto3" json:"price,omitempty"`
	Currency string `protobuf:"bytes,4,opt,name=currency,proto3" json:"currency,omitempty"`
}

func (m *CoinsOffer) Reset()                    { *m = CoinsOffer{} }
func (m *CoinsOffer) String() string            { return proto.CompactTextString(m) }
func (*CoinsOffer) ProtoMessage()               {}
func (*CoinsOffer) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{26} }

func (m *CoinsOffer) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CoinsOffer) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *CoinsOffer) GetPrice() uint64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *CoinsOffer) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

type GetCoinsOffersRequest struct {
	Currency string `protobuf:"bytes,1,opt,name=currency,proto3" json:"currency,omitempty"`
	// get single offer by id
	OfferId uint64 `protobuf:"varint,2,opt,name=offer_id,json=offerId,proto3" json:"offer_id,omitempty"`
}

func (m *GetCoinsOffersRequest) Reset()                    { *m = GetCoinsOffersRequest{} }
func (m *GetCoinsOffersRequest) String() string            { return proto.CompactTextString(m) }
func (*GetCoinsOffersRequest) ProtoMessage()               {}
func (*GetCoinsOffersRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{27} }

func (m *GetCoinsOffersRequest) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *GetCoinsOffersRequest) GetOfferId() uint64 {
	if m != nil {
		return m.OfferId
	}
	return 0
}

type GetCoinsOffersReply struct {
	Offers []*CoinsOffer `protobuf:"bytes,1,rep,name=offers" json:"offers,omitempty"`
	Error  string        `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *GetCoinsOffersReply) Reset()                    { *m = GetCoinsOffersReply{} }
func (m *GetCoinsOffersReply) String() string            { return proto.CompactTextString(m) }
func (*GetCoinsOffersReply) ProtoMessage()               {}
func (*GetCoinsOffersReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{28} }

func (m *GetCoinsOffersReply) GetOffers() []*CoinsOffer {
	if m != nil {
		return m.Offers
	}
	return nil
}

func (m *GetCoinsOffersReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type SubscribeRequest struct {
	ShopId uint64 `protobuf:"varint,1,opt,name=shop_id,json=shopId,proto3" json:"shop_id,omitempty"`
	// should be supplier of shop
	UserId      uint64 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	PlanId      uint64 `protobuf:"varint,3,opt,name=plan_id,json=planId,proto3" json:"plan_id,omitempty"`
	AutoRenewal bool   `protobuf:"varint,4,opt,name=auto_renewal,json=autoRenewal,proto3" json:"auto_renewal,omitempty"`
}

func (m *SubscribeRequest) Reset()                    { *m = SubscribeRequest{} }
func (m *SubscribeRequest) String() string            { return proto.CompactTextString(m) }
func (*SubscribeRequest) ProtoMessage()               {}
func (*SubscribeRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{29} }

func (m *SubscribeRequest) GetShopId() uint64 {
	if m != nil {
		return m.ShopId
	}
	return 0
}

func (m *SubscribeRequest) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SubscribeRequest) GetPlanId() uint64 {
	if m != nil {
		return m.PlanId
	}
	return 0
}

func (m *SubscribeRequest) GetAutoRenewal() bool {
	if m != nil {
		return m.AutoRenewal
	}
	return false
}

type SubscribeReply struct {
	Ok    bool   `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *SubscribeReply) Reset()                    { *m = SubscribeReply{} }
func (m *SubscribeReply) String() string            { return proto.CompactTextString(m) }
func (*SubscribeReply) ProtoMessage()               {}
func (*SubscribeReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{30} }

func (m *SubscribeReply) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *SubscribeReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type SetAutorefillRequest struct {
	UserId  uint64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	OfferId uint64 `protobuf:"varint,2,opt,name=offer_id,json=offerId,proto3" json:"offer_id,omitempty"`
}

func (m *SetAutorefillRequest) Reset()                    { *m = SetAutorefillRequest{} }
func (m *SetAutorefillRequest) String() string            { return proto.CompactTextString(m) }
func (*SetAutorefillRequest) ProtoMessage()               {}
func (*SetAutorefillRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{31} }

func (m *SetAutorefillRequest) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SetAutorefillRequest) GetOfferId() uint64 {
	if m != nil {
		return m.OfferId
	}
	return 0
}

type SetAutorefillReply struct {
	Error string `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *SetAutorefillReply) Reset()                    { *m = SetAutorefillReply{} }
func (m *SetAutorefillReply) String() string            { return proto.CompactTextString(m) }
func (*SetAutorefillReply) ProtoMessage()               {}
func (*SetAutorefillReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{32} }

func (m *SetAutorefillReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type GetProductRequest struct {
	// Types that are valid to be assigned to SearchBy:
	//	*GetProductRequest_Id
	//	*GetProductRequest_Code
	//	*GetProductRequest_MediaId
	SearchBy    isGetProductRequest_SearchBy `protobuf_oneof:"search_by"`
	WithDeleted bool                         `protobuf:"varint,4,opt,name=with_deleted,json=withDeleted,proto3" json:"with_deleted,omitempty"`
	// optional user id, we want to know if user liked this product before
	UserId uint64 `protobuf:"varint,5,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *GetProductRequest) Reset()                    { *m = GetProductRequest{} }
func (m *GetProductRequest) String() string            { return proto.CompactTextString(m) }
func (*GetProductRequest) ProtoMessage()               {}
func (*GetProductRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{33} }

type isGetProductRequest_SearchBy interface {
	isGetProductRequest_SearchBy()
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetProductRequest_Id struct {
	Id int64 `protobuf:"varint,1,opt,name=id,proto3,oneof"`
}
type GetProductRequest_Code struct {
	Code string `protobuf:"bytes,2,opt,name=code,proto3,oneof"`
}
type GetProductRequest_MediaId struct {
	MediaId string `protobuf:"bytes,3,opt,name=media_id,json=mediaId,proto3,oneof"`
}

func (*GetProductRequest_Id) isGetProductRequest_SearchBy()      {}
func (*GetProductRequest_Code) isGetProductRequest_SearchBy()    {}
func (*GetProductRequest_MediaId) isGetProductRequest_SearchBy() {}

func (m *GetProductRequest) GetSearchBy() isGetProductRequest_SearchBy {
	if m != nil {
		return m.SearchBy
	}
	return nil
}

func (m *GetProductRequest) GetId() int64 {
	if x, ok := m.GetSearchBy().(*GetProductRequest_Id); ok {
		return x.Id
	}
	return 0
}

func (m *GetProductRequest) GetCode() string {
	if x, ok := m.GetSearchBy().(*GetProductRequest_Code); ok {
		return x.Code
	}
	return ""
}

func (m *GetProductRequest) GetMediaId() string {
	if x, ok := m.GetSearchBy().(*GetProductRequest_MediaId); ok {
		return x.MediaId
	}
	return ""
}

func (m *GetProductRequest) GetWithDeleted() bool {
	if m != nil {
		return m.WithDeleted
	}
	return false
}

func (m *GetProductRequest) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetProductRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetProductRequest_OneofMarshaler, _GetProductRequest_OneofUnmarshaler, _GetProductRequest_OneofSizer, []interface{}{
		(*GetProductRequest_Id)(nil),
		(*GetProductRequest_Code)(nil),
		(*GetProductRequest_MediaId)(nil),
	}
}

func _GetProductRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetProductRequest)
	// search_by
	switch x := m.SearchBy.(type) {
	case *GetProductRequest_Id:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Id))
	case *GetProductRequest_Code:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Code)
	case *GetProductRequest_MediaId:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.MediaId)
	case nil:
	default:
		return fmt.Errorf("GetProductRequest.SearchBy has unexpected type %T", x)
	}
	return nil
}

func _GetProductRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetProductRequest)
	switch tag {
	case 1: // search_by.id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.SearchBy = &GetProductRequest_Id{int64(x)}
		return true, err
	case 2: // search_by.code
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.SearchBy = &GetProductRequest_Code{x}
		return true, err
	case 3: // search_by.media_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.SearchBy = &GetProductRequest_MediaId{x}
		return true, err
	default:
		return false, nil
	}
}

func _GetProductRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetProductRequest)
	// search_by
	switch x := m.SearchBy.(type) {
	case *GetProductRequest_Id:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Id))
	case *GetProductRequest_Code:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Code)))
		n += len(x.Code)
	case *GetProductRequest_MediaId:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.MediaId)))
		n += len(x.MediaId)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SearchProductRequest struct {
	Keyword string  `protobuf:"bytes,1,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Tags    []int64 `protobuf:"varint,2,rep,packed,name=tags" json:"tags,omitempty"`
	Limit   int64   `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	// Types that are valid to be assigned to OffsetBy:
	//	*SearchProductRequest_Offset
	//	*SearchProductRequest_FromId
	OffsetBy   isSearchProductRequest_OffsetBy `protobuf_oneof:"offset_by"`
	IsSaleOnly bool                            `protobuf:"varint,6,opt,name=is_sale_only,json=isSaleOnly,proto3" json:"is_sale_only,omitempty"`
	// false - desc, true - asc
	OffsetDirection bool `protobuf:"varint,7,opt,name=offset_direction,json=offsetDirection,proto3" json:"offset_direction,omitempty"`
	// that was one-of once
	UserId uint64 `protobuf:"varint,8,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	ShopId uint64 `protobuf:"varint,9,opt,name=shop_id,json=shopId,proto3" json:"shop_id,omitempty"`
	// user or shop instagram_name
	InstagramName string `protobuf:"bytes,10,opt,name=instagram_name,json=instagramName,proto3" json:"instagram_name,omitempty"`
}

func (m *SearchProductRequest) Reset()                    { *m = SearchProductRequest{} }
func (m *SearchProductRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchProductRequest) ProtoMessage()               {}
func (*SearchProductRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{34} }

type isSearchProductRequest_OffsetBy interface {
	isSearchProductRequest_OffsetBy()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SearchProductRequest_Offset struct {
	Offset int64 `protobuf:"varint,4,opt,name=offset,proto3,oneof"`
}
type SearchProductRequest_FromId struct {
	FromId uint64 `protobuf:"varint,5,opt,name=from_id,json=fromId,proto3,oneof"`
}

func (*SearchProductRequest_Offset) isSearchProductRequest_OffsetBy() {}
func (*SearchProductRequest_FromId) isSearchProductRequest_OffsetBy() {}

func (m *SearchProductRequest) GetOffsetBy() isSearchProductRequest_OffsetBy {
	if m != nil {
		return m.OffsetBy
	}
	return nil
}

func (m *SearchProductRequest) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *SearchProductRequest) GetTags() []int64 {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *SearchProductRequest) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SearchProductRequest) GetOffset() int64 {
	if x, ok := m.GetOffsetBy().(*SearchProductRequest_Offset); ok {
		return x.Offset
	}
	return 0
}

func (m *SearchProductRequest) GetFromId() uint64 {
	if x, ok := m.GetOffsetBy().(*SearchProductRequest_FromId); ok {
		return x.FromId
	}
	return 0
}

func (m *SearchProductRequest) GetIsSaleOnly() bool {
	if m != nil {
		return m.IsSaleOnly
	}
	return false
}

func (m *SearchProductRequest) GetOffsetDirection() bool {
	if m != nil {
		return m.OffsetDirection
	}
	return false
}

func (m *SearchProductRequest) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SearchProductRequest) GetShopId() uint64 {
	if m != nil {
		return m.ShopId
	}
	return 0
}

func (m *SearchProductRequest) GetInstagramName() string {
	if m != nil {
		return m.InstagramName
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SearchProductRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SearchProductRequest_OneofMarshaler, _SearchProductRequest_OneofUnmarshaler, _SearchProductRequest_OneofSizer, []interface{}{
		(*SearchProductRequest_Offset)(nil),
		(*SearchProductRequest_FromId)(nil),
	}
}

func _SearchProductRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SearchProductRequest)
	// offset_by
	switch x := m.OffsetBy.(type) {
	case *SearchProductRequest_Offset:
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Offset))
	case *SearchProductRequest_FromId:
		_ = b.EncodeVarint(5<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.FromId))
	case nil:
	default:
		return fmt.Errorf("SearchProductRequest.OffsetBy has unexpected type %T", x)
	}
	return nil
}

func _SearchProductRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SearchProductRequest)
	switch tag {
	case 4: // offset_by.offset
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.OffsetBy = &SearchProductRequest_Offset{int64(x)}
		return true, err
	case 5: // offset_by.from_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.OffsetBy = &SearchProductRequest_FromId{x}
		return true, err
	default:
		return false, nil
	}
}

func _SearchProductRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SearchProductRequest)
	// offset_by
	switch x := m.OffsetBy.(type) {
	case *SearchProductRequest_Offset:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Offset))
	case *SearchProductRequest_FromId:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.FromId))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ProductSearchResult struct {
	Result []*Product `protobuf:"bytes,1,rep,name=result" json:"result,omitempty"`
}

func (m *ProductSearchResult) Reset()                    { *m = ProductSearchResult{} }
func (m *ProductSearchResult) String() string            { return proto.CompactTextString(m) }
func (*ProductSearchResult) ProtoMessage()               {}
func (*ProductSearchResult) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{35} }

func (m *ProductSearchResult) GetResult() []*Product {
	if m != nil {
		return m.Result
	}
	return nil
}

type ProductReadResult struct {
	Id      int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Deleted bool  `protobuf:"varint,2,opt,name=deleted,proto3" json:"deleted,omitempty"`
}

func (m *ProductReadResult) Reset()                    { *m = ProductReadResult{} }
func (m *ProductReadResult) String() string            { return proto.CompactTextString(m) }
func (*ProductReadResult) ProtoMessage()               {}
func (*ProductReadResult) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{36} }

func (m *ProductReadResult) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ProductReadResult) GetDeleted() bool {
	if m != nil {
		return m.Deleted
	}
	return false
}

type CreateProductRequest struct {
	Product     *Product `protobuf:"bytes,1,opt,name=product" json:"product,omitempty"`
	MentionedBy uint64   `protobuf:"varint,2,opt,name=mentioned_by,json=mentionedBy,proto3" json:"mentioned_by,omitempty"`
}

func (m *CreateProductRequest) Reset()                    { *m = CreateProductRequest{} }
func (m *CreateProductRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateProductRequest) ProtoMessage()               {}
func (*CreateProductRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{37} }

func (m *CreateProductRequest) GetProduct() *Product {
	if m != nil {
		return m.Product
	}
	return nil
}

func (m *CreateProductRequest) GetMentionedBy() uint64 {
	if m != nil {
		return m.MentionedBy
	}
	return 0
}

type CreateProductResult struct {
	Id     int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Exists bool   `protobuf:"varint,2,opt,name=exists,proto3" json:"exists,omitempty"`
	Code   string `protobuf:"bytes,3,opt,name=code,proto3" json:"code,omitempty"`
}

func (m *CreateProductResult) Reset()                    { *m = CreateProductResult{} }
func (m *CreateProductResult) String() string            { return proto.CompactTextString(m) }
func (*CreateProductResult) ProtoMessage()               {}
func (*CreateProductResult) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{38} }

func (m *CreateProductResult) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CreateProductResult) GetExists() bool {
	if m != nil {
		return m.Exists
	}
	return false
}

func (m *CreateProductResult) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

// representation of product model
type Product struct {
	Id                      int64             `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Title                   string            `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Code                    string            `protobuf:"bytes,3,opt,name=code,proto3" json:"code,omitempty"`
	InstagramImageCaption   string            `protobuf:"bytes,4,opt,name=instagram_image_caption,json=instagramImageCaption,proto3" json:"instagram_image_caption,omitempty"`
	InstagramImageId        string            `protobuf:"bytes,5,opt,name=instagram_image_id,json=instagramImageId,proto3" json:"instagram_image_id,omitempty"`
	InstagramImageUrl       string            `protobuf:"bytes,6,opt,name=instagram_image_url,json=instagramImageUrl,proto3" json:"instagram_image_url,omitempty"`
	InstagramLink           string            `protobuf:"bytes,7,opt,name=instagram_link,json=instagramLink,proto3" json:"instagram_link,omitempty"`
	InstagramImageWidth     uint32            `protobuf:"varint,16,opt,name=instagram_image_width,json=instagramImageWidth,proto3" json:"instagram_image_width,omitempty"`
	InstagramImageHeight    uint32            `protobuf:"varint,17,opt,name=instagram_image_height,json=instagramImageHeight,proto3" json:"instagram_image_height,omitempty"`
	InstagramPublishedAt    int64             `protobuf:"varint,8,opt,name=instagram_published_at,json=instagramPublishedAt,proto3" json:"instagram_published_at,omitempty"`
	InstagramLikesCount     int32             `protobuf:"varint,9,opt,name=instagram_likes_count,json=instagramLikesCount,proto3" json:"instagram_likes_count,omitempty"`
	SupplierId              int64             `protobuf:"varint,10,opt,name=supplier_id,json=supplierId,proto3" json:"supplier_id,omitempty"`
	Supplier                *Shop             `protobuf:"bytes,11,opt,name=supplier" json:"supplier,omitempty"`
	MentionedId             int64             `protobuf:"varint,12,opt,name=mentioned_id,json=mentionedId,proto3" json:"mentioned_id,omitempty"`
	Mentioned               *User             `protobuf:"bytes,13,opt,name=mentioned" json:"mentioned,omitempty"`
	IsSale                  bool              `protobuf:"varint,14,opt,name=isSale,proto3" json:"isSale,omitempty"`
	Items                   []*ProductItem    `protobuf:"bytes,15,rep,name=items" json:"items,omitempty"`
	InstagramImages         []*ImageCandidate `protobuf:"bytes,18,rep,name=instagram_images,json=instagramImages" json:"instagram_images,omitempty"`
	LikedBy                 []*User           `protobuf:"bytes,19,rep,name=liked_by,json=likedBy" json:"liked_by,omitempty"`
	InstagramPublishedAtAgo int64             `protobuf:"varint,20,opt,name=instagram_published_at_ago,json=instagramPublishedAtAgo,proto3" json:"instagram_published_at_ago,omitempty"`
}

func (m *Product) Reset()                    { *m = Product{} }
func (m *Product) String() string            { return proto.CompactTextString(m) }
func (*Product) ProtoMessage()               {}
func (*Product) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{39} }

func (m *Product) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Product) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Product) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *Product) GetInstagramImageCaption() string {
	if m != nil {
		return m.InstagramImageCaption
	}
	return ""
}

func (m *Product) GetInstagramImageId() string {
	if m != nil {
		return m.InstagramImageId
	}
	return ""
}

func (m *Product) GetInstagramImageUrl() string {
	if m != nil {
		return m.InstagramImageUrl
	}
	return ""
}

func (m *Product) GetInstagramLink() string {
	if m != nil {
		return m.InstagramLink
	}
	return ""
}

func (m *Product) GetInstagramImageWidth() uint32 {
	if m != nil {
		return m.InstagramImageWidth
	}
	return 0
}

func (m *Product) GetInstagramImageHeight() uint32 {
	if m != nil {
		return m.InstagramImageHeight
	}
	return 0
}

func (m *Product) GetInstagramPublishedAt() int64 {
	if m != nil {
		return m.InstagramPublishedAt
	}
	return 0
}

func (m *Product) GetInstagramLikesCount() int32 {
	if m != nil {
		return m.InstagramLikesCount
	}
	return 0
}

func (m *Product) GetSupplierId() int64 {
	if m != nil {
		return m.SupplierId
	}
	return 0
}

func (m *Product) GetSupplier() *Shop {
	if m != nil {
		return m.Supplier
	}
	return nil
}

func (m *Product) GetMentionedId() int64 {
	if m != nil {
		return m.MentionedId
	}
	return 0
}

func (m *Product) GetMentioned() *User {
	if m != nil {
		return m.Mentioned
	}
	return nil
}

func (m *Product) GetIsSale() bool {
	if m != nil {
		return m.IsSale
	}
	return false
}

func (m *Product) GetItems() []*ProductItem {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *Product) GetInstagramImages() []*ImageCandidate {
	if m != nil {
		return m.InstagramImages
	}
	return nil
}

func (m *Product) GetLikedBy() []*User {
	if m != nil {
		return m.LikedBy
	}
	return nil
}

func (m *Product) GetInstagramPublishedAtAgo() int64 {
	if m != nil {
		return m.InstagramPublishedAtAgo
	}
	return 0
}

type ProductItem struct {
	Id            int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name          string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Price         uint64 `protobuf:"varint,10,opt,name=price,proto3" json:"price,omitempty"`
	DiscountPrice uint64 `protobuf:"varint,11,opt,name=discount_price,json=discountPrice,proto3" json:"discount_price,omitempty"`
	Tags          []*Tag `protobuf:"bytes,13,rep,name=tags" json:"tags,omitempty"`
}

func (m *ProductItem) Reset()                    { *m = ProductItem{} }
func (m *ProductItem) String() string            { return proto.CompactTextString(m) }
func (*ProductItem) ProtoMessage()               {}
func (*ProductItem) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{40} }

func (m *ProductItem) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ProductItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ProductItem) GetPrice() uint64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *ProductItem) GetDiscountPrice() uint64 {
	if m != nil {
		return m.DiscountPrice
	}
	return 0
}

func (m *ProductItem) GetTags() []*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

type ImageCandidate struct {
	Id   int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Url  string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ImageCandidate) Reset()                    { *m = ImageCandidate{} }
func (m *ImageCandidate) String() string            { return proto.CompactTextString(m) }
func (*ImageCandidate) ProtoMessage()               {}
func (*ImageCandidate) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{41} }

func (m *ImageCandidate) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ImageCandidate) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *ImageCandidate) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type GetLikedByRequest struct {
	UserId uint64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *GetLikedByRequest) Reset()                    { *m = GetLikedByRequest{} }
func (m *GetLikedByRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLikedByRequest) ProtoMessage()               {}
func (*GetLikedByRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{42} }

func (m *GetLikedByRequest) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type GetLikedByReply struct {
	ProductIds []uint64 `protobuf:"varint,1,rep,packed,name=product_ids,json=productIds" json:"product_ids,omitempty"`
}

func (m *GetLikedByReply) Reset()                    { *m = GetLikedByReply{} }
func (m *GetLikedByReply) String() string            { return proto.CompactTextString(m) }
func (*GetLikedByReply) ProtoMessage()               {}
func (*GetLikedByReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{43} }

func (m *GetLikedByReply) GetProductIds() []uint64 {
	if m != nil {
		return m.ProductIds
	}
	return nil
}

type LikeProductRequest struct {
	UserId    uint64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	ProductId uint64 `protobuf:"varint,2,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	// set false to remove like
	Like bool `protobuf:"varint,3,opt,name=like,proto3" json:"like,omitempty"`
}

func (m *LikeProductRequest) Reset()                    { *m = LikeProductRequest{} }
func (m *LikeProductRequest) String() string            { return proto.CompactTextString(m) }
func (*LikeProductRequest) ProtoMessage()               {}
func (*LikeProductRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{44} }

func (m *LikeProductRequest) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *LikeProductRequest) GetProductId() uint64 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

func (m *LikeProductRequest) GetLike() bool {
	if m != nil {
		return m.Like
	}
	return false
}

type LikeProductReply struct {
}

func (m *LikeProductReply) Reset()                    { *m = LikeProductReply{} }
func (m *LikeProductReply) String() string            { return proto.CompactTextString(m) }
func (*LikeProductReply) ProtoMessage()               {}
func (*LikeProductReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{45} }

type GetSpecialProductsRequest struct {
}

func (m *GetSpecialProductsRequest) Reset()                    { *m = GetSpecialProductsRequest{} }
func (m *GetSpecialProductsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetSpecialProductsRequest) ProtoMessage()               {}
func (*GetSpecialProductsRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{46} }

type SpecialProductInfo struct {
	Id    uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
}

func (m *SpecialProductInfo) Reset()                    { *m = SpecialProductInfo{} }
func (m *SpecialProductInfo) String() string            { return proto.CompactTextString(m) }
func (*SpecialProductInfo) ProtoMessage()               {}
func (*SpecialProductInfo) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{47} }

func (m *SpecialProductInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SpecialProductInfo) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

type GetSpecialProductsReply struct {
	List []*SpecialProductInfo `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
	Err  string                `protobuf:"bytes,2,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *GetSpecialProductsReply) Reset()                    { *m = GetSpecialProductsReply{} }
func (m *GetSpecialProductsReply) String() string            { return proto.CompactTextString(m) }
func (*GetSpecialProductsReply) ProtoMessage()               {}
func (*GetSpecialProductsReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{48} }

func (m *GetSpecialProductsReply) GetList() []*SpecialProductInfo {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *GetSpecialProductsReply) GetErr() string {
	if m != nil {
		return m.Err
	}
	return ""
}

type GetLastProductIDRequest struct {
	ShopId uint64 `protobuf:"varint,1,opt,name=shop_id,json=shopId,proto3" json:"shop_id,omitempty"`
}

func (m *GetLastProductIDRequest) Reset()                    { *m = GetLastProductIDRequest{} }
func (m *GetLastProductIDRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLastProductIDRequest) ProtoMessage()               {}
func (*GetLastProductIDRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{49} }

func (m *GetLastProductIDRequest) GetShopId() uint64 {
	if m != nil {
		return m.ShopId
	}
	return 0
}

type GetLastProductIDReply struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GetLastProductIDReply) Reset()                    { *m = GetLastProductIDReply{} }
func (m *GetLastProductIDReply) String() string            { return proto.CompactTextString(m) }
func (*GetLastProductIDReply) ProtoMessage()               {}
func (*GetLastProductIDReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{50} }

func (m *GetLastProductIDReply) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type DelProductRequest struct {
	ProductId uint64 `protobuf:"varint,1,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
}

func (m *DelProductRequest) Reset()                    { *m = DelProductRequest{} }
func (m *DelProductRequest) String() string            { return proto.CompactTextString(m) }
func (*DelProductRequest) ProtoMessage()               {}
func (*DelProductRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{51} }

func (m *DelProductRequest) GetProductId() uint64 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

type DelProductReply struct {
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *DelProductReply) Reset()                    { *m = DelProductReply{} }
func (m *DelProductReply) String() string            { return proto.CompactTextString(m) }
func (*DelProductReply) ProtoMessage()               {}
func (*DelProductReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{52} }

func (m *DelProductReply) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type TokenInfo struct {
	Id     uint64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	UserId uint64    `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Type   TokenType `protobuf:"varint,3,opt,name=type,proto3,enum=core.TokenType" json:"type,omitempty"`
	Token  string    `protobuf:"bytes,4,opt,name=token,proto3" json:"token,omitempty"`
	About  string    `protobuf:"bytes,5,opt,name=about,proto3" json:"about,omitempty"`
}

func (m *TokenInfo) Reset()                    { *m = TokenInfo{} }
func (m *TokenInfo) String() string            { return proto.CompactTextString(m) }
func (*TokenInfo) ProtoMessage()               {}
func (*TokenInfo) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{53} }

func (m *TokenInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TokenInfo) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *TokenInfo) GetType() TokenType {
	if m != nil {
		return m.Type
	}
	return TokenType_Android
}

func (m *TokenInfo) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *TokenInfo) GetAbout() string {
	if m != nil {
		return m.About
	}
	return ""
}

type AddTokenRequest struct {
	Token *TokenInfo `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
}

func (m *AddTokenRequest) Reset()                    { *m = AddTokenRequest{} }
func (m *AddTokenRequest) String() string            { return proto.CompactTextString(m) }
func (*AddTokenRequest) ProtoMessage()               {}
func (*AddTokenRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{54} }

func (m *AddTokenRequest) GetToken() *TokenInfo {
	if m != nil {
		return m.Token
	}
	return nil
}

type DelTokenRequest struct {
	TokenId uint64 `protobuf:"varint,1,opt,name=token_id,json=tokenId,proto3" json:"token_id,omitempty"`
	// user_id should be same as in token. Error will be returned otherwise
	UserId uint64 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *DelTokenRequest) Reset()                    { *m = DelTokenRequest{} }
func (m *DelTokenRequest) String() string            { return proto.CompactTextString(m) }
func (*DelTokenRequest) ProtoMessage()               {}
func (*DelTokenRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{55} }

func (m *DelTokenRequest) GetTokenId() uint64 {
	if m != nil {
		return m.TokenId
	}
	return 0
}

func (m *DelTokenRequest) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type ErrorResult struct {
	// empty if there was no errors
	Error string `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *ErrorResult) Reset()                    { *m = ErrorResult{} }
func (m *ErrorResult) String() string            { return proto.CompactTextString(m) }
func (*ErrorResult) ProtoMessage()               {}
func (*ErrorResult) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{56} }

func (m *ErrorResult) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type GetTokensRequest struct {
	UserId uint64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *GetTokensRequest) Reset()                    { *m = GetTokensRequest{} }
func (m *GetTokensRequest) String() string            { return proto.CompactTextString(m) }
func (*GetTokensRequest) ProtoMessage()               {}
func (*GetTokensRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{57} }

func (m *GetTokensRequest) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type GetTokensResult struct {
	Tokens []*TokenInfo `protobuf:"bytes,1,rep,name=tokens" json:"tokens,omitempty"`
	Error  string       `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *GetTokensResult) Reset()                    { *m = GetTokensResult{} }
func (m *GetTokensResult) String() string            { return proto.CompactTextString(m) }
func (*GetTokensResult) ProtoMessage()               {}
func (*GetTokensResult) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{58} }

func (m *GetTokensResult) GetTokens() []*TokenInfo {
	if m != nil {
		return m.Tokens
	}
	return nil
}

func (m *GetTokensResult) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type InvalidateTokensRequest struct {
	Type   TokenType `protobuf:"varint,1,opt,name=type,proto3,enum=core.TokenType" json:"type,omitempty"`
	Tokens []string  `protobuf:"bytes,2,rep,name=tokens" json:"tokens,omitempty"`
}

func (m *InvalidateTokensRequest) Reset()                    { *m = InvalidateTokensRequest{} }
func (m *InvalidateTokensRequest) String() string            { return proto.CompactTextString(m) }
func (*InvalidateTokensRequest) ProtoMessage()               {}
func (*InvalidateTokensRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{59} }

func (m *InvalidateTokensRequest) GetType() TokenType {
	if m != nil {
		return m.Type
	}
	return TokenType_Android
}

func (m *InvalidateTokensRequest) GetTokens() []string {
	if m != nil {
		return m.Tokens
	}
	return nil
}

type InvalidateTokensResult struct {
}

func (m *InvalidateTokensResult) Reset()                    { *m = InvalidateTokensResult{} }
func (m *InvalidateTokensResult) String() string            { return proto.CompactTextString(m) }
func (*InvalidateTokensResult) ProtoMessage()               {}
func (*InvalidateTokensResult) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{60} }

type UpdateTokenRequest struct {
	Type     TokenType `protobuf:"varint,1,opt,name=type,proto3,enum=core.TokenType" json:"type,omitempty"`
	OldToken string    `protobuf:"bytes,2,opt,name=old_token,json=oldToken,proto3" json:"old_token,omitempty"`
	NewToken string    `protobuf:"bytes,3,opt,name=new_token,json=newToken,proto3" json:"new_token,omitempty"`
}

func (m *UpdateTokenRequest) Reset()                    { *m = UpdateTokenRequest{} }
func (m *UpdateTokenRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateTokenRequest) ProtoMessage()               {}
func (*UpdateTokenRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{61} }

func (m *UpdateTokenRequest) GetType() TokenType {
	if m != nil {
		return m.Type
	}
	return TokenType_Android
}

func (m *UpdateTokenRequest) GetOldToken() string {
	if m != nil {
		return m.OldToken
	}
	return ""
}

func (m *UpdateTokenRequest) GetNewToken() string {
	if m != nil {
		return m.NewToken
	}
	return ""
}

type UpdateTokenResult struct {
}

func (m *UpdateTokenResult) Reset()                    { *m = UpdateTokenResult{} }
func (m *UpdateTokenResult) String() string            { return proto.CompactTextString(m) }
func (*UpdateTokenResult) ProtoMessage()               {}
func (*UpdateTokenResult) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{62} }

type ShopCard struct {
	Id     uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	ShopId uint64 `protobuf:"varint,2,opt,name=shop_id,json=shopId,proto3" json:"shop_id,omitempty"`
	Name   string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Number string `protobuf:"bytes,4,opt,name=number,proto3" json:"number,omitempty"`
	UserId uint64 `protobuf:"varint,5,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *ShopCard) Reset()                    { *m = ShopCard{} }
func (m *ShopCard) String() string            { return proto.CompactTextString(m) }
func (*ShopCard) ProtoMessage()               {}
func (*ShopCard) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{63} }

func (m *ShopCard) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ShopCard) GetShopId() uint64 {
	if m != nil {
		return m.ShopId
	}
	return 0
}

func (m *ShopCard) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ShopCard) GetNumber() string {
	if m != nil {
		return m.Number
	}
	return ""
}

func (m *ShopCard) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type CreateCardRequest struct {
	Card *ShopCard `protobuf:"bytes,2,opt,name=card" json:"card,omitempty"`
}

func (m *CreateCardRequest) Reset()                    { *m = CreateCardRequest{} }
func (m *CreateCardRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateCardRequest) ProtoMessage()               {}
func (*CreateCardRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{64} }

func (m *CreateCardRequest) GetCard() *ShopCard {
	if m != nil {
		return m.Card
	}
	return nil
}

type CreateCardReply struct {
	Id   uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *CreateCardReply) Reset()                    { *m = CreateCardReply{} }
func (m *CreateCardReply) String() string            { return proto.CompactTextString(m) }
func (*CreateCardReply) ProtoMessage()               {}
func (*CreateCardReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{65} }

func (m *CreateCardReply) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CreateCardReply) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type DeleteCardRequest struct {
	Id     uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	UserId uint64 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *DeleteCardRequest) Reset()                    { *m = DeleteCardRequest{} }
func (m *DeleteCardRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteCardRequest) ProtoMessage()               {}
func (*DeleteCardRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{66} }

func (m *DeleteCardRequest) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DeleteCardRequest) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type DeleteCardReply struct {
}

func (m *DeleteCardReply) Reset()                    { *m = DeleteCardReply{} }
func (m *DeleteCardReply) String() string            { return proto.CompactTextString(m) }
func (*DeleteCardReply) ProtoMessage()               {}
func (*DeleteCardReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{67} }

type GetCardsRequest struct {
	UserId uint64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	ShopId uint64 `protobuf:"varint,2,opt,name=shop_id,json=shopId,proto3" json:"shop_id,omitempty"`
}

func (m *GetCardsRequest) Reset()                    { *m = GetCardsRequest{} }
func (m *GetCardsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetCardsRequest) ProtoMessage()               {}
func (*GetCardsRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{68} }

func (m *GetCardsRequest) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GetCardsRequest) GetShopId() uint64 {
	if m != nil {
		return m.ShopId
	}
	return 0
}

type GetCardsReply struct {
	Cards []*ShopCard `protobuf:"bytes,1,rep,name=cards" json:"cards,omitempty"`
}

func (m *GetCardsReply) Reset()                    { *m = GetCardsReply{} }
func (m *GetCardsReply) String() string            { return proto.CompactTextString(m) }
func (*GetCardsReply) ProtoMessage()               {}
func (*GetCardsReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{69} }

func (m *GetCardsReply) GetCards() []*ShopCard {
	if m != nil {
		return m.Cards
	}
	return nil
}

type GetCardByIDRequest struct {
	Id     uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	UserId uint64 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *GetCardByIDRequest) Reset()                    { *m = GetCardByIDRequest{} }
func (m *GetCardByIDRequest) String() string            { return proto.CompactTextString(m) }
func (*GetCardByIDRequest) ProtoMessage()               {}
func (*GetCardByIDRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{70} }

func (m *GetCardByIDRequest) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GetCardByIDRequest) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type GetCardReply struct {
	Card *ShopCard `protobuf:"bytes,1,opt,name=card" json:"card,omitempty"`
}

func (m *GetCardReply) Reset()                    { *m = GetCardReply{} }
func (m *GetCardReply) String() string            { return proto.CompactTextString(m) }
func (*GetCardReply) ProtoMessage()               {}
func (*GetCardReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{71} }

func (m *GetCardReply) GetCard() *ShopCard {
	if m != nil {
		return m.Card
	}
	return nil
}

// representation of shop model
type Shop struct {
	Id         int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	SupplierId int64 `protobuf:"varint,2,opt,name=supplier_id,json=supplierId,proto3" json:"supplier_id,omitempty"`
	// @TODO most of data below will filled from this struct for compability
	// we need to update front and remove duplicate fields after it
	Supplier           *User   `protobuf:"bytes,3,opt,name=supplier" json:"supplier,omitempty"`
	InstagramId        uint64  `protobuf:"varint,4,opt,name=instagram_id,json=instagramId,proto3" json:"instagram_id,omitempty"`
	InstagramUsername  string  `protobuf:"bytes,5,opt,name=instagram_username,json=instagramUsername,proto3" json:"instagram_username,omitempty"`
	InstagramFullname  string  `protobuf:"bytes,6,opt,name=instagram_fullname,json=instagramFullname,proto3" json:"instagram_fullname,omitempty"`
	InstagramAvatarUrl string  `protobuf:"bytes,7,opt,name=instagram_avatar_url,json=instagramAvatarUrl,proto3" json:"instagram_avatar_url,omitempty"`
	InstagramCaption   string  `protobuf:"bytes,8,opt,name=instagram_caption,json=instagramCaption,proto3" json:"instagram_caption,omitempty"`
	InstagramWebsite   string  `protobuf:"bytes,9,opt,name=instagram_website,json=instagramWebsite,proto3" json:"instagram_website,omitempty"`
	PaymentRules       string  `protobuf:"bytes,10,opt,name=payment_rules,json=paymentRules,proto3" json:"payment_rules,omitempty"`
	ShippingRules      string  `protobuf:"bytes,11,opt,name=shipping_rules,json=shippingRules,proto3" json:"shipping_rules,omitempty"`
	Caption            string  `protobuf:"bytes,12,opt,name=caption,proto3" json:"caption,omitempty"`
	Sellers            []*User `protobuf:"bytes,13,rep,name=sellers" json:"sellers,omitempty"`
	AvatarUrl          string  `protobuf:"bytes,14,opt,name=avatar_url,json=avatarUrl,proto3" json:"avatar_url,omitempty"`
	Slogan             string  `protobuf:"bytes,15,opt,name=slogan,proto3" json:"slogan,omitempty"`
	Available          bool    `protobuf:"varint,16,opt,name=available,proto3" json:"available,omitempty"`
	// unix time, seconds
	CreatedAt uint64 `protobuf:"varint,17,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// true if shop has no active monetization plan
	Suspended bool   `protobuf:"varint,18,opt,name=suspended,proto3" json:"suspended,omitempty"`
	PlanId    uint64 `protobuf:"varint,19,opt,name=plan_id,json=planId,proto3" json:"plan_id,omitempty"`
	// may be zero for plans without expiration
	// DO NOT use this field to determinate whether shop has active plan, check "suspended" field instead
	PlanExpiresAt int64  `protobuf:"varint,20,opt,name=plan_expires_at,json=planExpiresAt,proto3" json:"plan_expires_at,omitempty"`
	AutoRenewal   bool   `protobuf:"varint,21,opt,name=auto_renewal,json=autoRenewal,proto3" json:"auto_renewal,omitempty"`
	Location      string `protobuf:"bytes,22,opt,name=location,proto3" json:"location,omitempty"`
	WorkingTime   string `protobuf:"bytes,23,opt,name=working_time,json=workingTime,proto3" json:"working_time,omitempty"`
}

func (m *Shop) Reset()                    { *m = Shop{} }
func (m *Shop) String() string            { return proto.CompactTextString(m) }
func (*Shop) ProtoMessage()               {}
func (*Shop) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{72} }

func (m *Shop) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Shop) GetSupplierId() int64 {
	if m != nil {
		return m.SupplierId
	}
	return 0
}

func (m *Shop) GetSupplier() *User {
	if m != nil {
		return m.Supplier
	}
	return nil
}

func (m *Shop) GetInstagramId() uint64 {
	if m != nil {
		return m.InstagramId
	}
	return 0
}

func (m *Shop) GetInstagramUsername() string {
	if m != nil {
		return m.InstagramUsername
	}
	return ""
}

func (m *Shop) GetInstagramFullname() string {
	if m != nil {
		return m.InstagramFullname
	}
	return ""
}

func (m *Shop) GetInstagramAvatarUrl() string {
	if m != nil {
		return m.InstagramAvatarUrl
	}
	return ""
}

func (m *Shop) GetInstagramCaption() string {
	if m != nil {
		return m.InstagramCaption
	}
	return ""
}

func (m *Shop) GetInstagramWebsite() string {
	if m != nil {
		return m.InstagramWebsite
	}
	return ""
}

func (m *Shop) GetPaymentRules() string {
	if m != nil {
		return m.PaymentRules
	}
	return ""
}

func (m *Shop) GetShippingRules() string {
	if m != nil {
		return m.ShippingRules
	}
	return ""
}

func (m *Shop) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *Shop) GetSellers() []*User {
	if m != nil {
		return m.Sellers
	}
	return nil
}

func (m *Shop) GetAvatarUrl() string {
	if m != nil {
		return m.AvatarUrl
	}
	return ""
}

func (m *Shop) GetSlogan() string {
	if m != nil {
		return m.Slogan
	}
	return ""
}

func (m *Shop) GetAvailable() bool {
	if m != nil {
		return m.Available
	}
	return false
}

func (m *Shop) GetCreatedAt() uint64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *Shop) GetSuspended() bool {
	if m != nil {
		return m.Suspended
	}
	return false
}

func (m *Shop) GetPlanId() uint64 {
	if m != nil {
		return m.PlanId
	}
	return 0
}

func (m *Shop) GetPlanExpiresAt() int64 {
	if m != nil {
		return m.PlanExpiresAt
	}
	return 0
}

func (m *Shop) GetAutoRenewal() bool {
	if m != nil {
		return m.AutoRenewal
	}
	return false
}

func (m *Shop) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *Shop) GetWorkingTime() string {
	if m != nil {
		return m.WorkingTime
	}
	return ""
}

type ShopProfileRequest struct {
	// Types that are valid to be assigned to SearchBy:
	//	*ShopProfileRequest_InstagramName
	//	*ShopProfileRequest_Id
	SearchBy isShopProfileRequest_SearchBy `protobuf_oneof:"search_by"`
}

func (m *ShopProfileRequest) Reset()                    { *m = ShopProfileRequest{} }
func (m *ShopProfileRequest) String() string            { return proto.CompactTextString(m) }
func (*ShopProfileRequest) ProtoMessage()               {}
func (*ShopProfileRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{73} }

type isShopProfileRequest_SearchBy interface {
	isShopProfileRequest_SearchBy()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ShopProfileRequest_InstagramName struct {
	InstagramName string `protobuf:"bytes,1,opt,name=instagram_name,json=instagramName,proto3,oneof"`
}
type ShopProfileRequest_Id struct {
	Id uint64 `protobuf:"varint,2,opt,name=id,proto3,oneof"`
}

func (*ShopProfileRequest_InstagramName) isShopProfileRequest_SearchBy() {}
func (*ShopProfileRequest_Id) isShopProfileRequest_SearchBy()            {}

func (m *ShopProfileRequest) GetSearchBy() isShopProfileRequest_SearchBy {
	if m != nil {
		return m.SearchBy
	}
	return nil
}

func (m *ShopProfileRequest) GetInstagramName() string {
	if x, ok := m.GetSearchBy().(*ShopProfileRequest_InstagramName); ok {
		return x.InstagramName
	}
	return ""
}

func (m *ShopProfileRequest) GetId() uint64 {
	if x, ok := m.GetSearchBy().(*ShopProfileRequest_Id); ok {
		return x.Id
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ShopProfileRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ShopProfileRequest_OneofMarshaler, _ShopProfileRequest_OneofUnmarshaler, _ShopProfileRequest_OneofSizer, []interface{}{
		(*ShopProfileRequest_InstagramName)(nil),
		(*ShopProfileRequest_Id)(nil),
	}
}

func _ShopProfileRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ShopProfileRequest)
	// search_by
	switch x := m.SearchBy.(type) {
	case *ShopProfileRequest_InstagramName:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.InstagramName)
	case *ShopProfileRequest_Id:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Id))
	case nil:
	default:
		return fmt.Errorf("ShopProfileRequest.SearchBy has unexpected type %T", x)
	}
	return nil
}

func _ShopProfileRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ShopProfileRequest)
	switch tag {
	case 1: // search_by.instagram_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.SearchBy = &ShopProfileRequest_InstagramName{x}
		return true, err
	case 2: // search_by.id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.SearchBy = &ShopProfileRequest_Id{x}
		return true, err
	default:
		return false, nil
	}
}

func _ShopProfileRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ShopProfileRequest)
	// search_by
	switch x := m.SearchBy.(type) {
	case *ShopProfileRequest_InstagramName:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.InstagramName)))
		n += len(x.InstagramName)
	case *ShopProfileRequest_Id:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Id))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ShopProfileReply struct {
	Shop          *Shop  `protobuf:"bytes,1,opt,name=shop" json:"shop,omitempty"`
	ProductsCount uint64 `protobuf:"varint,2,opt,name=products_count,json=productsCount,proto3" json:"products_count,omitempty"`
}

func (m *ShopProfileReply) Reset()                    { *m = ShopProfileReply{} }
func (m *ShopProfileReply) String() string            { return proto.CompactTextString(m) }
func (*ShopProfileReply) ProtoMessage()               {}
func (*ShopProfileReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{74} }

func (m *ShopProfileReply) GetShop() *Shop {
	if m != nil {
		return m.Shop
	}
	return nil
}

func (m *ShopProfileReply) GetProductsCount() uint64 {
	if m != nil {
		return m.ProductsCount
	}
	return 0
}

type FindOrCreateShopForSupplierRequest struct {
	SupplierId uint64 `protobuf:"varint,1,opt,name=supplier_id,json=supplierId,proto3" json:"supplier_id,omitempty"`
	// when false shop will not be recreated if it was deleted
	RecreateDeleted bool `protobuf:"varint,2,opt,name=recreate_deleted,json=recreateDeleted,proto3" json:"recreate_deleted,omitempty"`
}

func (m *FindOrCreateShopForSupplierRequest) Reset()         { *m = FindOrCreateShopForSupplierRequest{} }
func (m *FindOrCreateShopForSupplierRequest) String() string { return proto.CompactTextString(m) }
func (*FindOrCreateShopForSupplierRequest) ProtoMessage()    {}
func (*FindOrCreateShopForSupplierRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorCore, []int{75}
}

func (m *FindOrCreateShopForSupplierRequest) GetSupplierId() uint64 {
	if m != nil {
		return m.SupplierId
	}
	return 0
}

func (m *FindOrCreateShopForSupplierRequest) GetRecreateDeleted() bool {
	if m != nil {
		return m.RecreateDeleted
	}
	return false
}

type FindOrCreateShopForSupplierReply struct {
	ShopId  uint64 `protobuf:"varint,1,opt,name=shop_id,json=shopId,proto3" json:"shop_id,omitempty"`
	Deleted bool   `protobuf:"varint,2,opt,name=deleted,proto3" json:"deleted,omitempty"`
	Error   string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *FindOrCreateShopForSupplierReply) Reset()         { *m = FindOrCreateShopForSupplierReply{} }
func (m *FindOrCreateShopForSupplierReply) String() string { return proto.CompactTextString(m) }
func (*FindOrCreateShopForSupplierReply) ProtoMessage()    {}
func (*FindOrCreateShopForSupplierReply) Descriptor() ([]byte, []int) {
	return fileDescriptorCore, []int{76}
}

func (m *FindOrCreateShopForSupplierReply) GetShopId() uint64 {
	if m != nil {
		return m.ShopId
	}
	return 0
}

func (m *FindOrCreateShopForSupplierReply) GetDeleted() bool {
	if m != nil {
		return m.Deleted
	}
	return false
}

func (m *FindOrCreateShopForSupplierReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type FindOrCreateAttachedShopRequest struct {
	SupplierId        uint64 `protobuf:"varint,1,opt,name=supplier_id,json=supplierId,proto3" json:"supplier_id,omitempty"`
	InstagramUsername string `protobuf:"bytes,2,opt,name=instagram_username,json=instagramUsername,proto3" json:"instagram_username,omitempty"`
}

func (m *FindOrCreateAttachedShopRequest) Reset()         { *m = FindOrCreateAttachedShopRequest{} }
func (m *FindOrCreateAttachedShopRequest) String() string { return proto.CompactTextString(m) }
func (*FindOrCreateAttachedShopRequest) ProtoMessage()    {}
func (*FindOrCreateAttachedShopRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorCore, []int{77}
}

func (m *FindOrCreateAttachedShopRequest) GetSupplierId() uint64 {
	if m != nil {
		return m.SupplierId
	}
	return 0
}

func (m *FindOrCreateAttachedShopRequest) GetInstagramUsername() string {
	if m != nil {
		return m.InstagramUsername
	}
	return ""
}

type FindOrCreateAttachedShopReply struct {
	ShopId uint64 `protobuf:"varint,1,opt,name=shop_id,json=shopId,proto3" json:"shop_id,omitempty"`
	Error  string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *FindOrCreateAttachedShopReply) Reset()         { *m = FindOrCreateAttachedShopReply{} }
func (m *FindOrCreateAttachedShopReply) String() string { return proto.CompactTextString(m) }
func (*FindOrCreateAttachedShopReply) ProtoMessage()    {}
func (*FindOrCreateAttachedShopReply) Descriptor() ([]byte, []int) {
	return fileDescriptorCore, []int{78}
}

func (m *FindOrCreateAttachedShopReply) GetShopId() uint64 {
	if m != nil {
		return m.ShopId
	}
	return 0
}

func (m *FindOrCreateAttachedShopReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type GetMainTagsRequest struct {
	Limit int64 `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *GetMainTagsRequest) Reset()                    { *m = GetMainTagsRequest{} }
func (m *GetMainTagsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetMainTagsRequest) ProtoMessage()               {}
func (*GetMainTagsRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{79} }

func (m *GetMainTagsRequest) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type GetRelatedTagsRequest struct {
	// tag list
	Tags  []int64 `protobuf:"varint,1,rep,packed,name=tags" json:"tags,omitempty"`
	Limit int64   `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *GetRelatedTagsRequest) Reset()                    { *m = GetRelatedTagsRequest{} }
func (m *GetRelatedTagsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRelatedTagsRequest) ProtoMessage()               {}
func (*GetRelatedTagsRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{80} }

func (m *GetRelatedTagsRequest) GetTags() []int64 {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *GetRelatedTagsRequest) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// tag object list
type TagSearchResult struct {
	Result []*Tag `protobuf:"bytes,1,rep,name=result" json:"result,omitempty"`
}

func (m *TagSearchResult) Reset()                    { *m = TagSearchResult{} }
func (m *TagSearchResult) String() string            { return proto.CompactTextString(m) }
func (*TagSearchResult) ProtoMessage()               {}
func (*TagSearchResult) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{81} }

func (m *TagSearchResult) GetResult() []*Tag {
	if m != nil {
		return m.Result
	}
	return nil
}

// tag model representation
type Tag struct {
	Id   int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Tag) Reset()                    { *m = Tag{} }
func (m *Tag) String() string            { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()               {}
func (*Tag) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{82} }

func (m *Tag) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Tag) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type CreateUserRequest struct {
	User *User `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
}

func (m *CreateUserRequest) Reset()                    { *m = CreateUserRequest{} }
func (m *CreateUserRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateUserRequest) ProtoMessage()               {}
func (*CreateUserRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{83} }

func (m *CreateUserRequest) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

// where instagram_id = ? OR phone = ? OR instagram_username = ? OR name = ?
type ReadUserRequest struct {
	InstagramId       uint64 `protobuf:"varint,1,opt,name=instagram_id,json=instagramId,proto3" json:"instagram_id,omitempty"`
	Phone             string `protobuf:"bytes,2,opt,name=phone,proto3" json:"phone,omitempty"`
	InstagramUsername string `protobuf:"bytes,3,opt,name=instagram_username,json=instagramUsername,proto3" json:"instagram_username,omitempty"`
	Name              string `protobuf:"bytes,7,opt,name=name,proto3" json:"name,omitempty"`
	// direct by user.id
	Id uint64 `protobuf:"varint,4,opt,name=id,proto3" json:"id,omitempty"`
	// if true PuclicEncode will be used(phone/mail will be empty)
	Public bool `protobuf:"varint,5,opt,name=public,proto3" json:"public,omitempty"`
	// if true list of relared shops will be provided
	GetShops bool `protobuf:"varint,6,opt,name=get_shops,json=getShops,proto3" json:"get_shops,omitempty"`
}

func (m *ReadUserRequest) Reset()                    { *m = ReadUserRequest{} }
func (m *ReadUserRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadUserRequest) ProtoMessage()               {}
func (*ReadUserRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{84} }

func (m *ReadUserRequest) GetInstagramId() uint64 {
	if m != nil {
		return m.InstagramId
	}
	return 0
}

func (m *ReadUserRequest) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *ReadUserRequest) GetInstagramUsername() string {
	if m != nil {
		return m.InstagramUsername
	}
	return ""
}

func (m *ReadUserRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ReadUserRequest) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ReadUserRequest) GetPublic() bool {
	if m != nil {
		return m.Public
	}
	return false
}

func (m *ReadUserRequest) GetGetShops() bool {
	if m != nil {
		return m.GetShops
	}
	return false
}

type SearchUserReply struct {
	Result []*User `protobuf:"bytes,1,rep,name=result" json:"result,omitempty"`
}

func (m *SearchUserReply) Reset()                    { *m = SearchUserReply{} }
func (m *SearchUserReply) String() string            { return proto.CompactTextString(m) }
func (*SearchUserReply) ProtoMessage()               {}
func (*SearchUserReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{85} }

func (m *SearchUserReply) GetResult() []*User {
	if m != nil {
		return m.Result
	}
	return nil
}

type ReadUserReply struct {
	Id   int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	User *User `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
}

func (m *ReadUserReply) Reset()                    { *m = ReadUserReply{} }
func (m *ReadUserReply) String() string            { return proto.CompactTextString(m) }
func (*ReadUserReply) ProtoMessage()               {}
func (*ReadUserReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{86} }

func (m *ReadUserReply) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ReadUserReply) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

// representation of user model
type User struct {
	Id                 int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name               string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Email              string `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
	Phone              string `protobuf:"bytes,4,opt,name=phone,proto3" json:"phone,omitempty"`
	Website            string `protobuf:"bytes,5,opt,name=website,proto3" json:"website,omitempty"`
	Caption            string `protobuf:"bytes,13,opt,name=caption,proto3" json:"caption,omitempty"`
	AvatarUrl          string `protobuf:"bytes,17,opt,name=avatar_url,json=avatarUrl,proto3" json:"avatar_url,omitempty"`
	Slogan             string `protobuf:"bytes,18,opt,name=slogan,proto3" json:"slogan,omitempty"`
	InstagramId        uint64 `protobuf:"varint,6,opt,name=instagram_id,json=instagramId,proto3" json:"instagram_id,omitempty"`
	InstagramUsername  string `protobuf:"bytes,7,opt,name=instagram_username,json=instagramUsername,proto3" json:"instagram_username,omitempty"`
	InstagramFullname  string `protobuf:"bytes,8,opt,name=instagram_fullname,json=instagramFullname,proto3" json:"instagram_fullname,omitempty"`
	InstagramAvatarUrl string `protobuf:"bytes,9,opt,name=instagram_avatar_url,json=instagramAvatarUrl,proto3" json:"instagram_avatar_url,omitempty"`
	InstagramCaption   string `protobuf:"bytes,10,opt,name=instagram_caption,json=instagramCaption,proto3" json:"instagram_caption,omitempty"`
	OptOut             bool   `protobuf:"varint,11,opt,name=opt_out,json=optOut,proto3" json:"opt_out,omitempty"`
	SuperSeller        bool   `protobuf:"varint,12,opt,name=super_seller,json=superSeller,proto3" json:"super_seller,omitempty"`
	HasEmail           bool   `protobuf:"varint,14,opt,name=has_email,json=hasEmail,proto3" json:"has_email,omitempty"`
	HasPhone           bool   `protobuf:"varint,15,opt,name=has_phone,json=hasPhone,proto3" json:"has_phone,omitempty"`
	Confirmed          bool   `protobuf:"varint,21,opt,name=confirmed,proto3" json:"confirmed,omitempty"`
	IsFake             bool   `protobuf:"varint,22,opt,name=is_fake,json=isFake,proto3" json:"is_fake,omitempty"`
	IsAdmin            bool   `protobuf:"varint,23,opt,name=is_admin,json=isAdmin,proto3" json:"is_admin,omitempty"`
	Seller             bool   `protobuf:"varint,16,opt,name=seller,proto3" json:"seller,omitempty"`
	// list of shops where user is a supplier
	SupplierOf []uint64 `protobuf:"varint,19,rep,packed,name=supplier_of,json=supplierOf" json:"supplier_of,omitempty"`
	// list of shops where user is a seller
	SellerOf []uint64 `protobuf:"varint,20,rep,packed,name=seller_of,json=sellerOf" json:"seller_of,omitempty"`
	Source   string   `protobuf:"bytes,24,opt,name=source,proto3" json:"source,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{87} }

func (m *User) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *User) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *User) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *User) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *User) GetWebsite() string {
	if m != nil {
		return m.Website
	}
	return ""
}

func (m *User) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *User) GetAvatarUrl() string {
	if m != nil {
		return m.AvatarUrl
	}
	return ""
}

func (m *User) GetSlogan() string {
	if m != nil {
		return m.Slogan
	}
	return ""
}

func (m *User) GetInstagramId() uint64 {
	if m != nil {
		return m.InstagramId
	}
	return 0
}

func (m *User) GetInstagramUsername() string {
	if m != nil {
		return m.InstagramUsername
	}
	return ""
}

func (m *User) GetInstagramFullname() string {
	if m != nil {
		return m.InstagramFullname
	}
	return ""
}

func (m *User) GetInstagramAvatarUrl() string {
	if m != nil {
		return m.InstagramAvatarUrl
	}
	return ""
}

func (m *User) GetInstagramCaption() string {
	if m != nil {
		return m.InstagramCaption
	}
	return ""
}

func (m *User) GetOptOut() bool {
	if m != nil {
		return m.OptOut
	}
	return false
}

func (m *User) GetSuperSeller() bool {
	if m != nil {
		return m.SuperSeller
	}
	return false
}

func (m *User) GetHasEmail() bool {
	if m != nil {
		return m.HasEmail
	}
	return false
}

func (m *User) GetHasPhone() bool {
	if m != nil {
		return m.HasPhone
	}
	return false
}

func (m *User) GetConfirmed() bool {
	if m != nil {
		return m.Confirmed
	}
	return false
}

func (m *User) GetIsFake() bool {
	if m != nil {
		return m.IsFake
	}
	return false
}

func (m *User) GetIsAdmin() bool {
	if m != nil {
		return m.IsAdmin
	}
	return false
}

func (m *User) GetSeller() bool {
	if m != nil {
		return m.Seller
	}
	return false
}

func (m *User) GetSupplierOf() []uint64 {
	if m != nil {
		return m.SupplierOf
	}
	return nil
}

func (m *User) GetSellerOf() []uint64 {
	if m != nil {
		return m.SellerOf
	}
	return nil
}

func (m *User) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

type SetEmailRequest struct {
	UserId uint64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Email  string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
}

func (m *SetEmailRequest) Reset()                    { *m = SetEmailRequest{} }
func (m *SetEmailRequest) String() string            { return proto.CompactTextString(m) }
func (*SetEmailRequest) ProtoMessage()               {}
func (*SetEmailRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{88} }

func (m *SetEmailRequest) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SetEmailRequest) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

type SetEmailReply struct {
	Error string `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *SetEmailReply) Reset()                    { *m = SetEmailReply{} }
func (m *SetEmailReply) String() string            { return proto.CompactTextString(m) }
func (*SetEmailReply) ProtoMessage()               {}
func (*SetEmailReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{89} }

func (m *SetEmailReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type SetDataRequest struct {
	UserId uint64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Name   string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Phone  string `protobuf:"bytes,3,opt,name=phone,proto3" json:"phone,omitempty"`
}

func (m *SetDataRequest) Reset()                    { *m = SetDataRequest{} }
func (m *SetDataRequest) String() string            { return proto.CompactTextString(m) }
func (*SetDataRequest) ProtoMessage()               {}
func (*SetDataRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{90} }

func (m *SetDataRequest) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SetDataRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SetDataRequest) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

type SetDataReply struct {
}

func (m *SetDataReply) Reset()                    { *m = SetDataReply{} }
func (m *SetDataReply) String() string            { return proto.CompactTextString(m) }
func (*SetDataReply) ProtoMessage()               {}
func (*SetDataReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{91} }

type AddTelegramRequest struct {
	UserId uint64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// our local username, alternative for user_id to avoid surplus rpc calls
	Username string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	ChatId   uint64 `protobuf:"varint,3,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	// telegram username
	SubsricberName string `protobuf:"bytes,4,opt,name=subsricber_name,json=subsricberName,proto3" json:"subsricber_name,omitempty"`
}

func (m *AddTelegramRequest) Reset()                    { *m = AddTelegramRequest{} }
func (m *AddTelegramRequest) String() string            { return proto.CompactTextString(m) }
func (*AddTelegramRequest) ProtoMessage()               {}
func (*AddTelegramRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{92} }

func (m *AddTelegramRequest) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *AddTelegramRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *AddTelegramRequest) GetChatId() uint64 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *AddTelegramRequest) GetSubsricberName() string {
	if m != nil {
		return m.SubsricberName
	}
	return ""
}

type AddTelegramReply struct {
	Error string `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *AddTelegramReply) Reset()                    { *m = AddTelegramReply{} }
func (m *AddTelegramReply) String() string            { return proto.CompactTextString(m) }
func (*AddTelegramReply) ProtoMessage()               {}
func (*AddTelegramReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{93} }

func (m *AddTelegramReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type Telegram struct {
	UserId        uint64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	ChatId        uint64 `protobuf:"varint,2,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	SubsriberName string `protobuf:"bytes,3,opt,name=subsriber_name,json=subsriberName,proto3" json:"subsriber_name,omitempty"`
	Confirmed     bool   `protobuf:"varint,4,opt,name=confirmed,proto3" json:"confirmed,omitempty"`
}

func (m *Telegram) Reset()                    { *m = Telegram{} }
func (m *Telegram) String() string            { return proto.CompactTextString(m) }
func (*Telegram) ProtoMessage()               {}
func (*Telegram) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{94} }

func (m *Telegram) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *Telegram) GetChatId() uint64 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *Telegram) GetSubsriberName() string {
	if m != nil {
		return m.SubsriberName
	}
	return ""
}

func (m *Telegram) GetConfirmed() bool {
	if m != nil {
		return m.Confirmed
	}
	return false
}

type ListTelegramsRequest struct {
	UserId        uint64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	ConfirmedOnly bool   `protobuf:"varint,2,opt,name=confirmed_only,json=confirmedOnly,proto3" json:"confirmed_only,omitempty"`
}

func (m *ListTelegramsRequest) Reset()                    { *m = ListTelegramsRequest{} }
func (m *ListTelegramsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListTelegramsRequest) ProtoMessage()               {}
func (*ListTelegramsRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{95} }

func (m *ListTelegramsRequest) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ListTelegramsRequest) GetConfirmedOnly() bool {
	if m != nil {
		return m.ConfirmedOnly
	}
	return false
}

type ListTelegramsReply struct {
	Telegrams []*Telegram `protobuf:"bytes,1,rep,name=telegrams" json:"telegrams,omitempty"`
	Error     string      `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *ListTelegramsReply) Reset()                    { *m = ListTelegramsReply{} }
func (m *ListTelegramsReply) String() string            { return proto.CompactTextString(m) }
func (*ListTelegramsReply) ProtoMessage()               {}
func (*ListTelegramsReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{96} }

func (m *ListTelegramsReply) GetTelegrams() []*Telegram {
	if m != nil {
		return m.Telegrams
	}
	return nil
}

func (m *ListTelegramsReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type ConfirmTelegramRequest struct {
	UserId uint64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	ChatId uint64 `protobuf:"varint,2,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
}

func (m *ConfirmTelegramRequest) Reset()                    { *m = ConfirmTelegramRequest{} }
func (m *ConfirmTelegramRequest) String() string            { return proto.CompactTextString(m) }
func (*ConfirmTelegramRequest) ProtoMessage()               {}
func (*ConfirmTelegramRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{97} }

func (m *ConfirmTelegramRequest) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ConfirmTelegramRequest) GetChatId() uint64 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

type ConfirmTelegramReply struct {
	Error string `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *ConfirmTelegramReply) Reset()                    { *m = ConfirmTelegramReply{} }
func (m *ConfirmTelegramReply) String() string            { return proto.CompactTextString(m) }
func (*ConfirmTelegramReply) ProtoMessage()               {}
func (*ConfirmTelegramReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{98} }

func (m *ConfirmTelegramReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type DelTelegramRequest struct {
	UserId   uint64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Username string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	ChatId   uint64 `protobuf:"varint,3,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
}

func (m *DelTelegramRequest) Reset()                    { *m = DelTelegramRequest{} }
func (m *DelTelegramRequest) String() string            { return proto.CompactTextString(m) }
func (*DelTelegramRequest) ProtoMessage()               {}
func (*DelTelegramRequest) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{99} }

func (m *DelTelegramRequest) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *DelTelegramRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *DelTelegramRequest) GetChatId() uint64 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

type DelTelegramReply struct {
	Error string `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *DelTelegramReply) Reset()                    { *m = DelTelegramReply{} }
func (m *DelTelegramReply) String() string            { return proto.CompactTextString(m) }
func (*DelTelegramReply) ProtoMessage()               {}
func (*DelTelegramReply) Descriptor() ([]byte, []int) { return fileDescriptorCore, []int{100} }

func (m *DelTelegramReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func init() {
	proto.RegisterType((*ReadLeadRequest)(nil), "core.ReadLeadRequest")
	proto.RegisterType((*ReadLeadResult)(nil), "core.ReadLeadResult")
	proto.RegisterType((*Lead)(nil), "core.Lead")
	proto.RegisterType((*CreateLeadResult)(nil), "core.CreateLeadResult")
	proto.RegisterType((*UserLeadsRequest)(nil), "core.UserLeadsRequest")
	proto.RegisterType((*UserLeadsReply)(nil), "core.UserLeadsReply")
	proto.RegisterType((*LeadInfo)(nil), "core.LeadInfo")
	proto.RegisterType((*LeadEventMessage)(nil), "core.LeadEventMessage")
	proto.RegisterType((*SetLeadStatusRequest)(nil), "core.SetLeadStatusRequest")
	proto.RegisterType((*SetLeadStatusReply)(nil), "core.SetLeadStatusReply")
	proto.RegisterType((*CallSupplierRequest)(nil), "core.CallSupplierRequest")
	proto.RegisterType((*CallSupplierReply)(nil), "core.CallSupplierReply")
	proto.RegisterType((*CallCustomerRequest)(nil), "core.CallCustomerRequest")
	proto.RegisterType((*CallCustomerReply)(nil), "core.CallCustomerReply")
	proto.RegisterType((*GetLeadRequest)(nil), "core.GetLeadRequest")
	proto.RegisterType((*GetLeadReply)(nil), "core.GetLeadReply")
	proto.RegisterType((*GetCancelReasonsRequest)(nil), "core.GetCancelReasonsRequest")
	proto.RegisterType((*CancelReason)(nil), "core.CancelReason")
	proto.RegisterType((*GetCancelReasonsReply)(nil), "core.GetCancelReasonsReply")
	proto.RegisterType((*GetUserRoleRequest)(nil), "core.GetUserRoleRequest")
	proto.RegisterType((*GetUserRoleReply)(nil), "core.GetUserRoleReply")
	proto.RegisterType((*GetPlanRequest)(nil), "core.GetPlanRequest")
	proto.RegisterType((*MonezationPlan)(nil), "core.MonezationPlan")
	proto.RegisterType((*GetPlanReply)(nil), "core.GetPlanReply")
	proto.RegisterType((*GetPlansListRequest)(nil), "core.GetPlansListRequest")
	proto.RegisterType((*GetPlansListReply)(nil), "core.GetPlansListReply")
	proto.RegisterType((*CoinsOffer)(nil), "core.CoinsOffer")
	proto.RegisterType((*GetCoinsOffersRequest)(nil), "core.GetCoinsOffersRequest")
	proto.RegisterType((*GetCoinsOffersReply)(nil), "core.GetCoinsOffersReply")
	proto.RegisterType((*SubscribeRequest)(nil), "core.SubscribeRequest")
	proto.RegisterType((*SubscribeReply)(nil), "core.SubscribeReply")
	proto.RegisterType((*SetAutorefillRequest)(nil), "core.SetAutorefillRequest")
	proto.RegisterType((*SetAutorefillReply)(nil), "core.SetAutorefillReply")
	proto.RegisterType((*GetProductRequest)(nil), "core.GetProductRequest")
	proto.RegisterType((*SearchProductRequest)(nil), "core.SearchProductRequest")
	proto.RegisterType((*ProductSearchResult)(nil), "core.ProductSearchResult")
	proto.RegisterType((*ProductReadResult)(nil), "core.ProductReadResult")
	proto.RegisterType((*CreateProductRequest)(nil), "core.CreateProductRequest")
	proto.RegisterType((*CreateProductResult)(nil), "core.CreateProductResult")
	proto.RegisterType((*Product)(nil), "core.Product")
	proto.RegisterType((*ProductItem)(nil), "core.ProductItem")
	proto.RegisterType((*ImageCandidate)(nil), "core.ImageCandidate")
	proto.RegisterType((*GetLikedByRequest)(nil), "core.GetLikedByRequest")
	proto.RegisterType((*GetLikedByReply)(nil), "core.GetLikedByReply")
	proto.RegisterType((*LikeProductRequest)(nil), "core.LikeProductRequest")
	proto.RegisterType((*LikeProductReply)(nil), "core.LikeProductReply")
	proto.RegisterType((*GetSpecialProductsRequest)(nil), "core.GetSpecialProductsRequest")
	proto.RegisterType((*SpecialProductInfo)(nil), "core.SpecialProductInfo")
	proto.RegisterType((*GetSpecialProductsReply)(nil), "core.GetSpecialProductsReply")
	proto.RegisterType((*GetLastProductIDRequest)(nil), "core.GetLastProductIDRequest")
	proto.RegisterType((*GetLastProductIDReply)(nil), "core.GetLastProductIDReply")
	proto.RegisterType((*DelProductRequest)(nil), "core.DelProductRequest")
	proto.RegisterType((*DelProductReply)(nil), "core.DelProductReply")
	proto.RegisterType((*TokenInfo)(nil), "core.TokenInfo")
	proto.RegisterType((*AddTokenRequest)(nil), "core.AddTokenRequest")
	proto.RegisterType((*DelTokenRequest)(nil), "core.DelTokenRequest")
	proto.RegisterType((*ErrorResult)(nil), "core.ErrorResult")
	proto.RegisterType((*GetTokensRequest)(nil), "core.GetTokensRequest")
	proto.RegisterType((*GetTokensResult)(nil), "core.GetTokensResult")
	proto.RegisterType((*InvalidateTokensRequest)(nil), "core.InvalidateTokensRequest")
	proto.RegisterType((*InvalidateTokensResult)(nil), "core.InvalidateTokensResult")
	proto.RegisterType((*UpdateTokenRequest)(nil), "core.UpdateTokenRequest")
	proto.RegisterType((*UpdateTokenResult)(nil), "core.UpdateTokenResult")
	proto.RegisterType((*ShopCard)(nil), "core.ShopCard")
	proto.RegisterType((*CreateCardRequest)(nil), "core.CreateCardRequest")
	proto.RegisterType((*CreateCardReply)(nil), "core.CreateCardReply")
	proto.RegisterType((*DeleteCardRequest)(nil), "core.DeleteCardRequest")
	proto.RegisterType((*DeleteCardReply)(nil), "core.DeleteCardReply")
	proto.RegisterType((*GetCardsRequest)(nil), "core.GetCardsRequest")
	proto.RegisterType((*GetCardsReply)(nil), "core.GetCardsReply")
	proto.RegisterType((*GetCardByIDRequest)(nil), "core.GetCardByIDRequest")
	proto.RegisterType((*GetCardReply)(nil), "core.GetCardReply")
	proto.RegisterType((*Shop)(nil), "core.Shop")
	proto.RegisterType((*ShopProfileRequest)(nil), "core.ShopProfileRequest")
	proto.RegisterType((*ShopProfileReply)(nil), "core.ShopProfileReply")
	proto.RegisterType((*FindOrCreateShopForSupplierRequest)(nil), "core.FindOrCreateShopForSupplierRequest")
	proto.RegisterType((*FindOrCreateShopForSupplierReply)(nil), "core.FindOrCreateShopForSupplierReply")
	proto.RegisterType((*FindOrCreateAttachedShopRequest)(nil), "core.FindOrCreateAttachedShopRequest")
	proto.RegisterType((*FindOrCreateAttachedShopReply)(nil), "core.FindOrCreateAttachedShopReply")
	proto.RegisterType((*GetMainTagsRequest)(nil), "core.GetMainTagsRequest")
	proto.RegisterType((*GetRelatedTagsRequest)(nil), "core.GetRelatedTagsRequest")
	proto.RegisterType((*TagSearchResult)(nil), "core.TagSearchResult")
	proto.RegisterType((*Tag)(nil), "core.Tag")
	proto.RegisterType((*CreateUserRequest)(nil), "core.CreateUserRequest")
	proto.RegisterType((*ReadUserRequest)(nil), "core.ReadUserRequest")
	proto.RegisterType((*SearchUserReply)(nil), "core.SearchUserReply")
	proto.RegisterType((*ReadUserReply)(nil), "core.ReadUserReply")
	proto.RegisterType((*User)(nil), "core.User")
	proto.RegisterType((*SetEmailRequest)(nil), "core.SetEmailRequest")
	proto.RegisterType((*SetEmailReply)(nil), "core.SetEmailReply")
	proto.RegisterType((*SetDataRequest)(nil), "core.SetDataRequest")
	proto.RegisterType((*SetDataReply)(nil), "core.SetDataReply")
	proto.RegisterType((*AddTelegramRequest)(nil), "core.AddTelegramRequest")
	proto.RegisterType((*AddTelegramReply)(nil), "core.AddTelegramReply")
	proto.RegisterType((*Telegram)(nil), "core.Telegram")
	proto.RegisterType((*ListTelegramsRequest)(nil), "core.ListTelegramsRequest")
	proto.RegisterType((*ListTelegramsReply)(nil), "core.ListTelegramsReply")
	proto.RegisterType((*ConfirmTelegramRequest)(nil), "core.ConfirmTelegramRequest")
	proto.RegisterType((*ConfirmTelegramReply)(nil), "core.ConfirmTelegramReply")
	proto.RegisterType((*DelTelegramRequest)(nil), "core.DelTelegramRequest")
	proto.RegisterType((*DelTelegramReply)(nil), "core.DelTelegramReply")
	proto.RegisterEnum("core.LeadAction", LeadAction_name, LeadAction_value)
	proto.RegisterEnum("core.LeadUserRole", LeadUserRole_name, LeadUserRole_value)
	proto.RegisterEnum("core.LeadStatus", LeadStatus_name, LeadStatus_value)
	proto.RegisterEnum("core.LeadStatusEvent", LeadStatusEvent_name, LeadStatusEvent_value)
	proto.RegisterEnum("core.TokenType", TokenType_name, TokenType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for LeadService service

type LeadServiceClient interface {
	// Create lead. ID of created lead is returned
	CreateLead(ctx context.Context, in *Lead, opts ...grpc.CallOption) (*CreateLeadResult, error)
	// Find lead id
	ReadLead(ctx context.Context, in *ReadLeadRequest, opts ...grpc.CallOption) (*ReadLeadResult, error)
	// returns user leads filtred by user's roles
	GetUserLeads(ctx context.Context, in *UserLeadsRequest, opts ...grpc.CallOption) (*UserLeadsReply, error)
	// returns full lead info
	GetLead(ctx context.Context, in *GetLeadRequest, opts ...grpc.CallOption) (*GetLeadReply, error)
	// changes lead state
	SetLeadStatus(ctx context.Context, in *SetLeadStatusRequest, opts ...grpc.CallOption) (*SetLeadStatusReply, error)
	CallSupplier(ctx context.Context, in *CallSupplierRequest, opts ...grpc.CallOption) (*CallSupplierReply, error)
	CallCustomer(ctx context.Context, in *CallCustomerRequest, opts ...grpc.CallOption) (*CallCustomerReply, error)
	GetCancelReasons(ctx context.Context, in *GetCancelReasonsRequest, opts ...grpc.CallOption) (*GetCancelReasonsReply, error)
	GetUserRole(ctx context.Context, in *GetUserRoleRequest, opts ...grpc.CallOption) (*GetUserRoleReply, error)
}

type leadServiceClient struct {
	cc *grpc.ClientConn
}

func NewLeadServiceClient(cc *grpc.ClientConn) LeadServiceClient {
	return &leadServiceClient{cc}
}

func (c *leadServiceClient) CreateLead(ctx context.Context, in *Lead, opts ...grpc.CallOption) (*CreateLeadResult, error) {
	out := new(CreateLeadResult)
	err := grpc.Invoke(ctx, "/core.LeadService/CreateLead", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadServiceClient) ReadLead(ctx context.Context, in *ReadLeadRequest, opts ...grpc.CallOption) (*ReadLeadResult, error) {
	out := new(ReadLeadResult)
	err := grpc.Invoke(ctx, "/core.LeadService/ReadLead", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadServiceClient) GetUserLeads(ctx context.Context, in *UserLeadsRequest, opts ...grpc.CallOption) (*UserLeadsReply, error) {
	out := new(UserLeadsReply)
	err := grpc.Invoke(ctx, "/core.LeadService/GetUserLeads", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadServiceClient) GetLead(ctx context.Context, in *GetLeadRequest, opts ...grpc.CallOption) (*GetLeadReply, error) {
	out := new(GetLeadReply)
	err := grpc.Invoke(ctx, "/core.LeadService/GetLead", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadServiceClient) SetLeadStatus(ctx context.Context, in *SetLeadStatusRequest, opts ...grpc.CallOption) (*SetLeadStatusReply, error) {
	out := new(SetLeadStatusReply)
	err := grpc.Invoke(ctx, "/core.LeadService/SetLeadStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadServiceClient) CallSupplier(ctx context.Context, in *CallSupplierRequest, opts ...grpc.CallOption) (*CallSupplierReply, error) {
	out := new(CallSupplierReply)
	err := grpc.Invoke(ctx, "/core.LeadService/CallSupplier", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadServiceClient) CallCustomer(ctx context.Context, in *CallCustomerRequest, opts ...grpc.CallOption) (*CallCustomerReply, error) {
	out := new(CallCustomerReply)
	err := grpc.Invoke(ctx, "/core.LeadService/CallCustomer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadServiceClient) GetCancelReasons(ctx context.Context, in *GetCancelReasonsRequest, opts ...grpc.CallOption) (*GetCancelReasonsReply, error) {
	out := new(GetCancelReasonsReply)
	err := grpc.Invoke(ctx, "/core.LeadService/GetCancelReasons", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadServiceClient) GetUserRole(ctx context.Context, in *GetUserRoleRequest, opts ...grpc.CallOption) (*GetUserRoleReply, error) {
	out := new(GetUserRoleReply)
	err := grpc.Invoke(ctx, "/core.LeadService/GetUserRole", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for LeadService service

type LeadServiceServer interface {
	// Create lead. ID of created lead is returned
	CreateLead(context.Context, *Lead) (*CreateLeadResult, error)
	// Find lead id
	ReadLead(context.Context, *ReadLeadRequest) (*ReadLeadResult, error)
	// returns user leads filtred by user's roles
	GetUserLeads(context.Context, *UserLeadsRequest) (*UserLeadsReply, error)
	// returns full lead info
	GetLead(context.Context, *GetLeadRequest) (*GetLeadReply, error)
	// changes lead state
	SetLeadStatus(context.Context, *SetLeadStatusRequest) (*SetLeadStatusReply, error)
	CallSupplier(context.Context, *CallSupplierRequest) (*CallSupplierReply, error)
	CallCustomer(context.Context, *CallCustomerRequest) (*CallCustomerReply, error)
	GetCancelReasons(context.Context, *GetCancelReasonsRequest) (*GetCancelReasonsReply, error)
	GetUserRole(context.Context, *GetUserRoleRequest) (*GetUserRoleReply, error)
}

func RegisterLeadServiceServer(s *grpc.Server, srv LeadServiceServer) {
	s.RegisterService(&_LeadService_serviceDesc, srv)
}

func _LeadService_CreateLead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Lead)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadServiceServer).CreateLead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.LeadService/CreateLead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadServiceServer).CreateLead(ctx, req.(*Lead))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadService_ReadLead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadLeadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadServiceServer).ReadLead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.LeadService/ReadLead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadServiceServer).ReadLead(ctx, req.(*ReadLeadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadService_GetUserLeads_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserLeadsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadServiceServer).GetUserLeads(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.LeadService/GetUserLeads",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadServiceServer).GetUserLeads(ctx, req.(*UserLeadsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadService_GetLead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLeadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadServiceServer).GetLead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.LeadService/GetLead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadServiceServer).GetLead(ctx, req.(*GetLeadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadService_SetLeadStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLeadStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadServiceServer).SetLeadStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.LeadService/SetLeadStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadServiceServer).SetLeadStatus(ctx, req.(*SetLeadStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadService_CallSupplier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallSupplierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadServiceServer).CallSupplier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.LeadService/CallSupplier",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadServiceServer).CallSupplier(ctx, req.(*CallSupplierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadService_CallCustomer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallCustomerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadServiceServer).CallCustomer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.LeadService/CallCustomer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadServiceServer).CallCustomer(ctx, req.(*CallCustomerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadService_GetCancelReasons_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCancelReasonsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadServiceServer).GetCancelReasons(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.LeadService/GetCancelReasons",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadServiceServer).GetCancelReasons(ctx, req.(*GetCancelReasonsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadService_GetUserRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadServiceServer).GetUserRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.LeadService/GetUserRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadServiceServer).GetUserRole(ctx, req.(*GetUserRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _LeadService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "core.LeadService",
	HandlerType: (*LeadServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateLead",
			Handler:    _LeadService_CreateLead_Handler,
		},
		{
			MethodName: "ReadLead",
			Handler:    _LeadService_ReadLead_Handler,
		},
		{
			MethodName: "GetUserLeads",
			Handler:    _LeadService_GetUserLeads_Handler,
		},
		{
			MethodName: "GetLead",
			Handler:    _LeadService_GetLead_Handler,
		},
		{
			MethodName: "SetLeadStatus",
			Handler:    _LeadService_SetLeadStatus_Handler,
		},
		{
			MethodName: "CallSupplier",
			Handler:    _LeadService_CallSupplier_Handler,
		},
		{
			MethodName: "CallCustomer",
			Handler:    _LeadService_CallCustomer_Handler,
		},
		{
			MethodName: "GetCancelReasons",
			Handler:    _LeadService_GetCancelReasons_Handler,
		},
		{
			MethodName: "GetUserRole",
			Handler:    _LeadService_GetUserRole_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core.proto",
}

// Client API for MonetizationService service

type MonetizationServiceClient interface {
	// get plan by id
	GetPlan(ctx context.Context, in *GetPlanRequest, opts ...grpc.CallOption) (*GetPlanReply, error)
	// returns list of public plans
	GetPlansList(ctx context.Context, in *GetPlansListRequest, opts ...grpc.CallOption) (*GetPlansListReply, error)
	GetCoinsOffers(ctx context.Context, in *GetCoinsOffersRequest, opts ...grpc.CallOption) (*GetCoinsOffersReply, error)
	// subscribe shop to plan
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeReply, error)
	// sets autorefill coins offer for user
	SetAutorefill(ctx context.Context, in *SetAutorefillRequest, opts ...grpc.CallOption) (*SetAutorefillReply, error)
}

type monetizationServiceClient struct {
	cc *grpc.ClientConn
}

func NewMonetizationServiceClient(cc *grpc.ClientConn) MonetizationServiceClient {
	return &monetizationServiceClient{cc}
}

func (c *monetizationServiceClient) GetPlan(ctx context.Context, in *GetPlanRequest, opts ...grpc.CallOption) (*GetPlanReply, error) {
	out := new(GetPlanReply)
	err := grpc.Invoke(ctx, "/core.MonetizationService/GetPlan", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monetizationServiceClient) GetPlansList(ctx context.Context, in *GetPlansListRequest, opts ...grpc.CallOption) (*GetPlansListReply, error) {
	out := new(GetPlansListReply)
	err := grpc.Invoke(ctx, "/core.MonetizationService/GetPlansList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monetizationServiceClient) GetCoinsOffers(ctx context.Context, in *GetCoinsOffersRequest, opts ...grpc.CallOption) (*GetCoinsOffersReply, error) {
	out := new(GetCoinsOffersReply)
	err := grpc.Invoke(ctx, "/core.MonetizationService/GetCoinsOffers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monetizationServiceClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeReply, error) {
	out := new(SubscribeReply)
	err := grpc.Invoke(ctx, "/core.MonetizationService/Subscribe", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monetizationServiceClient) SetAutorefill(ctx context.Context, in *SetAutorefillRequest, opts ...grpc.CallOption) (*SetAutorefillReply, error) {
	out := new(SetAutorefillReply)
	err := grpc.Invoke(ctx, "/core.MonetizationService/SetAutorefill", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MonetizationService service

type MonetizationServiceServer interface {
	// get plan by id
	GetPlan(context.Context, *GetPlanRequest) (*GetPlanReply, error)
	// returns list of public plans
	GetPlansList(context.Context, *GetPlansListRequest) (*GetPlansListReply, error)
	GetCoinsOffers(context.Context, *GetCoinsOffersRequest) (*GetCoinsOffersReply, error)
	// subscribe shop to plan
	Subscribe(context.Context, *SubscribeRequest) (*SubscribeReply, error)
	// sets autorefill coins offer for user
	SetAutorefill(context.Context, *SetAutorefillRequest) (*SetAutorefillReply, error)
}

func RegisterMonetizationServiceServer(s *grpc.Server, srv MonetizationServiceServer) {
	s.RegisterService(&_MonetizationService_serviceDesc, srv)
}

func _MonetizationService_GetPlan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPlanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonetizationServiceServer).GetPlan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.MonetizationService/GetPlan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonetizationServiceServer).GetPlan(ctx, req.(*GetPlanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonetizationService_GetPlansList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPlansListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonetizationServiceServer).GetPlansList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.MonetizationService/GetPlansList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonetizationServiceServer).GetPlansList(ctx, req.(*GetPlansListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonetizationService_GetCoinsOffers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCoinsOffersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonetizationServiceServer).GetCoinsOffers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.MonetizationService/GetCoinsOffers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonetizationServiceServer).GetCoinsOffers(ctx, req.(*GetCoinsOffersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonetizationService_Subscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonetizationServiceServer).Subscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.MonetizationService/Subscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonetizationServiceServer).Subscribe(ctx, req.(*SubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonetizationService_SetAutorefill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAutorefillRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonetizationServiceServer).SetAutorefill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.MonetizationService/SetAutorefill",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonetizationServiceServer).SetAutorefill(ctx, req.(*SetAutorefillRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MonetizationService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "core.MonetizationService",
	HandlerType: (*MonetizationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPlan",
			Handler:    _MonetizationService_GetPlan_Handler,
		},
		{
			MethodName: "GetPlansList",
			Handler:    _MonetizationService_GetPlansList_Handler,
		},
		{
			MethodName: "GetCoinsOffers",
			Handler:    _MonetizationService_GetCoinsOffers_Handler,
		},
		{
			MethodName: "Subscribe",
			Handler:    _MonetizationService_Subscribe_Handler,
		},
		{
			MethodName: "SetAutorefill",
			Handler:    _MonetizationService_SetAutorefill_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core.proto",
}

// Client API for ProductService service

type ProductServiceClient interface {
	// Get product by id
	GetProduct(ctx context.Context, in *GetProductRequest, opts ...grpc.CallOption) (*ProductSearchResult, error)
	// Same search, but return only id
	ReadProduct(ctx context.Context, in *GetProductRequest, opts ...grpc.CallOption) (*ProductReadResult, error)
	// Search products
	SearchProducts(ctx context.Context, in *SearchProductRequest, opts ...grpc.CallOption) (*ProductSearchResult, error)
	// Create product
	CreateProduct(ctx context.Context, in *CreateProductRequest, opts ...grpc.CallOption) (*CreateProductResult, error)
	LikeProduct(ctx context.Context, in *LikeProductRequest, opts ...grpc.CallOption) (*LikeProductReply, error)
	// returns list of product ids that are liked by user
	GetLikedBy(ctx context.Context, in *GetLikedByRequest, opts ...grpc.CallOption) (*GetLikedByReply, error)
	// Method returns list of product with non-default chat templates
	GetSpecialProducts(ctx context.Context, in *GetSpecialProductsRequest, opts ...grpc.CallOption) (*GetSpecialProductsReply, error)
	// get last product ID
	GetLastProductID(ctx context.Context, in *GetLastProductIDRequest, opts ...grpc.CallOption) (*GetLastProductIDReply, error)
	// Del product
	DelProduct(ctx context.Context, in *DelProductRequest, opts ...grpc.CallOption) (*DelProductReply, error)
}

type productServiceClient struct {
	cc *grpc.ClientConn
}

func NewProductServiceClient(cc *grpc.ClientConn) ProductServiceClient {
	return &productServiceClient{cc}
}

func (c *productServiceClient) GetProduct(ctx context.Context, in *GetProductRequest, opts ...grpc.CallOption) (*ProductSearchResult, error) {
	out := new(ProductSearchResult)
	err := grpc.Invoke(ctx, "/core.ProductService/GetProduct", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) ReadProduct(ctx context.Context, in *GetProductRequest, opts ...grpc.CallOption) (*ProductReadResult, error) {
	out := new(ProductReadResult)
	err := grpc.Invoke(ctx, "/core.ProductService/ReadProduct", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) SearchProducts(ctx context.Context, in *SearchProductRequest, opts ...grpc.CallOption) (*ProductSearchResult, error) {
	out := new(ProductSearchResult)
	err := grpc.Invoke(ctx, "/core.ProductService/SearchProducts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) CreateProduct(ctx context.Context, in *CreateProductRequest, opts ...grpc.CallOption) (*CreateProductResult, error) {
	out := new(CreateProductResult)
	err := grpc.Invoke(ctx, "/core.ProductService/CreateProduct", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) LikeProduct(ctx context.Context, in *LikeProductRequest, opts ...grpc.CallOption) (*LikeProductReply, error) {
	out := new(LikeProductReply)
	err := grpc.Invoke(ctx, "/core.ProductService/LikeProduct", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) GetLikedBy(ctx context.Context, in *GetLikedByRequest, opts ...grpc.CallOption) (*GetLikedByReply, error) {
	out := new(GetLikedByReply)
	err := grpc.Invoke(ctx, "/core.ProductService/GetLikedBy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) GetSpecialProducts(ctx context.Context, in *GetSpecialProductsRequest, opts ...grpc.CallOption) (*GetSpecialProductsReply, error) {
	out := new(GetSpecialProductsReply)
	err := grpc.Invoke(ctx, "/core.ProductService/GetSpecialProducts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) GetLastProductID(ctx context.Context, in *GetLastProductIDRequest, opts ...grpc.CallOption) (*GetLastProductIDReply, error) {
	out := new(GetLastProductIDReply)
	err := grpc.Invoke(ctx, "/core.ProductService/GetLastProductID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) DelProduct(ctx context.Context, in *DelProductRequest, opts ...grpc.CallOption) (*DelProductReply, error) {
	out := new(DelProductReply)
	err := grpc.Invoke(ctx, "/core.ProductService/DelProduct", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ProductService service

type ProductServiceServer interface {
	// Get product by id
	GetProduct(context.Context, *GetProductRequest) (*ProductSearchResult, error)
	// Same search, but return only id
	ReadProduct(context.Context, *GetProductRequest) (*ProductReadResult, error)
	// Search products
	SearchProducts(context.Context, *SearchProductRequest) (*ProductSearchResult, error)
	// Create product
	CreateProduct(context.Context, *CreateProductRequest) (*CreateProductResult, error)
	LikeProduct(context.Context, *LikeProductRequest) (*LikeProductReply, error)
	// returns list of product ids that are liked by user
	GetLikedBy(context.Context, *GetLikedByRequest) (*GetLikedByReply, error)
	// Method returns list of product with non-default chat templates
	GetSpecialProducts(context.Context, *GetSpecialProductsRequest) (*GetSpecialProductsReply, error)
	// get last product ID
	GetLastProductID(context.Context, *GetLastProductIDRequest) (*GetLastProductIDReply, error)
	// Del product
	DelProduct(context.Context, *DelProductRequest) (*DelProductReply, error)
}

func RegisterProductServiceServer(s *grpc.Server, srv ProductServiceServer) {
	s.RegisterService(&_ProductService_serviceDesc, srv)
}

func _ProductService_GetProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).GetProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.ProductService/GetProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).GetProduct(ctx, req.(*GetProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_ReadProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).ReadProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.ProductService/ReadProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).ReadProduct(ctx, req.(*GetProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_SearchProducts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).SearchProducts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.ProductService/SearchProducts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).SearchProducts(ctx, req.(*SearchProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_CreateProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).CreateProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.ProductService/CreateProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).CreateProduct(ctx, req.(*CreateProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_LikeProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LikeProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).LikeProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.ProductService/LikeProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).LikeProduct(ctx, req.(*LikeProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_GetLikedBy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLikedByRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).GetLikedBy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.ProductService/GetLikedBy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).GetLikedBy(ctx, req.(*GetLikedByRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_GetSpecialProducts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSpecialProductsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).GetSpecialProducts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.ProductService/GetSpecialProducts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).GetSpecialProducts(ctx, req.(*GetSpecialProductsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_GetLastProductID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLastProductIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).GetLastProductID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.ProductService/GetLastProductID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).GetLastProductID(ctx, req.(*GetLastProductIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_DelProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).DelProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.ProductService/DelProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).DelProduct(ctx, req.(*DelProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ProductService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "core.ProductService",
	HandlerType: (*ProductServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetProduct",
			Handler:    _ProductService_GetProduct_Handler,
		},
		{
			MethodName: "ReadProduct",
			Handler:    _ProductService_ReadProduct_Handler,
		},
		{
			MethodName: "SearchProducts",
			Handler:    _ProductService_SearchProducts_Handler,
		},
		{
			MethodName: "CreateProduct",
			Handler:    _ProductService_CreateProduct_Handler,
		},
		{
			MethodName: "LikeProduct",
			Handler:    _ProductService_LikeProduct_Handler,
		},
		{
			MethodName: "GetLikedBy",
			Handler:    _ProductService_GetLikedBy_Handler,
		},
		{
			MethodName: "GetSpecialProducts",
			Handler:    _ProductService_GetSpecialProducts_Handler,
		},
		{
			MethodName: "GetLastProductID",
			Handler:    _ProductService_GetLastProductID_Handler,
		},
		{
			MethodName: "DelProduct",
			Handler:    _ProductService_DelProduct_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core.proto",
}

// Client API for PushTokensService service

type PushTokensServiceClient interface {
	AddToken(ctx context.Context, in *AddTokenRequest, opts ...grpc.CallOption) (*ErrorResult, error)
	DelToken(ctx context.Context, in *DelTokenRequest, opts ...grpc.CallOption) (*ErrorResult, error)
	GetTokens(ctx context.Context, in *GetTokensRequest, opts ...grpc.CallOption) (*GetTokensResult, error)
	InvalidateTokens(ctx context.Context, in *InvalidateTokensRequest, opts ...grpc.CallOption) (*InvalidateTokensResult, error)
	UpdateToken(ctx context.Context, in *UpdateTokenRequest, opts ...grpc.CallOption) (*UpdateTokenResult, error)
}

type pushTokensServiceClient struct {
	cc *grpc.ClientConn
}

func NewPushTokensServiceClient(cc *grpc.ClientConn) PushTokensServiceClient {
	return &pushTokensServiceClient{cc}
}

func (c *pushTokensServiceClient) AddToken(ctx context.Context, in *AddTokenRequest, opts ...grpc.CallOption) (*ErrorResult, error) {
	out := new(ErrorResult)
	err := grpc.Invoke(ctx, "/core.PushTokensService/AddToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pushTokensServiceClient) DelToken(ctx context.Context, in *DelTokenRequest, opts ...grpc.CallOption) (*ErrorResult, error) {
	out := new(ErrorResult)
	err := grpc.Invoke(ctx, "/core.PushTokensService/DelToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pushTokensServiceClient) GetTokens(ctx context.Context, in *GetTokensRequest, opts ...grpc.CallOption) (*GetTokensResult, error) {
	out := new(GetTokensResult)
	err := grpc.Invoke(ctx, "/core.PushTokensService/GetTokens", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pushTokensServiceClient) InvalidateTokens(ctx context.Context, in *InvalidateTokensRequest, opts ...grpc.CallOption) (*InvalidateTokensResult, error) {
	out := new(InvalidateTokensResult)
	err := grpc.Invoke(ctx, "/core.PushTokensService/InvalidateTokens", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pushTokensServiceClient) UpdateToken(ctx context.Context, in *UpdateTokenRequest, opts ...grpc.CallOption) (*UpdateTokenResult, error) {
	out := new(UpdateTokenResult)
	err := grpc.Invoke(ctx, "/core.PushTokensService/UpdateToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for PushTokensService service

type PushTokensServiceServer interface {
	AddToken(context.Context, *AddTokenRequest) (*ErrorResult, error)
	DelToken(context.Context, *DelTokenRequest) (*ErrorResult, error)
	GetTokens(context.Context, *GetTokensRequest) (*GetTokensResult, error)
	InvalidateTokens(context.Context, *InvalidateTokensRequest) (*InvalidateTokensResult, error)
	UpdateToken(context.Context, *UpdateTokenRequest) (*UpdateTokenResult, error)
}

func RegisterPushTokensServiceServer(s *grpc.Server, srv PushTokensServiceServer) {
	s.RegisterService(&_PushTokensService_serviceDesc, srv)
}

func _PushTokensService_AddToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PushTokensServiceServer).AddToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.PushTokensService/AddToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PushTokensServiceServer).AddToken(ctx, req.(*AddTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PushTokensService_DelToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PushTokensServiceServer).DelToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.PushTokensService/DelToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PushTokensServiceServer).DelToken(ctx, req.(*DelTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PushTokensService_GetTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PushTokensServiceServer).GetTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.PushTokensService/GetTokens",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PushTokensServiceServer).GetTokens(ctx, req.(*GetTokensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PushTokensService_InvalidateTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvalidateTokensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PushTokensServiceServer).InvalidateTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.PushTokensService/InvalidateTokens",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PushTokensServiceServer).InvalidateTokens(ctx, req.(*InvalidateTokensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PushTokensService_UpdateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PushTokensServiceServer).UpdateToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.PushTokensService/UpdateToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PushTokensServiceServer).UpdateToken(ctx, req.(*UpdateTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _PushTokensService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "core.PushTokensService",
	HandlerType: (*PushTokensServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddToken",
			Handler:    _PushTokensService_AddToken_Handler,
		},
		{
			MethodName: "DelToken",
			Handler:    _PushTokensService_DelToken_Handler,
		},
		{
			MethodName: "GetTokens",
			Handler:    _PushTokensService_GetTokens_Handler,
		},
		{
			MethodName: "InvalidateTokens",
			Handler:    _PushTokensService_InvalidateTokens_Handler,
		},
		{
			MethodName: "UpdateToken",
			Handler:    _PushTokensService_UpdateToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core.proto",
}

// Client API for ShopCardService service

type ShopCardServiceClient interface {
	// cards api
	CreateCard(ctx context.Context, in *CreateCardRequest, opts ...grpc.CallOption) (*CreateCardReply, error)
	DeleteCard(ctx context.Context, in *DeleteCardRequest, opts ...grpc.CallOption) (*DeleteCardReply, error)
	GetCards(ctx context.Context, in *GetCardsRequest, opts ...grpc.CallOption) (*GetCardsReply, error)
	GetCardByID(ctx context.Context, in *GetCardByIDRequest, opts ...grpc.CallOption) (*GetCardReply, error)
}

type shopCardServiceClient struct {
	cc *grpc.ClientConn
}

func NewShopCardServiceClient(cc *grpc.ClientConn) ShopCardServiceClient {
	return &shopCardServiceClient{cc}
}

func (c *shopCardServiceClient) CreateCard(ctx context.Context, in *CreateCardRequest, opts ...grpc.CallOption) (*CreateCardReply, error) {
	out := new(CreateCardReply)
	err := grpc.Invoke(ctx, "/core.ShopCardService/CreateCard", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shopCardServiceClient) DeleteCard(ctx context.Context, in *DeleteCardRequest, opts ...grpc.CallOption) (*DeleteCardReply, error) {
	out := new(DeleteCardReply)
	err := grpc.Invoke(ctx, "/core.ShopCardService/DeleteCard", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shopCardServiceClient) GetCards(ctx context.Context, in *GetCardsRequest, opts ...grpc.CallOption) (*GetCardsReply, error) {
	out := new(GetCardsReply)
	err := grpc.Invoke(ctx, "/core.ShopCardService/GetCards", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shopCardServiceClient) GetCardByID(ctx context.Context, in *GetCardByIDRequest, opts ...grpc.CallOption) (*GetCardReply, error) {
	out := new(GetCardReply)
	err := grpc.Invoke(ctx, "/core.ShopCardService/GetCardByID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ShopCardService service

type ShopCardServiceServer interface {
	// cards api
	CreateCard(context.Context, *CreateCardRequest) (*CreateCardReply, error)
	DeleteCard(context.Context, *DeleteCardRequest) (*DeleteCardReply, error)
	GetCards(context.Context, *GetCardsRequest) (*GetCardsReply, error)
	GetCardByID(context.Context, *GetCardByIDRequest) (*GetCardReply, error)
}

func RegisterShopCardServiceServer(s *grpc.Server, srv ShopCardServiceServer) {
	s.RegisterService(&_ShopCardService_serviceDesc, srv)
}

func _ShopCardService_CreateCard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShopCardServiceServer).CreateCard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.ShopCardService/CreateCard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShopCardServiceServer).CreateCard(ctx, req.(*CreateCardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShopCardService_DeleteCard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShopCardServiceServer).DeleteCard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.ShopCardService/DeleteCard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShopCardServiceServer).DeleteCard(ctx, req.(*DeleteCardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShopCardService_GetCards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShopCardServiceServer).GetCards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.ShopCardService/GetCards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShopCardServiceServer).GetCards(ctx, req.(*GetCardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShopCardService_GetCardByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCardByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShopCardServiceServer).GetCardByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.ShopCardService/GetCardByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShopCardServiceServer).GetCardByID(ctx, req.(*GetCardByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ShopCardService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "core.ShopCardService",
	HandlerType: (*ShopCardServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCard",
			Handler:    _ShopCardService_CreateCard_Handler,
		},
		{
			MethodName: "DeleteCard",
			Handler:    _ShopCardService_DeleteCard_Handler,
		},
		{
			MethodName: "GetCards",
			Handler:    _ShopCardService_GetCards_Handler,
		},
		{
			MethodName: "GetCardByID",
			Handler:    _ShopCardService_GetCardByID_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core.proto",
}

// Client API for ShopService service

type ShopServiceClient interface {
	// returns a public profile of the shop
	GetShopProfile(ctx context.Context, in *ShopProfileRequest, opts ...grpc.CallOption) (*ShopProfileReply, error)
	FindOrCreateShopForSupplier(ctx context.Context, in *FindOrCreateShopForSupplierRequest, opts ...grpc.CallOption) (*FindOrCreateShopForSupplierReply, error)
	FindOrCreateAttachedShop(ctx context.Context, in *FindOrCreateAttachedShopRequest, opts ...grpc.CallOption) (*FindOrCreateAttachedShopReply, error)
}

type shopServiceClient struct {
	cc *grpc.ClientConn
}

func NewShopServiceClient(cc *grpc.ClientConn) ShopServiceClient {
	return &shopServiceClient{cc}
}

func (c *shopServiceClient) GetShopProfile(ctx context.Context, in *ShopProfileRequest, opts ...grpc.CallOption) (*ShopProfileReply, error) {
	out := new(ShopProfileReply)
	err := grpc.Invoke(ctx, "/core.ShopService/GetShopProfile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shopServiceClient) FindOrCreateShopForSupplier(ctx context.Context, in *FindOrCreateShopForSupplierRequest, opts ...grpc.CallOption) (*FindOrCreateShopForSupplierReply, error) {
	out := new(FindOrCreateShopForSupplierReply)
	err := grpc.Invoke(ctx, "/core.ShopService/FindOrCreateShopForSupplier", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shopServiceClient) FindOrCreateAttachedShop(ctx context.Context, in *FindOrCreateAttachedShopRequest, opts ...grpc.CallOption) (*FindOrCreateAttachedShopReply, error) {
	out := new(FindOrCreateAttachedShopReply)
	err := grpc.Invoke(ctx, "/core.ShopService/FindOrCreateAttachedShop", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ShopService service

type ShopServiceServer interface {
	// returns a public profile of the shop
	GetShopProfile(context.Context, *ShopProfileRequest) (*ShopProfileReply, error)
	FindOrCreateShopForSupplier(context.Context, *FindOrCreateShopForSupplierRequest) (*FindOrCreateShopForSupplierReply, error)
	FindOrCreateAttachedShop(context.Context, *FindOrCreateAttachedShopRequest) (*FindOrCreateAttachedShopReply, error)
}

func RegisterShopServiceServer(s *grpc.Server, srv ShopServiceServer) {
	s.RegisterService(&_ShopService_serviceDesc, srv)
}

func _ShopService_GetShopProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShopProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShopServiceServer).GetShopProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.ShopService/GetShopProfile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShopServiceServer).GetShopProfile(ctx, req.(*ShopProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShopService_FindOrCreateShopForSupplier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindOrCreateShopForSupplierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShopServiceServer).FindOrCreateShopForSupplier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.ShopService/FindOrCreateShopForSupplier",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShopServiceServer).FindOrCreateShopForSupplier(ctx, req.(*FindOrCreateShopForSupplierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShopService_FindOrCreateAttachedShop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindOrCreateAttachedShopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShopServiceServer).FindOrCreateAttachedShop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.ShopService/FindOrCreateAttachedShop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShopServiceServer).FindOrCreateAttachedShop(ctx, req.(*FindOrCreateAttachedShopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ShopService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "core.ShopService",
	HandlerType: (*ShopServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetShopProfile",
			Handler:    _ShopService_GetShopProfile_Handler,
		},
		{
			MethodName: "FindOrCreateShopForSupplier",
			Handler:    _ShopService_FindOrCreateShopForSupplier_Handler,
		},
		{
			MethodName: "FindOrCreateAttachedShop",
			Handler:    _ShopService_FindOrCreateAttachedShop_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core.proto",
}

// Client API for TagService service

type TagServiceClient interface {
	// get tags that should be displayed in main page
	GetMainTags(ctx context.Context, in *GetMainTagsRequest, opts ...grpc.CallOption) (*TagSearchResult, error)
	// get tags that should be displayed near selected tags (GetRelatedTagsRequest.Tags)
	GetRelatedTags(ctx context.Context, in *GetRelatedTagsRequest, opts ...grpc.CallOption) (*TagSearchResult, error)
}

type tagServiceClient struct {
	cc *grpc.ClientConn
}

func NewTagServiceClient(cc *grpc.ClientConn) TagServiceClient {
	return &tagServiceClient{cc}
}

func (c *tagServiceClient) GetMainTags(ctx context.Context, in *GetMainTagsRequest, opts ...grpc.CallOption) (*TagSearchResult, error) {
	out := new(TagSearchResult)
	err := grpc.Invoke(ctx, "/core.TagService/GetMainTags", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) GetRelatedTags(ctx context.Context, in *GetRelatedTagsRequest, opts ...grpc.CallOption) (*TagSearchResult, error) {
	out := new(TagSearchResult)
	err := grpc.Invoke(ctx, "/core.TagService/GetRelatedTags", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TagService service

type TagServiceServer interface {
	// get tags that should be displayed in main page
	GetMainTags(context.Context, *GetMainTagsRequest) (*TagSearchResult, error)
	// get tags that should be displayed near selected tags (GetRelatedTagsRequest.Tags)
	GetRelatedTags(context.Context, *GetRelatedTagsRequest) (*TagSearchResult, error)
}

func RegisterTagServiceServer(s *grpc.Server, srv TagServiceServer) {
	s.RegisterService(&_TagService_serviceDesc, srv)
}

func _TagService_GetMainTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMainTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).GetMainTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.TagService/GetMainTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).GetMainTags(ctx, req.(*GetMainTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_GetRelatedTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRelatedTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).GetRelatedTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.TagService/GetRelatedTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).GetRelatedTags(ctx, req.(*GetRelatedTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TagService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "core.TagService",
	HandlerType: (*TagServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMainTags",
			Handler:    _TagService_GetMainTags_Handler,
		},
		{
			MethodName: "GetRelatedTags",
			Handler:    _TagService_GetRelatedTags_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core.proto",
}

// Client API for UserService service

type UserServiceClient interface {
	// returns a user with a specific email. If not exists, creates it
	FindOrCreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*ReadUserReply, error)
	CreateFakeUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*ReadUserReply, error)
	// returns a user that mathes request options
	ReadUser(ctx context.Context, in *ReadUserRequest, opts ...grpc.CallOption) (*ReadUserReply, error)
	SetEmail(ctx context.Context, in *SetEmailRequest, opts ...grpc.CallOption) (*SetEmailReply, error)
	SetData(ctx context.Context, in *SetDataRequest, opts ...grpc.CallOption) (*SetDataReply, error)
	AddTelegram(ctx context.Context, in *AddTelegramRequest, opts ...grpc.CallOption) (*AddTelegramReply, error)
	ConfirmTelegram(ctx context.Context, in *ConfirmTelegramRequest, opts ...grpc.CallOption) (*ConfirmTelegramReply, error)
	ListTelegrams(ctx context.Context, in *ListTelegramsRequest, opts ...grpc.CallOption) (*ListTelegramsReply, error)
	DelTelegram(ctx context.Context, in *DelTelegramRequest, opts ...grpc.CallOption) (*DelTelegramReply, error)
}

type userServiceClient struct {
	cc *grpc.ClientConn
}

func NewUserServiceClient(cc *grpc.ClientConn) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) FindOrCreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*ReadUserReply, error) {
	out := new(ReadUserReply)
	err := grpc.Invoke(ctx, "/core.UserService/FindOrCreateUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) CreateFakeUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*ReadUserReply, error) {
	out := new(ReadUserReply)
	err := grpc.Invoke(ctx, "/core.UserService/CreateFakeUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ReadUser(ctx context.Context, in *ReadUserRequest, opts ...grpc.CallOption) (*ReadUserReply, error) {
	out := new(ReadUserReply)
	err := grpc.Invoke(ctx, "/core.UserService/ReadUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) SetEmail(ctx context.Context, in *SetEmailRequest, opts ...grpc.CallOption) (*SetEmailReply, error) {
	out := new(SetEmailReply)
	err := grpc.Invoke(ctx, "/core.UserService/SetEmail", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) SetData(ctx context.Context, in *SetDataRequest, opts ...grpc.CallOption) (*SetDataReply, error) {
	out := new(SetDataReply)
	err := grpc.Invoke(ctx, "/core.UserService/SetData", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) AddTelegram(ctx context.Context, in *AddTelegramRequest, opts ...grpc.CallOption) (*AddTelegramReply, error) {
	out := new(AddTelegramReply)
	err := grpc.Invoke(ctx, "/core.UserService/AddTelegram", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ConfirmTelegram(ctx context.Context, in *ConfirmTelegramRequest, opts ...grpc.CallOption) (*ConfirmTelegramReply, error) {
	out := new(ConfirmTelegramReply)
	err := grpc.Invoke(ctx, "/core.UserService/ConfirmTelegram", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ListTelegrams(ctx context.Context, in *ListTelegramsRequest, opts ...grpc.CallOption) (*ListTelegramsReply, error) {
	out := new(ListTelegramsReply)
	err := grpc.Invoke(ctx, "/core.UserService/ListTelegrams", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DelTelegram(ctx context.Context, in *DelTelegramRequest, opts ...grpc.CallOption) (*DelTelegramReply, error) {
	out := new(DelTelegramReply)
	err := grpc.Invoke(ctx, "/core.UserService/DelTelegram", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for UserService service

type UserServiceServer interface {
	// returns a user with a specific email. If not exists, creates it
	FindOrCreateUser(context.Context, *CreateUserRequest) (*ReadUserReply, error)
	CreateFakeUser(context.Context, *CreateUserRequest) (*ReadUserReply, error)
	// returns a user that mathes request options
	ReadUser(context.Context, *ReadUserRequest) (*ReadUserReply, error)
	SetEmail(context.Context, *SetEmailRequest) (*SetEmailReply, error)
	SetData(context.Context, *SetDataRequest) (*SetDataReply, error)
	AddTelegram(context.Context, *AddTelegramRequest) (*AddTelegramReply, error)
	ConfirmTelegram(context.Context, *ConfirmTelegramRequest) (*ConfirmTelegramReply, error)
	ListTelegrams(context.Context, *ListTelegramsRequest) (*ListTelegramsReply, error)
	DelTelegram(context.Context, *DelTelegramRequest) (*DelTelegramReply, error)
}

func RegisterUserServiceServer(s *grpc.Server, srv UserServiceServer) {
	s.RegisterService(&_UserService_serviceDesc, srv)
}

func _UserService_FindOrCreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).FindOrCreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.UserService/FindOrCreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).FindOrCreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_CreateFakeUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateFakeUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.UserService/CreateFakeUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateFakeUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ReadUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ReadUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.UserService/ReadUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ReadUser(ctx, req.(*ReadUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_SetEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).SetEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.UserService/SetEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).SetEmail(ctx, req.(*SetEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_SetData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).SetData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.UserService/SetData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).SetData(ctx, req.(*SetDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_AddTelegram_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTelegramRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).AddTelegram(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.UserService/AddTelegram",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).AddTelegram(ctx, req.(*AddTelegramRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ConfirmTelegram_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfirmTelegramRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ConfirmTelegram(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.UserService/ConfirmTelegram",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ConfirmTelegram(ctx, req.(*ConfirmTelegramRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ListTelegrams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTelegramsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ListTelegrams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.UserService/ListTelegrams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ListTelegrams(ctx, req.(*ListTelegramsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DelTelegram_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelTelegramRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DelTelegram(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.UserService/DelTelegram",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DelTelegram(ctx, req.(*DelTelegramRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _UserService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "core.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FindOrCreateUser",
			Handler:    _UserService_FindOrCreateUser_Handler,
		},
		{
			MethodName: "CreateFakeUser",
			Handler:    _UserService_CreateFakeUser_Handler,
		},
		{
			MethodName: "ReadUser",
			Handler:    _UserService_ReadUser_Handler,
		},
		{
			MethodName: "SetEmail",
			Handler:    _UserService_SetEmail_Handler,
		},
		{
			MethodName: "SetData",
			Handler:    _UserService_SetData_Handler,
		},
		{
			MethodName: "AddTelegram",
			Handler:    _UserService_AddTelegram_Handler,
		},
		{
			MethodName: "ConfirmTelegram",
			Handler:    _UserService_ConfirmTelegram_Handler,
		},
		{
			MethodName: "ListTelegrams",
			Handler:    _UserService_ListTelegrams_Handler,
		},
		{
			MethodName: "DelTelegram",
			Handler:    _UserService_DelTelegram_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core.proto",
}

func (m *ReadLeadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadLeadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SearchBy != nil {
		nn1, err := m.SearchBy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *ReadLeadRequest_Id) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintCore(dAtA, i, uint64(m.Id))
	return i, nil
}
func (m *ReadLeadRequest_InstagramPk) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramPk)))
	i += copy(dAtA[i:], m.InstagramPk)
	return i, nil
}
func (m *ReadLeadRequest_ConversationId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	i = encodeVarintCore(dAtA, i, uint64(m.ConversationId))
	return i, nil
}
func (m *ReadLeadResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadLeadResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *Lead) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Lead) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	if len(m.Source) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Comment) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if m.CustomerId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.CustomerId))
	}
	if len(m.InstagramPk) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramPk)))
		i += copy(dAtA[i:], m.InstagramPk)
	}
	if m.ProductId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.ProductId))
	}
	if len(m.InstagramLink) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramLink)))
		i += copy(dAtA[i:], m.InstagramLink)
	}
	if m.Action != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Action))
	}
	if len(m.DirectThread) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.DirectThread)))
		i += copy(dAtA[i:], m.DirectThread)
	}
	if len(m.InstagramMediaId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramMediaId)))
		i += copy(dAtA[i:], m.InstagramMediaId)
	}
	return i, nil
}

func (m *CreateLeadResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateLeadResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	if m.Lead != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Lead.Size()))
		n2, err := m.Lead.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *UserLeadsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserLeadsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	if len(m.Role) > 0 {
		dAtA4 := make([]byte, len(m.Role)*10)
		var j3 int
		for _, num := range m.Role {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if m.LeadId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.LeadId))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Limit))
	}
	if m.Direction {
		dAtA[i] = 0x28
		i++
		if m.Direction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FromUpdatedAt != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.FromUpdatedAt))
	}
	return i, nil
}

func (m *UserLeadsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserLeadsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Leads) > 0 {
		for _, msg := range m.Leads {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LeadInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeadInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	if len(m.Source) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Comment) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if m.CustomerId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.CustomerId))
	}
	if len(m.Products) > 0 {
		for _, msg := range m.Products {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintCore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.InstagramPk) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramPk)))
		i += copy(dAtA[i:], m.InstagramPk)
	}
	if m.Customer != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Customer.Size()))
		n5, err := m.Customer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Status != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Status))
	}
	if m.UserRole != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserRole))
	}
	if m.ConversationId != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.ConversationId))
	}
	if m.Shop != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Shop.Size()))
		n6, err := m.Shop.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.UpdatedAt != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UpdatedAt))
	}
	if len(m.InstagramLink) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramLink)))
		i += copy(dAtA[i:], m.InstagramLink)
	}
	if m.CancelReason != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.CancelReason))
	}
	if len(m.StatusComment) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.StatusComment)))
		i += copy(dAtA[i:], m.StatusComment)
	}
	if m.UpdatedAtAgo != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UpdatedAtAgo))
	}
	if len(m.InstagramMediaId) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramMediaId)))
		i += copy(dAtA[i:], m.InstagramMediaId)
	}
	return i, nil
}

func (m *LeadEventMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeadEventMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LeadId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.LeadId))
	}
	if len(m.Event) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Event)))
		i += copy(dAtA[i:], m.Event)
	}
	if len(m.Users) > 0 {
		dAtA8 := make([]byte, len(m.Users)*10)
		var j7 int
		for _, num := range m.Users {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCore(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	return i, nil
}

func (m *SetLeadStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetLeadStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LeadId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.LeadId))
	}
	if m.Event != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Event))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	if m.CancelReason != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.CancelReason))
	}
	if len(m.StatusComment) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.StatusComment)))
		i += copy(dAtA[i:], m.StatusComment)
	}
	return i, nil
}

func (m *SetLeadStatusReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetLeadStatusReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lead != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Lead.Size()))
		n9, err := m.Lead.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *CallSupplierRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallSupplierRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LeadId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.LeadId))
	}
	return i, nil
}

func (m *CallSupplierReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallSupplierReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CallCustomerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallCustomerRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LeadId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.LeadId))
	}
	return i, nil
}

func (m *CallCustomerReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallCustomerReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetLeadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLeadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	if m.SearchBy != nil {
		nn10, err := m.SearchBy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn10
	}
	return i, nil
}

func (m *GetLeadRequest_Id) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintCore(dAtA, i, uint64(m.Id))
	return i, nil
}
func (m *GetLeadRequest_ConversationId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	i = encodeVarintCore(dAtA, i, uint64(m.ConversationId))
	return i, nil
}
func (m *GetLeadReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLeadReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lead != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Lead.Size()))
		n11, err := m.Lead.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *GetCancelReasonsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCancelReasonsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CancelReason) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelReason) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *GetCancelReasonsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCancelReasonsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reasons) > 0 {
		for _, msg := range m.Reasons {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetUserRoleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserRoleRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	if m.InstagramUserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.InstagramUserId))
	}
	if m.LeadId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.LeadId))
	}
	if m.ConversationId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.ConversationId))
	}
	return i, nil
}

func (m *GetUserRoleReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserRoleReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Role != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Role))
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *GetPlanRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPlanRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *MonezationPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MonezationPlan) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.About) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.About)))
		i += copy(dAtA[i:], m.About)
	}
	if len(m.PrimaryCurrency) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.PrimaryCurrency)))
		i += copy(dAtA[i:], m.PrimaryCurrency)
	}
	if m.SubscriptionPeriod != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.SubscriptionPeriod))
	}
	if m.SubscriptionPrice != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.SubscriptionPrice))
	}
	if m.TransactionCommission != 0 {
		dAtA[i] = 0x39
		i++
		i = encodeFixed64Core(dAtA, i, uint64(math.Float64bits(float64(m.TransactionCommission))))
	}
	if m.CoinsExchangeRate != 0 {
		dAtA[i] = 0x41
		i++
		i = encodeFixed64Core(dAtA, i, uint64(math.Float64bits(float64(m.CoinsExchangeRate))))
	}
	if m.Public {
		dAtA[i] = 0x48
		i++
		if m.Public {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DirectbotEnabled {
		dAtA[i] = 0x50
		i++
		if m.DirectbotEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GetPlanReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPlanReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Plan != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Plan.Size()))
		n12, err := m.Plan.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *GetPlansListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPlansListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Currency) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Currency)))
		i += copy(dAtA[i:], m.Currency)
	}
	if m.WithBot {
		dAtA[i] = 0x10
		i++
		if m.WithBot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GetPlansListReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPlansListReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Plans) > 0 {
		for _, msg := range m.Plans {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *CoinsOffer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoinsOffer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	if m.Amount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Amount))
	}
	if m.Price != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Price))
	}
	if len(m.Currency) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Currency)))
		i += copy(dAtA[i:], m.Currency)
	}
	return i, nil
}

func (m *GetCoinsOffersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCoinsOffersRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Currency) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Currency)))
		i += copy(dAtA[i:], m.Currency)
	}
	if m.OfferId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.OfferId))
	}
	return i, nil
}

func (m *GetCoinsOffersReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCoinsOffersReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Offers) > 0 {
		for _, msg := range m.Offers {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *SubscribeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ShopId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.ShopId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	if m.PlanId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.PlanId))
	}
	if m.AutoRenewal {
		dAtA[i] = 0x20
		i++
		if m.AutoRenewal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SubscribeReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ok {
		dAtA[i] = 0x8
		i++
		if m.Ok {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *SetAutorefillRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetAutorefillRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	if m.OfferId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.OfferId))
	}
	return i, nil
}

func (m *SetAutorefillReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetAutorefillReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *GetProductRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetProductRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SearchBy != nil {
		nn13, err := m.SearchBy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn13
	}
	if m.WithDeleted {
		dAtA[i] = 0x20
		i++
		if m.WithDeleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UserId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *GetProductRequest_Id) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintCore(dAtA, i, uint64(m.Id))
	return i, nil
}
func (m *GetProductRequest_Code) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintCore(dAtA, i, uint64(len(m.Code)))
	i += copy(dAtA[i:], m.Code)
	return i, nil
}
func (m *GetProductRequest_MediaId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCore(dAtA, i, uint64(len(m.MediaId)))
	i += copy(dAtA[i:], m.MediaId)
	return i, nil
}
func (m *SearchProductRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchProductRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keyword) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if len(m.Tags) > 0 {
		dAtA15 := make([]byte, len(m.Tags)*10)
		var j14 int
		for _, num1 := range m.Tags {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(j14))
		i += copy(dAtA[i:], dAtA15[:j14])
	}
	if m.Limit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Limit))
	}
	if m.OffsetBy != nil {
		nn16, err := m.OffsetBy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn16
	}
	if m.IsSaleOnly {
		dAtA[i] = 0x30
		i++
		if m.IsSaleOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OffsetDirection {
		dAtA[i] = 0x38
		i++
		if m.OffsetDirection {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UserId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	if m.ShopId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.ShopId))
	}
	if len(m.InstagramName) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramName)))
		i += copy(dAtA[i:], m.InstagramName)
	}
	return i, nil
}

func (m *SearchProductRequest_Offset) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x20
	i++
	i = encodeVarintCore(dAtA, i, uint64(m.Offset))
	return i, nil
}
func (m *SearchProductRequest_FromId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x28
	i++
	i = encodeVarintCore(dAtA, i, uint64(m.FromId))
	return i, nil
}
func (m *ProductSearchResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductSearchResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for _, msg := range m.Result {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ProductReadResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductReadResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	if m.Deleted {
		dAtA[i] = 0x10
		i++
		if m.Deleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CreateProductRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateProductRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Product != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Product.Size()))
		n17, err := m.Product.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.MentionedBy != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.MentionedBy))
	}
	return i, nil
}

func (m *CreateProductResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateProductResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	if m.Exists {
		dAtA[i] = 0x10
		i++
		if m.Exists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	return i, nil
}

func (m *Product) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Product) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	if len(m.InstagramImageCaption) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramImageCaption)))
		i += copy(dAtA[i:], m.InstagramImageCaption)
	}
	if len(m.InstagramImageId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramImageId)))
		i += copy(dAtA[i:], m.InstagramImageId)
	}
	if len(m.InstagramImageUrl) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramImageUrl)))
		i += copy(dAtA[i:], m.InstagramImageUrl)
	}
	if len(m.InstagramLink) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramLink)))
		i += copy(dAtA[i:], m.InstagramLink)
	}
	if m.InstagramPublishedAt != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.InstagramPublishedAt))
	}
	if m.InstagramLikesCount != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.InstagramLikesCount))
	}
	if m.SupplierId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.SupplierId))
	}
	if m.Supplier != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Supplier.Size()))
		n18, err := m.Supplier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.MentionedId != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.MentionedId))
	}
	if m.Mentioned != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Mentioned.Size()))
		n19, err := m.Mentioned.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.IsSale {
		dAtA[i] = 0x70
		i++
		if m.IsSale {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x7a
			i++
			i = encodeVarintCore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.InstagramImageWidth != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.InstagramImageWidth))
	}
	if m.InstagramImageHeight != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.InstagramImageHeight))
	}
	if len(m.InstagramImages) > 0 {
		for _, msg := range m.InstagramImages {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.LikedBy) > 0 {
		for _, msg := range m.LikedBy {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.InstagramPublishedAtAgo != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.InstagramPublishedAtAgo))
	}
	return i, nil
}

func (m *ProductItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Price != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Price))
	}
	if m.DiscountPrice != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.DiscountPrice))
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintCore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ImageCandidate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageCandidate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *GetLikedByRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLikedByRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *GetLikedByReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLikedByReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProductIds) > 0 {
		dAtA21 := make([]byte, len(m.ProductIds)*10)
		var j20 int
		for _, num := range m.ProductIds {
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintCore(dAtA, i, uint64(j20))
		i += copy(dAtA[i:], dAtA21[:j20])
	}
	return i, nil
}

func (m *LikeProductRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LikeProductRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	if m.ProductId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.ProductId))
	}
	if m.Like {
		dAtA[i] = 0x18
		i++
		if m.Like {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *LikeProductReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LikeProductReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetSpecialProductsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecialProductsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SpecialProductInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecialProductInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	return i, nil
}

func (m *GetSpecialProductsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecialProductsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Err) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Err)))
		i += copy(dAtA[i:], m.Err)
	}
	return i, nil
}

func (m *GetLastProductIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLastProductIDRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ShopId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.ShopId))
	}
	return i, nil
}

func (m *GetLastProductIDReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLastProductIDReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *DelProductRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelProductRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProductId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.ProductId))
	}
	return i, nil
}

func (m *DelProductReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelProductReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *TokenInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Type))
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if len(m.About) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.About)))
		i += copy(dAtA[i:], m.About)
	}
	return i, nil
}

func (m *AddTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Token != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Token.Size()))
		n22, err := m.Token.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *DelTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TokenId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.TokenId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *ErrorResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrorResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *GetTokensRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTokensRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *GetTokensResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTokensResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tokens) > 0 {
		for _, msg := range m.Tokens {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *InvalidateTokensRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InvalidateTokensRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Type))
	}
	if len(m.Tokens) > 0 {
		for _, s := range m.Tokens {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *InvalidateTokensResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InvalidateTokensResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *UpdateTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Type))
	}
	if len(m.OldToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.OldToken)))
		i += copy(dAtA[i:], m.OldToken)
	}
	if len(m.NewToken) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.NewToken)))
		i += copy(dAtA[i:], m.NewToken)
	}
	return i, nil
}

func (m *UpdateTokenResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTokenResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ShopCard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShopCard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	if m.ShopId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.ShopId))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Number) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Number)))
		i += copy(dAtA[i:], m.Number)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *CreateCardRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateCardRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Card != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Card.Size()))
		n23, err := m.Card.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *CreateCardReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateCardReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *DeleteCardRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteCardRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *DeleteCardReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteCardReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetCardsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCardsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	if m.ShopId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.ShopId))
	}
	return i, nil
}

func (m *GetCardsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCardsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for _, msg := range m.Cards {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetCardByIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCardByIDRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *GetCardReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCardReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Card != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Card.Size()))
		n24, err := m.Card.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *Shop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Shop) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	if m.SupplierId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.SupplierId))
	}
	if m.Supplier != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Supplier.Size()))
		n25, err := m.Supplier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.InstagramId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.InstagramId))
	}
	if len(m.InstagramUsername) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramUsername)))
		i += copy(dAtA[i:], m.InstagramUsername)
	}
	if len(m.InstagramFullname) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramFullname)))
		i += copy(dAtA[i:], m.InstagramFullname)
	}
	if len(m.InstagramAvatarUrl) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramAvatarUrl)))
		i += copy(dAtA[i:], m.InstagramAvatarUrl)
	}
	if len(m.InstagramCaption) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramCaption)))
		i += copy(dAtA[i:], m.InstagramCaption)
	}
	if len(m.InstagramWebsite) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramWebsite)))
		i += copy(dAtA[i:], m.InstagramWebsite)
	}
	if len(m.PaymentRules) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.PaymentRules)))
		i += copy(dAtA[i:], m.PaymentRules)
	}
	if len(m.ShippingRules) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.ShippingRules)))
		i += copy(dAtA[i:], m.ShippingRules)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.Sellers) > 0 {
		for _, msg := range m.Sellers {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintCore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AvatarUrl) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.AvatarUrl)))
		i += copy(dAtA[i:], m.AvatarUrl)
	}
	if len(m.Slogan) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Slogan)))
		i += copy(dAtA[i:], m.Slogan)
	}
	if m.Available {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.Available {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CreatedAt != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.CreatedAt))
	}
	if m.Suspended {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.Suspended {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PlanId != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.PlanId))
	}
	if m.PlanExpiresAt != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.PlanExpiresAt))
	}
	if m.AutoRenewal {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		if m.AutoRenewal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Location) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Location)))
		i += copy(dAtA[i:], m.Location)
	}
	if len(m.WorkingTime) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.WorkingTime)))
		i += copy(dAtA[i:], m.WorkingTime)
	}
	return i, nil
}

func (m *ShopProfileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShopProfileRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SearchBy != nil {
		nn26, err := m.SearchBy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn26
	}
	return i, nil
}

func (m *ShopProfileRequest_InstagramName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramName)))
	i += copy(dAtA[i:], m.InstagramName)
	return i, nil
}
func (m *ShopProfileRequest_Id) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintCore(dAtA, i, uint64(m.Id))
	return i, nil
}
func (m *ShopProfileReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShopProfileReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Shop != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Shop.Size()))
		n27, err := m.Shop.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.ProductsCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.ProductsCount))
	}
	return i, nil
}

func (m *FindOrCreateShopForSupplierRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindOrCreateShopForSupplierRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SupplierId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.SupplierId))
	}
	if m.RecreateDeleted {
		dAtA[i] = 0x10
		i++
		if m.RecreateDeleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *FindOrCreateShopForSupplierReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindOrCreateShopForSupplierReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ShopId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.ShopId))
	}
	if m.Deleted {
		dAtA[i] = 0x10
		i++
		if m.Deleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *FindOrCreateAttachedShopRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindOrCreateAttachedShopRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SupplierId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.SupplierId))
	}
	if len(m.InstagramUsername) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramUsername)))
		i += copy(dAtA[i:], m.InstagramUsername)
	}
	return i, nil
}

func (m *FindOrCreateAttachedShopReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindOrCreateAttachedShopReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ShopId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.ShopId))
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *GetMainTagsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMainTagsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Limit))
	}
	return i, nil
}

func (m *GetRelatedTagsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRelatedTagsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		dAtA29 := make([]byte, len(m.Tags)*10)
		var j28 int
		for _, num1 := range m.Tags {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintCore(dAtA, i, uint64(j28))
		i += copy(dAtA[i:], dAtA29[:j28])
	}
	if m.Limit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Limit))
	}
	return i, nil
}

func (m *TagSearchResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagSearchResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for _, msg := range m.Result {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Tag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *CreateUserRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateUserRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.User != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.User.Size()))
		n30, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}

func (m *ReadUserRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadUserRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InstagramId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.InstagramId))
	}
	if len(m.Phone) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	if len(m.InstagramUsername) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramUsername)))
		i += copy(dAtA[i:], m.InstagramUsername)
	}
	if m.Id != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	if m.Public {
		dAtA[i] = 0x28
		i++
		if m.Public {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GetShops {
		dAtA[i] = 0x30
		i++
		if m.GetShops {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *SearchUserReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchUserReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for _, msg := range m.Result {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReadUserReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadUserReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	if m.User != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.User.Size()))
		n31, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.Phone) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	if len(m.Website) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Website)))
		i += copy(dAtA[i:], m.Website)
	}
	if m.InstagramId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.InstagramId))
	}
	if len(m.InstagramUsername) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramUsername)))
		i += copy(dAtA[i:], m.InstagramUsername)
	}
	if len(m.InstagramFullname) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramFullname)))
		i += copy(dAtA[i:], m.InstagramFullname)
	}
	if len(m.InstagramAvatarUrl) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramAvatarUrl)))
		i += copy(dAtA[i:], m.InstagramAvatarUrl)
	}
	if len(m.InstagramCaption) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.InstagramCaption)))
		i += copy(dAtA[i:], m.InstagramCaption)
	}
	if m.OptOut {
		dAtA[i] = 0x58
		i++
		if m.OptOut {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SuperSeller {
		dAtA[i] = 0x60
		i++
		if m.SuperSeller {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if m.HasEmail {
		dAtA[i] = 0x70
		i++
		if m.HasEmail {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HasPhone {
		dAtA[i] = 0x78
		i++
		if m.HasPhone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Seller {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.Seller {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.AvatarUrl) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.AvatarUrl)))
		i += copy(dAtA[i:], m.AvatarUrl)
	}
	if len(m.Slogan) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Slogan)))
		i += copy(dAtA[i:], m.Slogan)
	}
	if len(m.SupplierOf) > 0 {
		dAtA33 := make([]byte, len(m.SupplierOf)*10)
		var j32 int
		for _, num := range m.SupplierOf {
			for num >= 1<<7 {
				dAtA33[j32] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j32++
			}
			dAtA33[j32] = uint8(num)
			j32++
		}
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCore(dAtA, i, uint64(j32))
		i += copy(dAtA[i:], dAtA33[:j32])
	}
	if len(m.SellerOf) > 0 {
		dAtA35 := make([]byte, len(m.SellerOf)*10)
		var j34 int
		for _, num := range m.SellerOf {
			for num >= 1<<7 {
				dAtA35[j34] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j34++
			}
			dAtA35[j34] = uint8(num)
			j34++
		}
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCore(dAtA, i, uint64(j34))
		i += copy(dAtA[i:], dAtA35[:j34])
	}
	if m.Confirmed {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		if m.Confirmed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsFake {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		if m.IsFake {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsAdmin {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		if m.IsAdmin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Source) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	return i, nil
}

func (m *SetEmailRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetEmailRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	return i, nil
}

func (m *SetEmailReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetEmailReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *SetDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetDataRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Phone) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	return i, nil
}

func (m *SetDataReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetDataReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AddTelegramRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddTelegramRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if m.ChatId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.ChatId))
	}
	if len(m.SubsricberName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.SubsricberName)))
		i += copy(dAtA[i:], m.SubsricberName)
	}
	return i, nil
}

func (m *AddTelegramReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddTelegramReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *Telegram) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Telegram) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	if m.ChatId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.ChatId))
	}
	if len(m.SubsriberName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.SubsriberName)))
		i += copy(dAtA[i:], m.SubsriberName)
	}
	if m.Confirmed {
		dAtA[i] = 0x20
		i++
		if m.Confirmed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ListTelegramsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTelegramsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	if m.ConfirmedOnly {
		dAtA[i] = 0x10
		i++
		if m.ConfirmedOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ListTelegramsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTelegramsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Telegrams) > 0 {
		for _, msg := range m.Telegrams {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *ConfirmTelegramRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfirmTelegramRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	if m.ChatId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.ChatId))
	}
	return i, nil
}

func (m *ConfirmTelegramReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfirmTelegramReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *DelTelegramRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelTelegramRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.UserId))
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if m.ChatId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCore(dAtA, i, uint64(m.ChatId))
	}
	return i, nil
}

func (m *DelTelegramReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelTelegramReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCore(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func encodeFixed64Core(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Core(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintCore(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ReadLeadRequest) Size() (n int) {
	var l int
	_ = l
	if m.SearchBy != nil {
		n += m.SearchBy.Size()
	}
	return n
}

func (m *ReadLeadRequest_Id) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovCore(uint64(m.Id))
	return n
}
func (m *ReadLeadRequest_InstagramPk) Size() (n int) {
	var l int
	_ = l
	l = len(m.InstagramPk)
	n += 1 + l + sovCore(uint64(l))
	return n
}
func (m *ReadLeadRequest_ConversationId) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovCore(uint64(m.ConversationId))
	return n
}
func (m *ReadLeadResult) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	return n
}

func (m *Lead) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	if m.CustomerId != 0 {
		n += 1 + sovCore(uint64(m.CustomerId))
	}
	l = len(m.InstagramPk)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	if m.ProductId != 0 {
		n += 1 + sovCore(uint64(m.ProductId))
	}
	l = len(m.InstagramLink)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	if m.Action != 0 {
		n += 1 + sovCore(uint64(m.Action))
	}
	l = len(m.DirectThread)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.InstagramMediaId)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *CreateLeadResult) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	if m.Lead != nil {
		l = m.Lead.Size()
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *UserLeadsRequest) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	if len(m.Role) > 0 {
		l = 0
		for _, e := range m.Role {
			l += sovCore(uint64(e))
		}
		n += 1 + sovCore(uint64(l)) + l
	}
	if m.LeadId != 0 {
		n += 1 + sovCore(uint64(m.LeadId))
	}
	if m.Limit != 0 {
		n += 1 + sovCore(uint64(m.Limit))
	}
	if m.Direction {
		n += 2
	}
	if m.FromUpdatedAt != 0 {
		n += 1 + sovCore(uint64(m.FromUpdatedAt))
	}
	return n
}

func (m *UserLeadsReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Leads) > 0 {
		for _, e := range m.Leads {
			l = e.Size()
			n += 1 + l + sovCore(uint64(l))
		}
	}
	return n
}

func (m *LeadInfo) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	if m.CustomerId != 0 {
		n += 1 + sovCore(uint64(m.CustomerId))
	}
	if len(m.Products) > 0 {
		for _, e := range m.Products {
			l = e.Size()
			n += 1 + l + sovCore(uint64(l))
		}
	}
	l = len(m.InstagramPk)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	if m.Customer != nil {
		l = m.Customer.Size()
		n += 1 + l + sovCore(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovCore(uint64(m.Status))
	}
	if m.UserRole != 0 {
		n += 1 + sovCore(uint64(m.UserRole))
	}
	if m.ConversationId != 0 {
		n += 1 + sovCore(uint64(m.ConversationId))
	}
	if m.Shop != nil {
		l = m.Shop.Size()
		n += 1 + l + sovCore(uint64(l))
	}
	if m.UpdatedAt != 0 {
		n += 1 + sovCore(uint64(m.UpdatedAt))
	}
	l = len(m.InstagramLink)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	if m.CancelReason != 0 {
		n += 1 + sovCore(uint64(m.CancelReason))
	}
	l = len(m.StatusComment)
	if l > 0 {
		n += 2 + l + sovCore(uint64(l))
	}
	if m.UpdatedAtAgo != 0 {
		n += 2 + sovCore(uint64(m.UpdatedAtAgo))
	}
	l = len(m.InstagramMediaId)
	if l > 0 {
		n += 2 + l + sovCore(uint64(l))
	}
	return n
}

func (m *LeadEventMessage) Size() (n int) {
	var l int
	_ = l
	if m.LeadId != 0 {
		n += 1 + sovCore(uint64(m.LeadId))
	}
	l = len(m.Event)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	if len(m.Users) > 0 {
		l = 0
		for _, e := range m.Users {
			l += sovCore(uint64(e))
		}
		n += 1 + sovCore(uint64(l)) + l
	}
	return n
}

func (m *SetLeadStatusRequest) Size() (n int) {
	var l int
	_ = l
	if m.LeadId != 0 {
		n += 1 + sovCore(uint64(m.LeadId))
	}
	if m.Event != 0 {
		n += 1 + sovCore(uint64(m.Event))
	}
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	if m.CancelReason != 0 {
		n += 1 + sovCore(uint64(m.CancelReason))
	}
	l = len(m.StatusComment)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *SetLeadStatusReply) Size() (n int) {
	var l int
	_ = l
	if m.Lead != nil {
		l = m.Lead.Size()
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *CallSupplierRequest) Size() (n int) {
	var l int
	_ = l
	if m.LeadId != 0 {
		n += 1 + sovCore(uint64(m.LeadId))
	}
	return n
}

func (m *CallSupplierReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CallCustomerRequest) Size() (n int) {
	var l int
	_ = l
	if m.LeadId != 0 {
		n += 1 + sovCore(uint64(m.LeadId))
	}
	return n
}

func (m *CallCustomerReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetLeadRequest) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	if m.SearchBy != nil {
		n += m.SearchBy.Size()
	}
	return n
}

func (m *GetLeadRequest_Id) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovCore(uint64(m.Id))
	return n
}
func (m *GetLeadRequest_ConversationId) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovCore(uint64(m.ConversationId))
	return n
}
func (m *GetLeadReply) Size() (n int) {
	var l int
	_ = l
	if m.Lead != nil {
		l = m.Lead.Size()
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *GetCancelReasonsRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CancelReason) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *GetCancelReasonsReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Reasons) > 0 {
		for _, e := range m.Reasons {
			l = e.Size()
			n += 1 + l + sovCore(uint64(l))
		}
	}
	return n
}

func (m *GetUserRoleRequest) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	if m.InstagramUserId != 0 {
		n += 1 + sovCore(uint64(m.InstagramUserId))
	}
	if m.LeadId != 0 {
		n += 1 + sovCore(uint64(m.LeadId))
	}
	if m.ConversationId != 0 {
		n += 1 + sovCore(uint64(m.ConversationId))
	}
	return n
}

func (m *GetUserRoleReply) Size() (n int) {
	var l int
	_ = l
	if m.Role != 0 {
		n += 1 + sovCore(uint64(m.Role))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *GetPlanRequest) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	return n
}

func (m *MonezationPlan) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.About)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.PrimaryCurrency)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	if m.SubscriptionPeriod != 0 {
		n += 1 + sovCore(uint64(m.SubscriptionPeriod))
	}
	if m.SubscriptionPrice != 0 {
		n += 1 + sovCore(uint64(m.SubscriptionPrice))
	}
	if m.TransactionCommission != 0 {
		n += 9
	}
	if m.CoinsExchangeRate != 0 {
		n += 9
	}
	if m.Public {
		n += 2
	}
	if m.DirectbotEnabled {
		n += 2
	}
	return n
}

func (m *GetPlanReply) Size() (n int) {
	var l int
	_ = l
	if m.Plan != nil {
		l = m.Plan.Size()
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *GetPlansListRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	if m.WithBot {
		n += 2
	}
	return n
}

func (m *GetPlansListReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Plans) > 0 {
		for _, e := range m.Plans {
			l = e.Size()
			n += 1 + l + sovCore(uint64(l))
		}
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *CoinsOffer) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	if m.Amount != 0 {
		n += 1 + sovCore(uint64(m.Amount))
	}
	if m.Price != 0 {
		n += 1 + sovCore(uint64(m.Price))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *GetCoinsOffersRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	if m.OfferId != 0 {
		n += 1 + sovCore(uint64(m.OfferId))
	}
	return n
}

func (m *GetCoinsOffersReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Offers) > 0 {
		for _, e := range m.Offers {
			l = e.Size()
			n += 1 + l + sovCore(uint64(l))
		}
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *SubscribeRequest) Size() (n int) {
	var l int
	_ = l
	if m.ShopId != 0 {
		n += 1 + sovCore(uint64(m.ShopId))
	}
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	if m.PlanId != 0 {
		n += 1 + sovCore(uint64(m.PlanId))
	}
	if m.AutoRenewal {
		n += 2
	}
	return n
}

func (m *SubscribeReply) Size() (n int) {
	var l int
	_ = l
	if m.Ok {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *SetAutorefillRequest) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	if m.OfferId != 0 {
		n += 1 + sovCore(uint64(m.OfferId))
	}
	return n
}

func (m *SetAutorefillReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *GetProductRequest) Size() (n int) {
	var l int
	_ = l
	if m.SearchBy != nil {
		n += m.SearchBy.Size()
	}
	if m.WithDeleted {
		n += 2
	}
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	return n
}

func (m *GetProductRequest_Id) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovCore(uint64(m.Id))
	return n
}
func (m *GetProductRequest_Code) Size() (n int) {
	var l int
	_ = l
	l = len(m.Code)
	n += 1 + l + sovCore(uint64(l))
	return n
}
func (m *GetProductRequest_MediaId) Size() (n int) {
	var l int
	_ = l
	l = len(m.MediaId)
	n += 1 + l + sovCore(uint64(l))
	return n
}
func (m *SearchProductRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	if len(m.Tags) > 0 {
		l = 0
		for _, e := range m.Tags {
			l += sovCore(uint64(e))
		}
		n += 1 + sovCore(uint64(l)) + l
	}
	if m.Limit != 0 {
		n += 1 + sovCore(uint64(m.Limit))
	}
	if m.OffsetBy != nil {
		n += m.OffsetBy.Size()
	}
	if m.IsSaleOnly {
		n += 2
	}
	if m.OffsetDirection {
		n += 2
	}
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	if m.ShopId != 0 {
		n += 1 + sovCore(uint64(m.ShopId))
	}
	l = len(m.InstagramName)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *SearchProductRequest_Offset) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovCore(uint64(m.Offset))
	return n
}
func (m *SearchProductRequest_FromId) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovCore(uint64(m.FromId))
	return n
}
func (m *ProductSearchResult) Size() (n int) {
	var l int
	_ = l
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovCore(uint64(l))
		}
	}
	return n
}

func (m *ProductReadResult) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	if m.Deleted {
		n += 2
	}
	return n
}

func (m *CreateProductRequest) Size() (n int) {
	var l int
	_ = l
	if m.Product != nil {
		l = m.Product.Size()
		n += 1 + l + sovCore(uint64(l))
	}
	if m.MentionedBy != 0 {
		n += 1 + sovCore(uint64(m.MentionedBy))
	}
	return n
}

func (m *CreateProductResult) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	if m.Exists {
		n += 2
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *Product) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.InstagramImageCaption)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.InstagramImageId)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.InstagramImageUrl)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.InstagramLink)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	if m.InstagramPublishedAt != 0 {
		n += 1 + sovCore(uint64(m.InstagramPublishedAt))
	}
	if m.InstagramLikesCount != 0 {
		n += 1 + sovCore(uint64(m.InstagramLikesCount))
	}
	if m.SupplierId != 0 {
		n += 1 + sovCore(uint64(m.SupplierId))
	}
	if m.Supplier != nil {
		l = m.Supplier.Size()
		n += 1 + l + sovCore(uint64(l))
	}
	if m.MentionedId != 0 {
		n += 1 + sovCore(uint64(m.MentionedId))
	}
	if m.Mentioned != nil {
		l = m.Mentioned.Size()
		n += 1 + l + sovCore(uint64(l))
	}
	if m.IsSale {
		n += 2
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovCore(uint64(l))
		}
	}
	if m.InstagramImageWidth != 0 {
		n += 2 + sovCore(uint64(m.InstagramImageWidth))
	}
	if m.InstagramImageHeight != 0 {
		n += 2 + sovCore(uint64(m.InstagramImageHeight))
	}
	if len(m.InstagramImages) > 0 {
		for _, e := range m.InstagramImages {
			l = e.Size()
			n += 2 + l + sovCore(uint64(l))
		}
	}
	if len(m.LikedBy) > 0 {
		for _, e := range m.LikedBy {
			l = e.Size()
			n += 2 + l + sovCore(uint64(l))
		}
	}
	if m.InstagramPublishedAtAgo != 0 {
		n += 2 + sovCore(uint64(m.InstagramPublishedAtAgo))
	}
	return n
}

func (m *ProductItem) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	if m.Price != 0 {
		n += 1 + sovCore(uint64(m.Price))
	}
	if m.DiscountPrice != 0 {
		n += 1 + sovCore(uint64(m.DiscountPrice))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovCore(uint64(l))
		}
	}
	return n
}

func (m *ImageCandidate) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *GetLikedByRequest) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	return n
}

func (m *GetLikedByReply) Size() (n int) {
	var l int
	_ = l
	if len(m.ProductIds) > 0 {
		l = 0
		for _, e := range m.ProductIds {
			l += sovCore(uint64(e))
		}
		n += 1 + sovCore(uint64(l)) + l
	}
	return n
}

func (m *LikeProductRequest) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	if m.ProductId != 0 {
		n += 1 + sovCore(uint64(m.ProductId))
	}
	if m.Like {
		n += 2
	}
	return n
}

func (m *LikeProductReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetSpecialProductsRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SpecialProductInfo) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *GetSpecialProductsReply) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCore(uint64(l))
		}
	}
	l = len(m.Err)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *GetLastProductIDRequest) Size() (n int) {
	var l int
	_ = l
	if m.ShopId != 0 {
		n += 1 + sovCore(uint64(m.ShopId))
	}
	return n
}

func (m *GetLastProductIDReply) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	return n
}

func (m *DelProductRequest) Size() (n int) {
	var l int
	_ = l
	if m.ProductId != 0 {
		n += 1 + sovCore(uint64(m.ProductId))
	}
	return n
}

func (m *DelProductReply) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *TokenInfo) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	if m.Type != 0 {
		n += 1 + sovCore(uint64(m.Type))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.About)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *AddTokenRequest) Size() (n int) {
	var l int
	_ = l
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *DelTokenRequest) Size() (n int) {
	var l int
	_ = l
	if m.TokenId != 0 {
		n += 1 + sovCore(uint64(m.TokenId))
	}
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	return n
}

func (m *ErrorResult) Size() (n int) {
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *GetTokensRequest) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	return n
}

func (m *GetTokensResult) Size() (n int) {
	var l int
	_ = l
	if len(m.Tokens) > 0 {
		for _, e := range m.Tokens {
			l = e.Size()
			n += 1 + l + sovCore(uint64(l))
		}
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *InvalidateTokensRequest) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCore(uint64(m.Type))
	}
	if len(m.Tokens) > 0 {
		for _, s := range m.Tokens {
			l = len(s)
			n += 1 + l + sovCore(uint64(l))
		}
	}
	return n
}

func (m *InvalidateTokensResult) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *UpdateTokenRequest) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCore(uint64(m.Type))
	}
	l = len(m.OldToken)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.NewToken)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *UpdateTokenResult) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ShopCard) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	if m.ShopId != 0 {
		n += 1 + sovCore(uint64(m.ShopId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.Number)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	return n
}

func (m *CreateCardRequest) Size() (n int) {
	var l int
	_ = l
	if m.Card != nil {
		l = m.Card.Size()
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *CreateCardReply) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *DeleteCardRequest) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	return n
}

func (m *DeleteCardReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetCardsRequest) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	if m.ShopId != 0 {
		n += 1 + sovCore(uint64(m.ShopId))
	}
	return n
}

func (m *GetCardsReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for _, e := range m.Cards {
			l = e.Size()
			n += 1 + l + sovCore(uint64(l))
		}
	}
	return n
}

func (m *GetCardByIDRequest) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	return n
}

func (m *GetCardReply) Size() (n int) {
	var l int
	_ = l
	if m.Card != nil {
		l = m.Card.Size()
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *Shop) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	if m.SupplierId != 0 {
		n += 1 + sovCore(uint64(m.SupplierId))
	}
	if m.Supplier != nil {
		l = m.Supplier.Size()
		n += 1 + l + sovCore(uint64(l))
	}
	if m.InstagramId != 0 {
		n += 1 + sovCore(uint64(m.InstagramId))
	}
	l = len(m.InstagramUsername)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.InstagramFullname)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.InstagramAvatarUrl)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.InstagramCaption)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.InstagramWebsite)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.PaymentRules)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.ShippingRules)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	if len(m.Sellers) > 0 {
		for _, e := range m.Sellers {
			l = e.Size()
			n += 1 + l + sovCore(uint64(l))
		}
	}
	l = len(m.AvatarUrl)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.Slogan)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	if m.Available {
		n += 3
	}
	if m.CreatedAt != 0 {
		n += 2 + sovCore(uint64(m.CreatedAt))
	}
	if m.Suspended {
		n += 3
	}
	if m.PlanId != 0 {
		n += 2 + sovCore(uint64(m.PlanId))
	}
	if m.PlanExpiresAt != 0 {
		n += 2 + sovCore(uint64(m.PlanExpiresAt))
	}
	if m.AutoRenewal {
		n += 3
	}
	l = len(m.Location)
	if l > 0 {
		n += 2 + l + sovCore(uint64(l))
	}
	l = len(m.WorkingTime)
	if l > 0 {
		n += 2 + l + sovCore(uint64(l))
	}
	return n
}

func (m *ShopProfileRequest) Size() (n int) {
	var l int
	_ = l
	if m.SearchBy != nil {
		n += m.SearchBy.Size()
	}
	return n
}

func (m *ShopProfileRequest_InstagramName) Size() (n int) {
	var l int
	_ = l
	l = len(m.InstagramName)
	n += 1 + l + sovCore(uint64(l))
	return n
}
func (m *ShopProfileRequest_Id) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovCore(uint64(m.Id))
	return n
}
func (m *ShopProfileReply) Size() (n int) {
	var l int
	_ = l
	if m.Shop != nil {
		l = m.Shop.Size()
		n += 1 + l + sovCore(uint64(l))
	}
	if m.ProductsCount != 0 {
		n += 1 + sovCore(uint64(m.ProductsCount))
	}
	return n
}

func (m *FindOrCreateShopForSupplierRequest) Size() (n int) {
	var l int
	_ = l
	if m.SupplierId != 0 {
		n += 1 + sovCore(uint64(m.SupplierId))
	}
	if m.RecreateDeleted {
		n += 2
	}
	return n
}

func (m *FindOrCreateShopForSupplierReply) Size() (n int) {
	var l int
	_ = l
	if m.ShopId != 0 {
		n += 1 + sovCore(uint64(m.ShopId))
	}
	if m.Deleted {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *FindOrCreateAttachedShopRequest) Size() (n int) {
	var l int
	_ = l
	if m.SupplierId != 0 {
		n += 1 + sovCore(uint64(m.SupplierId))
	}
	l = len(m.InstagramUsername)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *FindOrCreateAttachedShopReply) Size() (n int) {
	var l int
	_ = l
	if m.ShopId != 0 {
		n += 1 + sovCore(uint64(m.ShopId))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *GetMainTagsRequest) Size() (n int) {
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovCore(uint64(m.Limit))
	}
	return n
}

func (m *GetRelatedTagsRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Tags) > 0 {
		l = 0
		for _, e := range m.Tags {
			l += sovCore(uint64(e))
		}
		n += 1 + sovCore(uint64(l)) + l
	}
	if m.Limit != 0 {
		n += 1 + sovCore(uint64(m.Limit))
	}
	return n
}

func (m *TagSearchResult) Size() (n int) {
	var l int
	_ = l
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovCore(uint64(l))
		}
	}
	return n
}

func (m *Tag) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *CreateUserRequest) Size() (n int) {
	var l int
	_ = l
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *ReadUserRequest) Size() (n int) {
	var l int
	_ = l
	if m.InstagramId != 0 {
		n += 1 + sovCore(uint64(m.InstagramId))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.InstagramUsername)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	if m.Public {
		n += 2
	}
	if m.GetShops {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *SearchUserReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovCore(uint64(l))
		}
	}
	return n
}

func (m *ReadUserReply) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *User) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCore(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.Website)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	if m.InstagramId != 0 {
		n += 1 + sovCore(uint64(m.InstagramId))
	}
	l = len(m.InstagramUsername)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.InstagramFullname)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.InstagramAvatarUrl)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.InstagramCaption)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	if m.OptOut {
		n += 2
	}
	if m.SuperSeller {
		n += 2
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	if m.HasEmail {
		n += 2
	}
	if m.HasPhone {
		n += 2
	}
	if m.Seller {
		n += 3
	}
	l = len(m.AvatarUrl)
	if l > 0 {
		n += 2 + l + sovCore(uint64(l))
	}
	l = len(m.Slogan)
	if l > 0 {
		n += 2 + l + sovCore(uint64(l))
	}
	if len(m.SupplierOf) > 0 {
		l = 0
		for _, e := range m.SupplierOf {
			l += sovCore(uint64(e))
		}
		n += 2 + sovCore(uint64(l)) + l
	}
	if len(m.SellerOf) > 0 {
		l = 0
		for _, e := range m.SellerOf {
			l += sovCore(uint64(e))
		}
		n += 2 + sovCore(uint64(l)) + l
	}
	if m.Confirmed {
		n += 3
	}
	if m.IsFake {
		n += 3
	}
	if m.IsAdmin {
		n += 3
	}
	l = len(m.Source)
	if l > 0 {
		n += 2 + l + sovCore(uint64(l))
	}
	return n
}

func (m *SetEmailRequest) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *SetEmailReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *SetDataRequest) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *SetDataReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AddTelegramRequest) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	if m.ChatId != 0 {
		n += 1 + sovCore(uint64(m.ChatId))
	}
	l = len(m.SubsricberName)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *AddTelegramReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *Telegram) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	if m.ChatId != 0 {
		n += 1 + sovCore(uint64(m.ChatId))
	}
	l = len(m.SubsriberName)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	if m.Confirmed {
		n += 2
	}
	return n
}

func (m *ListTelegramsRequest) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	if m.ConfirmedOnly {
		n += 2
	}
	return n
}

func (m *ListTelegramsReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Telegrams) > 0 {
		for _, e := range m.Telegrams {
			l = e.Size()
			n += 1 + l + sovCore(uint64(l))
		}
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *ConfirmTelegramRequest) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	if m.ChatId != 0 {
		n += 1 + sovCore(uint64(m.ChatId))
	}
	return n
}

func (m *ConfirmTelegramReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func (m *DelTelegramRequest) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCore(uint64(m.UserId))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	if m.ChatId != 0 {
		n += 1 + sovCore(uint64(m.ChatId))
	}
	return n
}

func (m *DelTelegramReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCore(uint64(l))
	}
	return n
}

func sovCore(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCore(x uint64) (n int) {
	return sovCore(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ReadLeadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadLeadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadLeadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SearchBy = &ReadLeadRequest_Id{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramPk", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchBy = &ReadLeadRequest_InstagramPk{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConversationId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SearchBy = &ReadLeadRequest_ConversationId{v}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadLeadResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadLeadResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadLeadResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Lead) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Lead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Lead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			m.CustomerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CustomerId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramPk", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstagramPk = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstagramLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (LeadAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectThread", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectThread = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramMediaId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstagramMediaId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateLeadResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateLeadResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateLeadResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lead", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lead == nil {
				m.Lead = &LeadInfo{}
			}
			if err := m.Lead.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserLeadsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserLeadsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserLeadsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v LeadUserRole
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCore
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (LeadUserRole(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Role = append(m.Role, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCore
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCore
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v LeadUserRole
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCore
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (LeadUserRole(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Role = append(m.Role, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeadId", wireType)
			}
			m.LeadId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeadId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Direction = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromUpdatedAt", wireType)
			}
			m.FromUpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromUpdatedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserLeadsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserLeadsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserLeadsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leads", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leads = append(m.Leads, &LeadInfo{})
			if err := m.Leads[len(m.Leads)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeadInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeadInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeadInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			m.CustomerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CustomerId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Products", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Products = append(m.Products, &Product{})
			if err := m.Products[len(m.Products)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramPk", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstagramPk = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Customer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Customer == nil {
				m.Customer = &User{}
			}
			if err := m.Customer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (LeadStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserRole", wireType)
			}
			m.UserRole = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserRole |= (LeadUserRole(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConversationId", wireType)
			}
			m.ConversationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConversationId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shop == nil {
				m.Shop = &Shop{}
			}
			if err := m.Shop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstagramLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelReason", wireType)
			}
			m.CancelReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CancelReason |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusComment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusComment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAtAgo", wireType)
			}
			m.UpdatedAtAgo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAtAgo |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramMediaId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstagramMediaId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeadEventMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeadEventMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeadEventMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeadId", wireType)
			}
			m.LeadId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeadId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Event = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCore
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Users = append(m.Users, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCore
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCore
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCore
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Users = append(m.Users, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetLeadStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetLeadStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetLeadStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeadId", wireType)
			}
			m.LeadId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeadId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			m.Event = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Event |= (LeadStatusEvent(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelReason", wireType)
			}
			m.CancelReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CancelReason |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusComment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusComment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetLeadStatusReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetLeadStatusReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetLeadStatusReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lead", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lead == nil {
				m.Lead = &LeadInfo{}
			}
			if err := m.Lead.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallSupplierRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallSupplierRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallSupplierRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeadId", wireType)
			}
			m.LeadId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeadId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallSupplierReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallSupplierReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallSupplierReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallCustomerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallCustomerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallCustomerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeadId", wireType)
			}
			m.LeadId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeadId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallCustomerReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallCustomerReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallCustomerReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLeadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLeadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLeadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SearchBy = &GetLeadRequest_Id{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConversationId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SearchBy = &GetLeadRequest_ConversationId{v}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLeadReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLeadReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLeadReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lead", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lead == nil {
				m.Lead = &LeadInfo{}
			}
			if err := m.Lead.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCancelReasonsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCancelReasonsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCancelReasonsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelReason) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelReason: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelReason: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCancelReasonsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCancelReasonsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCancelReasonsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reasons", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reasons = append(m.Reasons, &CancelReason{})
			if err := m.Reasons[len(m.Reasons)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserRoleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserRoleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserRoleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramUserId", wireType)
			}
			m.InstagramUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstagramUserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeadId", wireType)
			}
			m.LeadId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeadId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConversationId", wireType)
			}
			m.ConversationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConversationId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserRoleReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserRoleReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserRoleReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= (LeadUserRole(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPlanRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPlanRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPlanRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MonezationPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MonezationPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MonezationPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field About", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.About = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryCurrency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryCurrency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionPeriod", wireType)
			}
			m.SubscriptionPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubscriptionPeriod |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionPrice", wireType)
			}
			m.SubscriptionPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubscriptionPrice |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionCommission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.TransactionCommission = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinsExchangeRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.CoinsExchangeRate = float64(math.Float64frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Public", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Public = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectbotEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DirectbotEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPlanReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPlanReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPlanReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Plan == nil {
				m.Plan = &MonezationPlan{}
			}
			if err := m.Plan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPlansListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPlansListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPlansListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithBot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithBot = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPlansListReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPlansListReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPlansListReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plans = append(m.Plans, &MonezationPlan{})
			if err := m.Plans[len(m.Plans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoinsOffer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoinsOffer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoinsOffer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCoinsOffersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCoinsOffersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCoinsOffersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfferId", wireType)
			}
			m.OfferId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OfferId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCoinsOffersReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCoinsOffersReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCoinsOffersReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Offers = append(m.Offers, &CoinsOffer{})
			if err := m.Offers[len(m.Offers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopId", wireType)
			}
			m.ShopId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanId", wireType)
			}
			m.PlanId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlanId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoRenewal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoRenewal = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetAutorefillRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetAutorefillRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetAutorefillRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfferId", wireType)
			}
			m.OfferId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OfferId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetAutorefillReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetAutorefillReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetAutorefillReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetProductRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetProductRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetProductRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SearchBy = &GetProductRequest_Id{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchBy = &GetProductRequest_Code{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchBy = &GetProductRequest_MediaId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithDeleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithDeleted = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchProductRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchProductRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchProductRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCore
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Tags = append(m.Tags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCore
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCore
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCore
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Tags = append(m.Tags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OffsetBy = &SearchProductRequest_Offset{v}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OffsetBy = &SearchProductRequest_FromId{v}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSaleOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSaleOnly = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetDirection", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OffsetDirection = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopId", wireType)
			}
			m.ShopId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstagramName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductSearchResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductSearchResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductSearchResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &Product{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductReadResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductReadResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductReadResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deleted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateProductRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateProductRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateProductRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Product == nil {
				m.Product = &Product{}
			}
			if err := m.Product.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MentionedBy", wireType)
			}
			m.MentionedBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MentionedBy |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateProductResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateProductResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateProductResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exists = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Product) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Product: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Product: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramImageCaption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstagramImageCaption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramImageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstagramImageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramImageUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstagramImageUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstagramLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramPublishedAt", wireType)
			}
			m.InstagramPublishedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstagramPublishedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramLikesCount", wireType)
			}
			m.InstagramLikesCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstagramLikesCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplierId", wireType)
			}
			m.SupplierId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SupplierId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Supplier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Supplier == nil {
				m.Supplier = &Shop{}
			}
			if err := m.Supplier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MentionedId", wireType)
			}
			m.MentionedId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MentionedId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mentioned", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mentioned == nil {
				m.Mentioned = &User{}
			}
			if err := m.Mentioned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSale", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSale = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ProductItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramImageWidth", wireType)
			}
			m.InstagramImageWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstagramImageWidth |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramImageHeight", wireType)
			}
			m.InstagramImageHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstagramImageHeight |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramImages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstagramImages = append(m.InstagramImages, &ImageCandidate{})
			if err := m.InstagramImages[len(m.InstagramImages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LikedBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LikedBy = append(m.LikedBy, &User{})
			if err := m.LikedBy[len(m.LikedBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramPublishedAtAgo", wireType)
			}
			m.InstagramPublishedAtAgo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstagramPublishedAtAgo |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscountPrice", wireType)
			}
			m.DiscountPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscountPrice |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageCandidate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageCandidate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageCandidate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLikedByRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLikedByRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLikedByRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLikedByReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLikedByReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLikedByReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCore
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ProductIds = append(m.ProductIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCore
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCore
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCore
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ProductIds = append(m.ProductIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LikeProductRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LikeProductRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LikeProductRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Like", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Like = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LikeProductReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LikeProductReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LikeProductReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecialProductsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecialProductsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecialProductsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpecialProductInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecialProductInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecialProductInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecialProductsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecialProductsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecialProductsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &SpecialProductInfo{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Err = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLastProductIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLastProductIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLastProductIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopId", wireType)
			}
			m.ShopId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLastProductIDReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLastProductIDReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLastProductIDReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelProductRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelProductRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelProductRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelProductReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelProductReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelProductReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (TokenType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field About", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.About = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &TokenInfo{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenId", wireType)
			}
			m.TokenId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TokenId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ErrorResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrorResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrorResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTokensRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTokensRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTokensRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTokensResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTokensResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTokensResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tokens = append(m.Tokens, &TokenInfo{})
			if err := m.Tokens[len(m.Tokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InvalidateTokensRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InvalidateTokensRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InvalidateTokensRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (TokenType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokens", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tokens = append(m.Tokens, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InvalidateTokensResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InvalidateTokensResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InvalidateTokensResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (TokenType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTokenResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTokenResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTokenResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShopCard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShopCard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShopCard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopId", wireType)
			}
			m.ShopId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Number = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateCardRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateCardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateCardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Card == nil {
				m.Card = &ShopCard{}
			}
			if err := m.Card.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateCardReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateCardReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateCardReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteCardRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteCardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteCardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteCardReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteCardReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteCardReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCardsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCardsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCardsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopId", wireType)
			}
			m.ShopId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCardsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCardsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCardsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cards = append(m.Cards, &ShopCard{})
			if err := m.Cards[len(m.Cards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCardByIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCardByIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCardByIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCardReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCardReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCardReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Card == nil {
				m.Card = &ShopCard{}
			}
			if err := m.Card.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Shop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Shop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Shop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplierId", wireType)
			}
			m.SupplierId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SupplierId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Supplier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Supplier == nil {
				m.Supplier = &User{}
			}
			if err := m.Supplier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramId", wireType)
			}
			m.InstagramId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstagramId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstagramUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramFullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstagramFullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramAvatarUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstagramAvatarUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramCaption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstagramCaption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramWebsite", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstagramWebsite = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentRules", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentRules = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShippingRules", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShippingRules = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sellers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sellers = append(m.Sellers, &User{})
			if err := m.Sellers[len(m.Sellers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvatarUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvatarUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slogan", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Slogan = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Available", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Available = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suspended", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Suspended = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanId", wireType)
			}
			m.PlanId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlanId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanExpiresAt", wireType)
			}
			m.PlanExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlanExpiresAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoRenewal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoRenewal = bool(v != 0)
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkingTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShopProfileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShopProfileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShopProfileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchBy = &ShopProfileRequest_InstagramName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SearchBy = &ShopProfileRequest_Id{v}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShopProfileReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShopProfileReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShopProfileReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shop == nil {
				m.Shop = &Shop{}
			}
			if err := m.Shop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductsCount", wireType)
			}
			m.ProductsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductsCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindOrCreateShopForSupplierRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindOrCreateShopForSupplierRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindOrCreateShopForSupplierRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplierId", wireType)
			}
			m.SupplierId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SupplierId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecreateDeleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RecreateDeleted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindOrCreateShopForSupplierReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindOrCreateShopForSupplierReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindOrCreateShopForSupplierReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopId", wireType)
			}
			m.ShopId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deleted = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindOrCreateAttachedShopRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindOrCreateAttachedShopRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindOrCreateAttachedShopRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplierId", wireType)
			}
			m.SupplierId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SupplierId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstagramUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindOrCreateAttachedShopReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindOrCreateAttachedShopReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindOrCreateAttachedShopReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopId", wireType)
			}
			m.ShopId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMainTagsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMainTagsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMainTagsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRelatedTagsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRelatedTagsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRelatedTagsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCore
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Tags = append(m.Tags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCore
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCore
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCore
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Tags = append(m.Tags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagSearchResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagSearchResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagSearchResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &Tag{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateUserRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateUserRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateUserRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadUserRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadUserRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadUserRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramId", wireType)
			}
			m.InstagramId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstagramId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstagramUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Public", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Public = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetShops", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GetShops = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchUserReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchUserReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchUserReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &User{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadUserReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadUserReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadUserReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Website", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Website = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramId", wireType)
			}
			m.InstagramId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstagramId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstagramUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramFullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstagramFullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramAvatarUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstagramAvatarUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstagramCaption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstagramCaption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptOut", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptOut = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuperSeller", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SuperSeller = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasEmail", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasEmail = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasPhone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasPhone = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seller", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Seller = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvatarUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvatarUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slogan", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Slogan = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCore
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SupplierOf = append(m.SupplierOf, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCore
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCore
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCore
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SupplierOf = append(m.SupplierOf, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplierOf", wireType)
			}
		case 20:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCore
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SellerOf = append(m.SellerOf, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCore
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCore
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCore
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SellerOf = append(m.SellerOf, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SellerOf", wireType)
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Confirmed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Confirmed = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFake", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFake = bool(v != 0)
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAdmin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAdmin = bool(v != 0)
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetEmailRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetEmailRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetEmailRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetEmailReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetEmailReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetEmailReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetDataReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetDataReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetDataReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddTelegramRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddTelegramRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddTelegramRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubsricberName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubsricberName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddTelegramReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddTelegramReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddTelegramReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Telegram) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Telegram: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Telegram: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubsriberName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubsriberName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Confirmed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Confirmed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTelegramsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTelegramsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTelegramsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfirmedOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConfirmedOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTelegramsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTelegramsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTelegramsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Telegrams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Telegrams = append(m.Telegrams, &Telegram{})
			if err := m.Telegrams[len(m.Telegrams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfirmTelegramRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfirmTelegramRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfirmTelegramRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfirmTelegramReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfirmTelegramReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfirmTelegramReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelTelegramRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelTelegramRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelTelegramRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelTelegramReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelTelegramReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelTelegramReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCore(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCore
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCore
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCore
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCore
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCore
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCore(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCore = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCore   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("core.proto", fileDescriptorCore) }

var fileDescriptorCore = []byte{
	// 4712 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x7b, 0xcd, 0x6f, 0x23, 0x47,
	0x76, 0x38, 0x9b, 0xa4, 0xc4, 0xe6, 0xa3, 0xf8, 0xa1, 0x92, 0x46, 0xe2, 0x70, 0xec, 0xf1, 0x6c,
	0x8f, 0xc7, 0xa3, 0x19, 0xfb, 0xe7, 0xfd, 0x41, 0xbb, 0x76, 0x9c, 0xac, 0xbd, 0x6b, 0x7d, 0x70,
	0x66, 0xb8, 0xab, 0xaf, 0x6d, 0x49, 0x9e, 0x18, 0x08, 0xc0, 0xb4, 0xd8, 0x25, 0xa9, 0xa1, 0x26,
	0x9b, 0xee, 0x6e, 0xce, 0x58, 0x39, 0xed, 0x1e, 0x72, 0x49, 0x10, 0x20, 0xa7, 0x00, 0x41, 0x4e,
	0xf9, 0x03, 0x02, 0xe4, 0x5f, 0xc8, 0x25, 0xd8, 0x5b, 0x16, 0xb9, 0x24, 0x87, 0x04, 0x08, 0x9c,
	0x5c, 0xf3, 0x3f, 0x04, 0xf5, 0xaa, 0xaa, 0xbb, 0xaa, 0x9b, 0x2d, 0xc9, 0x8b, 0xe4, 0xc6, 0x7a,
	0xaf, 0xfa, 0x55, 0xd5, 0x7b, 0xaf, 0xea, 0x7d, 0x12, 0x60, 0x14, 0x84, 0xf4, 0xe3, 0x69, 0x18,
	0xc4, 0x01, 0xa9, 0xb2, 0xdf, 0xd6, 0xaf, 0x0c, 0x68, 0xdb, 0xd4, 0x71, 0xf7, 0xa8, 0xe3, 0xda,
	0xf4, 0x9b, 0x19, 0x8d, 0x62, 0xd2, 0x81, 0xb2, 0xe7, 0x76, 0x8d, 0x47, 0xc6, 0x46, 0xe5, 0x55,
	0xc9, 0x2e, 0x7b, 0x2e, 0x79, 0x0c, 0x4b, 0xde, 0x24, 0x8a, 0x9d, 0x8b, 0xd0, 0x19, 0x0f, 0xa7,
	0x57, 0xdd, 0xf2, 0x23, 0x63, 0xa3, 0xfe, 0xaa, 0x64, 0x37, 0x12, 0xe8, 0xd1, 0x15, 0x79, 0x06,
	0xed, 0x51, 0x30, 0x79, 0x43, 0xc3, 0xc8, 0x89, 0xbd, 0x60, 0x32, 0xf4, 0xdc, 0x6e, 0xe5, 0x91,
	0xb1, 0x51, 0x7d, 0x55, 0xb2, 0x5b, 0x2a, 0x62, 0xe0, 0x6e, 0x37, 0xa0, 0x1e, 0x51, 0x27, 0x1c,
	0x5d, 0x0e, 0xcf, 0xae, 0xad, 0x47, 0xd0, 0x4a, 0x77, 0x10, 0xcd, 0xfc, 0x98, 0xb4, 0xd2, 0x0d,
	0xb0, 0xe5, 0xad, 0x7f, 0x2a, 0x43, 0x95, 0xa1, 0xb3, 0x08, 0xb2, 0x06, 0x8b, 0x51, 0x30, 0x0b,
	0x47, 0x94, 0xef, 0xc8, 0x16, 0x23, 0xd2, 0x85, 0xda, 0x28, 0x18, 0x8f, 0xe9, 0x24, 0xc6, 0x2d,
	0xd4, 0x6d, 0x39, 0x24, 0xef, 0x41, 0x63, 0x34, 0x8b, 0xe2, 0x60, 0x4c, 0x43, 0xb6, 0xc1, 0x2a,
	0x92, 0x02, 0x09, 0x1a, 0xb8, 0xe4, 0x07, 0x99, 0xa3, 0x2e, 0xe0, 0xf7, 0xda, 0x41, 0xdf, 0x05,
	0x98, 0x86, 0x81, 0x3b, 0x1b, 0xc5, 0x8c, 0xc4, 0x22, 0x92, 0xa8, 0x0b, 0xc8, 0xc0, 0x25, 0x4f,
	0xa0, 0x95, 0x52, 0xf0, 0xbd, 0xc9, 0x55, 0xb7, 0x86, 0x34, 0x9a, 0x09, 0x74, 0xcf, 0x9b, 0x5c,
	0x91, 0x0d, 0x58, 0x74, 0x46, 0x8c, 0x1f, 0x5d, 0xf3, 0x91, 0xb1, 0xd1, 0xda, 0xec, 0x7c, 0x8c,
	0xc2, 0x61, 0xe7, 0xdc, 0x42, 0xb8, 0x2d, 0xf0, 0xe4, 0x31, 0x34, 0x5d, 0x2f, 0xa4, 0xa3, 0x78,
	0x18, 0x5f, 0x86, 0xd4, 0x71, 0xbb, 0x75, 0xa4, 0xb7, 0xc4, 0x81, 0x27, 0x08, 0x23, 0x1f, 0x01,
	0x49, 0x57, 0x1d, 0x53, 0xd7, 0x73, 0xd8, 0xe6, 0x00, 0x67, 0x76, 0x12, 0xcc, 0x3e, 0x43, 0x0c,
	0x5c, 0xeb, 0x05, 0x74, 0x76, 0x42, 0xea, 0xc4, 0xb4, 0x98, 0xeb, 0xc4, 0x82, 0xaa, 0xcf, 0x56,
	0x63, 0xac, 0x6d, 0x6c, 0xb6, 0xd2, 0xed, 0x0d, 0x26, 0xe7, 0x81, 0x8d, 0x38, 0xeb, 0x37, 0x06,
	0x74, 0x4e, 0x23, 0x1a, 0x32, 0x70, 0x24, 0xf5, 0x67, 0x1d, 0x6a, 0xb3, 0x88, 0xf3, 0x97, 0x51,
	0xab, 0xda, 0x8b, 0x6c, 0x38, 0x70, 0xc9, 0x07, 0x50, 0x0d, 0x03, 0x9f, 0x09, 0xab, 0xb2, 0xd1,
	0xda, 0x24, 0x29, 0x45, 0x46, 0xc2, 0x0e, 0x7c, 0x6a, 0x23, 0x9e, 0x11, 0x60, 0xd4, 0x13, 0x0d,
	0xb2, 0x17, 0xd9, 0x70, 0xe0, 0x92, 0x55, 0x58, 0xf0, 0xbd, 0xb1, 0x17, 0xa3, 0xdc, 0xaa, 0x36,
	0x1f, 0x90, 0x77, 0xa0, 0xce, 0x59, 0xc1, 0x98, 0xc9, 0xe4, 0x65, 0xda, 0x29, 0x80, 0x7c, 0x00,
	0xed, 0xf3, 0x30, 0x18, 0x0f, 0x67, 0x53, 0xd7, 0x89, 0xa9, 0x3b, 0x74, 0x62, 0x21, 0xb2, 0x26,
	0x03, 0x9f, 0x72, 0xe8, 0x56, 0x6c, 0x7d, 0x0a, 0x2d, 0xe5, 0x24, 0x53, 0xff, 0x9a, 0xbc, 0x0f,
	0x0b, 0x6c, 0xdd, 0xa8, 0x6b, 0x3c, 0xaa, 0xcc, 0xe1, 0x00, 0x47, 0x5a, 0xff, 0x5d, 0x05, 0x53,
	0xc2, 0x14, 0x1e, 0x56, 0xff, 0xf7, 0x14, 0xb4, 0xaa, 0x29, 0xe8, 0x33, 0x30, 0x85, 0xae, 0x45,
	0xdd, 0x05, 0xdc, 0x58, 0x93, 0x6f, 0xec, 0x88, 0x43, 0xed, 0x04, 0x9d, 0xd3, 0xe5, 0x5a, 0x5e,
	0x97, 0x3f, 0x00, 0x53, 0xd2, 0x46, 0x3d, 0x6c, 0x6c, 0x02, 0xa7, 0x86, 0x22, 0x49, 0x70, 0x4c,
	0x5b, 0xa3, 0xd8, 0x89, 0x67, 0x11, 0x2a, 0x9f, 0xa6, 0xad, 0xc7, 0x08, 0xb7, 0x05, 0x9e, 0xfc,
	0x10, 0xea, 0x28, 0x7d, 0x94, 0x34, 0xe0, 0xe4, 0x79, 0x92, 0x36, 0x67, 0xe2, 0x17, 0x79, 0x9a,
	0x7f, 0x37, 0x1a, 0x78, 0xea, 0xcc, 0xab, 0x41, 0x1e, 0x42, 0x35, 0xba, 0x0c, 0xa6, 0xdd, 0x25,
	0x75, 0x9f, 0xc7, 0x97, 0xc1, 0xd4, 0x46, 0x38, 0xbb, 0x97, 0x8a, 0x90, 0x9b, 0xfc, 0x5e, 0xce,
	0xa4, 0x80, 0xe7, 0xdc, 0xcb, 0xd6, 0xbc, 0x7b, 0xf9, 0x18, 0x9a, 0x23, 0x67, 0x32, 0xa2, 0xfe,
	0x30, 0xa4, 0x4e, 0x14, 0x4c, 0xba, 0x6d, 0xdc, 0xcc, 0x12, 0x07, 0xda, 0x08, 0x63, 0xb4, 0xf8,
	0x71, 0x87, 0x52, 0x8c, 0x1d, 0x4e, 0x8b, 0x43, 0x77, 0x84, 0x30, 0xdf, 0x87, 0x56, 0xba, 0xa3,
	0xa1, 0x73, 0x11, 0x74, 0x97, 0x71, 0x57, 0x4b, 0xc9, 0xae, 0xb6, 0x2e, 0x82, 0x82, 0xab, 0x4b,
	0x0a, 0xae, 0xee, 0x6b, 0xe8, 0x30, 0x46, 0xf6, 0xdf, 0xd0, 0x49, 0xbc, 0x4f, 0xa3, 0xc8, 0xb9,
	0xd0, 0x2e, 0x8c, 0x91, 0xbd, 0x30, 0x94, 0x4d, 0x14, 0xea, 0xc7, 0x07, 0x0c, 0xca, 0xb8, 0x1f,
	0x75, 0x2b, 0x8f, 0x2a, 0xec, 0x1a, 0xe1, 0xc0, 0xfa, 0x07, 0x03, 0x56, 0x8f, 0x69, 0xac, 0x88,
	0x34, 0xbd, 0xcf, 0xf3, 0xa9, 0x7f, 0xa8, 0x52, 0x6f, 0x6d, 0xde, 0xcb, 0xea, 0x04, 0xee, 0x51,
	0x2e, 0xaa, 0xbc, 0x0a, 0x15, 0xed, 0x55, 0xc8, 0x31, 0xbc, 0x7a, 0x27, 0x86, 0x2f, 0xcc, 0x61,
	0xb8, 0xf5, 0x19, 0x90, 0xcc, 0x11, 0xd8, 0x45, 0x96, 0x2f, 0x99, 0x71, 0xc3, 0x4b, 0xf6, 0x31,
	0xac, 0xec, 0x38, 0xbe, 0x7f, 0x3c, 0x9b, 0x4e, 0x7d, 0x8f, 0x86, 0xb7, 0x9d, 0xdd, 0x5a, 0x81,
	0x65, 0x7d, 0xfe, 0xd4, 0xbf, 0x96, 0x44, 0x76, 0xc4, 0xad, 0xb9, 0x2b, 0x91, 0x74, 0x3e, 0x23,
	0x12, 0x41, 0xeb, 0x25, 0x3f, 0xc3, 0xad, 0x0f, 0x2a, 0xb7, 0xd4, 0x65, 0x61, 0x65, 0xd9, 0x83,
	0xf3, 0xbb, 0x1a, 0xe1, 0x4d, 0x58, 0x4a, 0x16, 0xbd, 0x2b, 0xcb, 0xee, 0xc3, 0xfa, 0x4b, 0x1a,
	0xef, 0x28, 0x62, 0x92, 0x2a, 0xc3, 0xc8, 0xa9, 0xf0, 0xdc, 0xbb, 0x48, 0xa0, 0x3a, 0x71, 0xc6,
	0xf2, 0x55, 0xc4, 0xdf, 0x56, 0x1f, 0xee, 0xe5, 0xc9, 0xb1, 0xbd, 0x7c, 0x04, 0x35, 0xae, 0x19,
	0xf2, 0x25, 0x16, 0xef, 0x89, 0x3a, 0xd5, 0x96, 0x53, 0xac, 0xbf, 0x31, 0x80, 0xbc, 0xa4, 0x71,
	0xf2, 0xd0, 0xdc, 0xc6, 0xc3, 0xe7, 0xb0, 0x9c, 0xde, 0x3e, 0x39, 0x05, 0x59, 0x6a, 0xb7, 0x13,
	0xc4, 0x29, 0x9f, 0xab, 0x08, 0x72, 0x41, 0xbb, 0x09, 0x73, 0xde, 0xb0, 0xc5, 0x79, 0x6f, 0x98,
	0x75, 0x04, 0x1d, 0x6d, 0x73, 0xec, 0x7c, 0xd2, 0x2c, 0x1a, 0x85, 0x8f, 0x25, 0x37, 0x8b, 0xec,
	0x32, 0x87, 0x61, 0x10, 0x26, 0x97, 0x99, 0x0d, 0x98, 0xfb, 0xf4, 0x92, 0xc6, 0x47, 0xbe, 0x33,
	0x91, 0x47, 0xcd, 0x30, 0xdb, 0xfa, 0x75, 0x05, 0x5a, 0xfb, 0xc1, 0x84, 0xfe, 0x09, 0x6e, 0x82,
	0xcd, 0xbc, 0x8b, 0x3c, 0xd8, 0x72, 0xce, 0x59, 0x30, 0x93, 0x16, 0x8a, 0x0f, 0xc8, 0x33, 0xe8,
	0x4c, 0x43, 0x6f, 0xec, 0x84, 0xd7, 0xc3, 0xd1, 0x2c, 0x0c, 0xe9, 0x64, 0x74, 0x8d, 0x17, 0xb6,
	0x6e, 0xb7, 0x05, 0x7c, 0x47, 0x80, 0xc9, 0x0f, 0x61, 0x25, 0x9a, 0x9d, 0x45, 0xa3, 0xd0, 0x9b,
	0x22, 0x53, 0xa6, 0x34, 0xf4, 0x02, 0xc9, 0x39, 0xa2, 0xa2, 0x8e, 0x10, 0x43, 0xfe, 0x1f, 0x10,
	0xfd, 0x83, 0xd0, 0x1b, 0x51, 0xc1, 0xc8, 0x65, 0x6d, 0x3e, 0x43, 0x90, 0x4f, 0x60, 0x2d, 0x0e,
	0x9d, 0x49, 0xc4, 0xdd, 0x24, 0x7c, 0x18, 0xbc, 0x28, 0x62, 0x4e, 0x00, 0x33, 0x74, 0x86, 0x7d,
	0x4f, 0xc1, 0xee, 0x24, 0x48, 0xf2, 0x31, 0xac, 0x8c, 0x02, 0x6f, 0x12, 0x0d, 0xe9, 0xb7, 0xa3,
	0x4b, 0x67, 0x72, 0x41, 0x87, 0xa1, 0x13, 0x53, 0xb4, 0x7e, 0x86, 0xbd, 0x8c, 0xa8, 0xbe, 0xc0,
	0xd8, 0x4e, 0x4c, 0x99, 0x0d, 0x9f, 0xce, 0xce, 0x7c, 0x6f, 0x84, 0xa6, 0xcf, 0xb4, 0xc5, 0x88,
	0x7c, 0x08, 0xcb, 0xdc, 0xcb, 0x38, 0x0b, 0xe2, 0x21, 0x9d, 0x38, 0x67, 0x3e, 0xe5, 0x0e, 0x97,
	0x69, 0x77, 0x12, 0x44, 0x9f, 0xc3, 0xad, 0x03, 0xbc, 0x5f, 0x5c, 0x4a, 0x4c, 0xe6, 0x1b, 0x50,
	0x9d, 0xfa, 0xce, 0x44, 0xdc, 0xaf, 0x55, 0x2e, 0x73, 0x5d, 0x48, 0x36, 0xce, 0x28, 0x90, 0xfa,
	0x1e, 0xac, 0x08, 0x7a, 0xd1, 0x9e, 0x17, 0xc5, 0x52, 0xf4, 0x3d, 0x66, 0xce, 0x85, 0x54, 0x0c,
	0x9c, 0x9f, 0x8c, 0xc9, 0x7d, 0x30, 0xdf, 0x7a, 0xf1, 0xe5, 0xf0, 0x2c, 0xe0, 0x0f, 0xb6, 0x69,
	0xd7, 0xd8, 0x78, 0x3b, 0x88, 0xad, 0x53, 0x58, 0xd6, 0xa9, 0xb1, 0x2d, 0x3e, 0x87, 0x05, 0xb6,
	0x01, 0x79, 0xe9, 0xe6, 0xef, 0x91, 0x4f, 0x29, 0xd8, 0xe4, 0x39, 0xc0, 0x0e, 0x63, 0xe7, 0xe1,
	0xf9, 0x39, 0x0d, 0xe7, 0xf9, 0x46, 0xce, 0x38, 0x98, 0x09, 0xf3, 0x51, 0xb5, 0xc5, 0x88, 0xd1,
	0xe2, 0x82, 0xe7, 0x66, 0x82, 0x0f, 0xb4, 0x93, 0x55, 0xf5, 0x93, 0x59, 0x07, 0xfc, 0xe5, 0x48,
	0x96, 0x8a, 0xee, 0xc8, 0x8e, 0x80, 0x4d, 0x4e, 0xaf, 0x7b, 0x0d, 0xc7, 0x03, 0xd7, 0x3a, 0x45,
	0xe6, 0x6a, 0xf4, 0xb8, 0xcc, 0x16, 0x71, 0x86, 0xe4, 0x88, 0xf0, 0x81, 0xd2, 0x79, 0xb6, 0xc0,
	0x17, 0xb0, 0xe3, 0x57, 0x06, 0x74, 0x8e, 0xb9, 0x16, 0x9f, 0xa9, 0xef, 0x12, 0x73, 0x5e, 0x94,
	0x77, 0x89, 0x0d, 0xf9, 0x5b, 0xa3, 0xbf, 0x46, 0xf2, 0xc1, 0x5a, 0x87, 0x1a, 0x63, 0xba, 0x62,
	0x48, 0xd9, 0x90, 0x87, 0x2e, 0xce, 0x2c, 0x0e, 0x86, 0x21, 0x9d, 0xd0, 0xb7, 0x8e, 0x8f, 0x6c,
	0x32, 0xed, 0x06, 0x83, 0xd9, 0x1c, 0xc4, 0x9c, 0x5c, 0x65, 0x07, 0xec, 0x50, 0x2d, 0x28, 0x07,
	0x57, 0xb8, 0xb4, 0x69, 0x97, 0x83, 0xab, 0x82, 0xad, 0xff, 0x1c, 0x5d, 0x83, 0xad, 0x59, 0x1c,
	0x84, 0xf4, 0xdc, 0xf3, 0xfd, 0x5b, 0x5f, 0xd5, 0x1b, 0xb8, 0xfb, 0x1c, 0x6d, 0xb4, 0x4a, 0x8b,
	0xed, 0x23, 0x59, 0xd7, 0x50, 0xd7, 0xfd, 0x5b, 0x83, 0x6b, 0xa6, 0x70, 0x6d, 0x0b, 0x03, 0xd4,
	0x55, 0xa8, 0x8e, 0x02, 0x97, 0x26, 0x81, 0x29, 0x8e, 0xc8, 0x03, 0x30, 0x13, 0x77, 0xaa, 0x22,
	0x30, 0xb5, 0x31, 0xf7, 0xa3, 0x18, 0xb7, 0xf0, 0x3a, 0xb8, 0xd4, 0xa7, 0x31, 0x75, 0x25, 0xb7,
	0x18, 0x6c, 0x97, 0x83, 0xd4, 0xd3, 0x2d, 0xa8, 0xa7, 0xd3, 0x4d, 0xe7, 0x3f, 0x96, 0x19, 0x73,
	0xd8, 0x28, 0xb3, 0xcd, 0x2e, 0xd4, 0xae, 0xe8, 0xf5, 0xdb, 0x20, 0x74, 0xc5, 0xa1, 0xe4, 0x90,
	0xac, 0x41, 0x35, 0x76, 0x2e, 0x22, 0x0c, 0x84, 0x2a, 0xdb, 0xe5, 0x8e, 0x61, 0xe3, 0x38, 0x8d,
	0x6f, 0x2a, 0xe8, 0x26, 0x8a, 0xf8, 0xa6, 0x8b, 0x7a, 0x17, 0x51, 0x1e, 0xf6, 0xb0, 0x23, 0x8b,
	0x31, 0xb9, 0x0f, 0x35, 0x8c, 0x6d, 0xe4, 0x06, 0x19, 0x8a, 0x01, 0x06, 0x2e, 0x79, 0x04, 0x4b,
	0x5e, 0x34, 0x8c, 0x1c, 0x9f, 0x0e, 0x83, 0x89, 0x7f, 0x8d, 0xaf, 0xa8, 0x69, 0x83, 0x17, 0x1d,
	0x3b, 0x3e, 0x3d, 0x9c, 0xf8, 0xd7, 0xec, 0x25, 0xe7, 0x64, 0x86, 0x69, 0xf4, 0x54, 0xc3, 0x59,
	0x6d, 0x0e, 0xdf, 0x4d, 0x62, 0x28, 0x85, 0x11, 0x66, 0x56, 0x17, 0xa5, 0xf6, 0xd6, 0x35, 0xed,
	0xd5, 0x9c, 0x6d, 0x34, 0x2d, 0x90, 0x71, 0xb6, 0x0f, 0x9c, 0x31, 0x65, 0x8c, 0x14, 0x7b, 0x38,
	0xbb, 0xb6, 0x3e, 0x87, 0x15, 0xc1, 0x41, 0xce, 0x4e, 0x11, 0x97, 0x3e, 0x81, 0xc5, 0x10, 0x7f,
	0x89, 0x6b, 0x97, 0x09, 0x77, 0x04, 0xd2, 0xfa, 0x02, 0x96, 0x13, 0xfe, 0x17, 0xc6, 0xb4, 0x5d,
	0xa8, 0x49, 0x79, 0x8b, 0x27, 0x50, 0x0c, 0xad, 0x33, 0x58, 0xe5, 0x11, 0x71, 0x46, 0x88, 0x4f,
	0xa1, 0x26, 0xe2, 0x29, 0xf1, 0x56, 0x67, 0x96, 0x97, 0x58, 0xa6, 0x4f, 0xcc, 0x05, 0xf5, 0x82,
	0x09, 0x75, 0x87, 0x67, 0xd7, 0x42, 0xeb, 0x1b, 0x09, 0x6c, 0xfb, 0xda, 0xfa, 0x25, 0xac, 0x64,
	0xd6, 0x98, 0xbb, 0xc9, 0x35, 0x58, 0xa4, 0xdf, 0x7a, 0x51, 0x1c, 0x89, 0x3d, 0x8a, 0x11, 0x33,
	0xd2, 0xa8, 0xe4, 0xdc, 0x1e, 0xe3, 0x6f, 0xeb, 0xb7, 0x8b, 0x50, 0x13, 0xd4, 0x72, 0x74, 0x56,
	0x61, 0x21, 0xf6, 0x62, 0x5f, 0x5a, 0x75, 0x3e, 0x98, 0x47, 0x85, 0x7c, 0x0a, 0xeb, 0xa9, 0xb4,
	0xbc, 0xb1, 0x73, 0x41, 0x87, 0x23, 0x07, 0x2d, 0xad, 0x78, 0x6b, 0xef, 0x25, 0xe8, 0x01, 0xc3,
	0xee, 0x70, 0xa4, 0x1e, 0xb9, 0xf0, 0xef, 0x84, 0x2a, 0xaa, 0x91, 0x0b, 0x7e, 0x32, 0x70, 0x99,
	0xe1, 0xcd, 0xce, 0x9e, 0x85, 0x3e, 0x6a, 0x66, 0xdd, 0x5e, 0xd6, 0xa7, 0x9f, 0x86, 0xfe, 0x5d,
	0x13, 0x29, 0x3f, 0x86, 0x35, 0x25, 0xca, 0x65, 0xb6, 0x39, 0xba, 0xe4, 0x21, 0xa0, 0x89, 0xac,
	0x58, 0x4d, 0xe3, 0x5d, 0x89, 0xdc, 0x8a, 0xc9, 0x26, 0xdc, 0x53, 0x89, 0x5f, 0x51, 0x16, 0x59,
	0x30, 0x63, 0xc4, 0xf4, 0x78, 0xc1, 0x5e, 0x51, 0xd6, 0xb8, 0xa2, 0xd1, 0x0e, 0x5a, 0xa6, 0xf7,
	0xa0, 0x11, 0x09, 0x7f, 0x5f, 0x26, 0x57, 0x2a, 0x36, 0x48, 0x10, 0x26, 0x38, 0x4c, 0x39, 0xc2,
	0x18, 0x56, 0x8f, 0x52, 0x13, 0x9c, 0xae, 0x2b, 0x9e, 0x8b, 0x11, 0x6d, 0x45, 0xd1, 0x95, 0x81,
	0x4b, 0x36, 0xa0, 0x9e, 0x0c, 0x31, 0x96, 0xd5, 0x23, 0xf3, 0x14, 0xc9, 0xd4, 0x85, 0xdf, 0x6a,
	0x8c, 0x67, 0x4d, 0x5b, 0x8c, 0xc8, 0x53, 0x58, 0xf0, 0x62, 0x3a, 0x8e, 0xba, 0x6d, 0xbc, 0x36,
	0xcb, 0x9a, 0xde, 0x0e, 0x62, 0x3a, 0xb6, 0x39, 0x5e, 0x67, 0x05, 0x97, 0xcb, 0x5b, 0xcf, 0x8d,
	0x2f, 0x31, 0xa6, 0x6d, 0x2a, 0xac, 0x40, 0xc9, 0xbc, 0x66, 0x28, 0x9d, 0xe9, 0xfc, 0x9b, 0x4b,
	0xea, 0x5d, 0x5c, 0xc6, 0x18, 0xe1, 0x36, 0x15, 0xa6, 0xe3, 0x47, 0xaf, 0x10, 0x47, 0x7e, 0x06,
	0x9d, 0xcc, 0x57, 0x51, 0x97, 0xa8, 0xde, 0x85, 0xd0, 0xae, 0x89, 0xeb, 0xb1, 0xf8, 0x58, 0x71,
	0xc0, 0x11, 0x11, 0x91, 0x27, 0x60, 0x32, 0x59, 0xe1, 0x05, 0x5b, 0xc1, 0x0f, 0x55, 0xa6, 0xd4,
	0x10, 0xb7, 0x7d, 0x4d, 0x7e, 0x02, 0xbd, 0xf9, 0x2a, 0x81, 0x31, 0xf8, 0x2a, 0x72, 0x7b, 0x7d,
	0x9e, 0x5a, 0x6c, 0x5d, 0x04, 0xd6, 0x5f, 0x18, 0xd0, 0x50, 0xb8, 0x94, 0xbb, 0x56, 0x05, 0xbe,
	0x32, 0xf7, 0x59, 0x40, 0xf5, 0x59, 0x9e, 0x40, 0xcb, 0xf5, 0x22, 0x54, 0x2b, 0xe1, 0xcb, 0xf2,
	0xc4, 0x46, 0x53, 0x42, 0xb9, 0x1f, 0xfb, 0xae, 0xb0, 0x06, 0x4d, 0x3c, 0x50, 0x9d, 0x1f, 0xe8,
	0xc4, 0xb9, 0xe0, 0x46, 0xc1, 0x7a, 0x01, 0x2d, 0x9d, 0x2d, 0xb9, 0x1d, 0x75, 0xa0, 0xc2, 0x2e,
	0x12, 0xdf, 0x10, 0xfb, 0x99, 0xec, 0xb1, 0xa2, 0xc4, 0x57, 0x1f, 0xa1, 0x29, 0xdd, 0xe3, 0x2c,
	0xba, 0xcd, 0x80, 0x5b, 0x9b, 0xd0, 0x56, 0x67, 0x33, 0x13, 0xfd, 0x1e, 0x34, 0xd2, 0xbc, 0x27,
	0x77, 0x82, 0xaa, 0x36, 0x24, 0x89, 0xcf, 0xc8, 0xfa, 0x63, 0x20, 0xec, 0x83, 0xcc, 0x0b, 0x5a,
	0xe8, 0x23, 0xe8, 0x79, 0x54, 0xfe, 0x5e, 0x2a, 0x79, 0x54, 0x02, 0x55, 0x26, 0x4f, 0x3c, 0x83,
	0x69, 0xe3, 0x6f, 0x8b, 0x40, 0x47, 0x5b, 0x81, 0xc5, 0xcb, 0x0f, 0xe0, 0xfe, 0x4b, 0x1a, 0x1f,
	0x4f, 0xe9, 0xc8, 0x73, 0x7c, 0x81, 0x49, 0x02, 0xd1, 0x3f, 0x00, 0xa2, 0x63, 0xe6, 0xa6, 0xe9,
	0xe6, 0xbe, 0x94, 0xd6, 0xd7, 0x18, 0xdf, 0xe6, 0x08, 0xf3, 0x90, 0xb4, 0xea, 0x7b, 0x91, 0xb4,
	0x48, 0x5d, 0x71, 0xc9, 0x73, 0x0b, 0xd9, 0x38, 0x8b, 0xc9, 0x87, 0x86, 0xd2, 0xa3, 0x62, 0x3f,
	0xad, 0x4d, 0x24, 0xbd, 0xe7, 0x44, 0xd2, 0xb5, 0x19, 0xec, 0xde, 0xe6, 0x10, 0x5a, 0x4f, 0xd1,
	0xcb, 0xcd, 0x7c, 0x23, 0x5c, 0x38, 0x2d, 0xde, 0xdb, 0x84, 0xe5, 0x5d, 0xea, 0x67, 0xa4, 0xa0,
	0x33, 0xdb, 0xc8, 0x30, 0xdb, 0xfa, 0x10, 0xda, 0xea, 0x37, 0x8c, 0x6c, 0x17, 0x6a, 0xd1, 0x6c,
	0x34, 0xa2, 0x51, 0x24, 0xdc, 0x43, 0x39, 0xb4, 0xfe, 0xd4, 0x80, 0xfa, 0x49, 0x70, 0x45, 0x27,
	0x73, 0x99, 0x59, 0xe8, 0xb8, 0x3e, 0x86, 0x6a, 0x7c, 0x3d, 0xe5, 0x02, 0x6d, 0x6d, 0xb6, 0x85,
	0x9e, 0x33, 0x3a, 0x27, 0xd7, 0x53, 0x6a, 0x23, 0x12, 0x45, 0xc1, 0x40, 0xc2, 0xf0, 0xf0, 0x41,
	0x1a, 0x8b, 0x2e, 0x28, 0xb1, 0xa8, 0xf5, 0x19, 0xb4, 0xb7, 0x5c, 0x17, 0x29, 0xc8, 0x63, 0x3e,
	0x91, 0x9f, 0x73, 0x63, 0xad, 0x2e, 0xc2, 0x93, 0xb6, 0x88, 0xb5, 0xfa, 0x78, 0x5c, 0xed, 0xcb,
	0xfb, 0x60, 0x22, 0x2e, 0x65, 0x4f, 0x0d, 0xc7, 0x37, 0xb8, 0xe2, 0xd6, 0x63, 0x68, 0xf4, 0x99,
	0x9f, 0x2a, 0x0c, 0xf9, 0x7c, 0x1f, 0xf6, 0x43, 0x0c, 0xf9, 0x71, 0xad, 0x5b, 0x53, 0xe4, 0xd6,
	0x11, 0x5e, 0x3b, 0x39, 0x19, 0xa9, 0x3e, 0x85, 0x45, 0xdc, 0x88, 0x0c, 0x3b, 0x72, 0x67, 0x12,
	0xe8, 0x02, 0xd7, 0xfd, 0x2b, 0x58, 0x1f, 0x4c, 0xde, 0x38, 0x3e, 0x3e, 0x1d, 0xfa, 0x2e, 0xa4,
	0x40, 0x8c, 0x9b, 0x04, 0xb2, 0x96, 0x2c, 0xcf, 0xbc, 0xd5, 0xba, 0x5c, 0xcd, 0xea, 0xc2, 0x5a,
	0x9e, 0x2e, 0x7a, 0x62, 0x11, 0x10, 0x9e, 0x56, 0xd7, 0xf8, 0x7b, 0xa7, 0xc5, 0x1e, 0x40, 0x3d,
	0xf0, 0xdd, 0x21, 0x17, 0x21, 0x3f, 0x86, 0x19, 0xf8, 0x5c, 0xc4, 0x0c, 0x39, 0xa1, 0x6f, 0x05,
	0x92, 0xbf, 0x6c, 0xe6, 0x84, 0xbe, 0x45, 0xa4, 0xb5, 0x02, 0xcb, 0xda, 0xa2, 0xb8, 0x93, 0x6f,
	0xc1, 0x64, 0x96, 0x77, 0xc7, 0x09, 0xdd, 0x79, 0x6a, 0x2a, 0xef, 0x59, 0x59, 0x73, 0x5d, 0xe7,
	0xbc, 0x9d, 0x8c, 0x09, 0x93, 0xd9, 0xf8, 0x8c, 0x86, 0x42, 0x2d, 0xc5, 0xa8, 0x30, 0x42, 0xb0,
	0x7e, 0x0f, 0x96, 0xb9, 0xab, 0xc7, 0xd6, 0x96, 0x2c, 0xb0, 0xa0, 0x3a, 0x72, 0xc2, 0x4c, 0x45,
	0x45, 0x6e, 0xd0, 0x46, 0x9c, 0xf5, 0x09, 0xb4, 0xd5, 0x0f, 0xe7, 0xdc, 0xef, 0xb9, 0xc9, 0xb3,
	0xcf, 0xf1, 0xce, 0x53, 0x7d, 0xbd, 0xbb, 0xde, 0x4c, 0x6b, 0x19, 0xaf, 0x03, 0x55, 0x16, 0xb5,
	0x76, 0x50, 0x11, 0xd9, 0xf8, 0xf6, 0xba, 0x4e, 0x11, 0x2b, 0xad, 0x4f, 0xa0, 0x99, 0x12, 0x11,
	0x25, 0x15, 0x76, 0xca, 0x4c, 0x49, 0x25, 0x61, 0x01, 0x47, 0x5a, 0x5f, 0x60, 0x06, 0x8f, 0x41,
	0xb6, 0xaf, 0xd3, 0x87, 0xf1, 0xce, 0xa7, 0xe1, 0xb9, 0xcc, 0x94, 0x7f, 0x92, 0xed, 0xc6, 0x0d,
	0x6c, 0xff, 0xbb, 0x45, 0xa8, 0x32, 0x50, 0xce, 0xb6, 0x66, 0x7c, 0xbe, 0xf2, 0x8d, 0x3e, 0x5f,
	0x25, 0x5f, 0x41, 0x51, 0x7d, 0x3e, 0xc5, 0xf7, 0x91, 0x95, 0x9d, 0xb4, 0x18, 0x33, 0xc0, 0xfc,
	0x97, 0x9e, 0x8a, 0x44, 0x31, 0x2f, 0x64, 0xfc, 0xe3, 0x53, 0x81, 0xd0, 0xa7, 0x9f, 0xcf, 0x7c,
	0x1f, 0xa7, 0x67, 0xdd, 0xe9, 0x17, 0x02, 0x41, 0xfe, 0x3f, 0xa4, 0x4e, 0xd9, 0xd0, 0x79, 0xe3,
	0xc4, 0x4e, 0x88, 0xfe, 0x37, 0x77, 0xaa, 0x53, 0x52, 0x5b, 0x88, 0x62, 0x0e, 0xf8, 0x87, 0x6a,
	0x6a, 0x54, 0x06, 0x04, 0x66, 0xc6, 0xbb, 0x97, 0xb1, 0x80, 0x36, 0xf9, 0x2d, 0x3d, 0x8b, 0xbc,
	0x98, 0x8a, 0x4a, 0x65, 0x3a, 0xf9, 0x35, 0x87, 0x93, 0xc7, 0xd0, 0x9c, 0x3a, 0xd7, 0xcc, 0x87,
	0x1d, 0x86, 0x33, 0x9f, 0x46, 0x22, 0x3a, 0x5c, 0x12, 0x40, 0x9b, 0xc1, 0x30, 0xe7, 0x7f, 0xe9,
	0x4d, 0xa7, 0xde, 0xe4, 0x42, 0xcc, 0x6a, 0x88, 0x9c, 0xbf, 0x80, 0xf2, 0x69, 0x5d, 0xa8, 0xc9,
	0xbd, 0x2d, 0x89, 0x5a, 0x9a, 0xd8, 0xd2, 0xfb, 0x50, 0x8b, 0xa8, 0xef, 0xd3, 0x50, 0xfa, 0x56,
	0x9a, 0xb3, 0x28, 0x50, 0xcc, 0x32, 0x2a, 0xdc, 0xe0, 0x35, 0xa1, 0xba, 0x93, 0x30, 0x61, 0x0d,
	0x16, 0x23, 0x3f, 0xb8, 0x70, 0x78, 0x21, 0xa8, 0x6e, 0x8b, 0x11, 0x79, 0x07, 0xd8, 0x24, 0xcf,
	0x77, 0xce, 0x7c, 0x8a, 0x9e, 0xb2, 0x69, 0xa7, 0x00, 0x46, 0x74, 0x84, 0xd7, 0x18, 0x03, 0x91,
	0x65, 0x6e, 0x6e, 0x05, 0x64, 0x0b, 0x4b, 0x96, 0xd1, 0x2c, 0x9a, 0xd2, 0x89, 0x4b, 0x79, 0xa5,
	0xc7, 0xb4, 0x53, 0x80, 0x9a, 0xe1, 0x59, 0xd1, 0x32, 0x3c, 0x1f, 0x40, 0x1b, 0x11, 0xf4, 0xdb,
	0xa9, 0x17, 0xd2, 0x88, 0x91, 0xe6, 0xce, 0x6c, 0x93, 0x81, 0xfb, 0x1c, 0xba, 0x15, 0xe7, 0x32,
	0x41, 0xf7, 0x72, 0x99, 0x20, 0xd2, 0x03, 0xd3, 0x0f, 0x46, 0x98, 0xc8, 0xeb, 0xae, 0xf1, 0xb7,
	0x54, 0x8e, 0x31, 0x35, 0x12, 0x84, 0x57, 0x8c, 0xef, 0xb1, 0x37, 0xa6, 0xdd, 0x75, 0x5e, 0x37,
	0x14, 0xb0, 0x13, 0x6f, 0x4c, 0xad, 0x3f, 0x02, 0xc2, 0xae, 0xcb, 0x51, 0x18, 0x9c, 0x7b, 0x69,
	0x92, 0xfd, 0x69, 0x2e, 0xea, 0x37, 0x44, 0xda, 0x45, 0x8f, 0xfb, 0xf3, 0x85, 0x0b, 0x3d, 0xa5,
	0xf2, 0x35, 0x74, 0x34, 0xea, 0xec, 0x16, 0xcb, 0xea, 0x9f, 0x51, 0x50, 0xfd, 0x7b, 0x02, 0x2d,
	0x59, 0xf8, 0x14, 0x91, 0x1c, 0x7f, 0x15, 0x9a, 0x12, 0x8a, 0x31, 0x9c, 0x35, 0x05, 0xeb, 0x85,
	0x37, 0x71, 0x0f, 0x43, 0xfe, 0xca, 0x32, 0x02, 0x2f, 0x82, 0x30, 0x5b, 0xf6, 0xc9, 0xdc, 0x7a,
	0xfe, 0xe8, 0xa8, 0xb7, 0xfe, 0x19, 0x74, 0x42, 0xca, 0xe5, 0x39, 0xd4, 0x33, 0x0a, 0x6d, 0x09,
	0x17, 0x59, 0x24, 0xeb, 0x0a, 0x1e, 0xdd, 0xb8, 0x22, 0x3b, 0x5c, 0x61, 0x16, 0xb0, 0x30, 0x61,
	0x91, 0x5a, 0xfb, 0x8a, 0x6a, 0xed, 0xbf, 0x81, 0xf7, 0xd4, 0xc5, 0xb6, 0xe2, 0xd8, 0x19, 0x5d,
	0x52, 0x17, 0xf9, 0x74, 0xd7, 0xb3, 0xcd, 0x7f, 0x86, 0xca, 0x05, 0xcf, 0x90, 0x75, 0x00, 0xef,
	0x16, 0x2f, 0x79, 0xe3, 0xe1, 0xe6, 0x1f, 0xe1, 0x39, 0xbe, 0xfe, 0xfb, 0x8e, 0x37, 0x39, 0x71,
	0x2e, 0x12, 0xe3, 0x93, 0xa4, 0xc6, 0x0c, 0x25, 0x35, 0x26, 0x6a, 0x46, 0x36, 0xf5, 0xd9, 0xbd,
	0x52, 0xa7, 0xcb, 0x0c, 0x9b, 0x51, 0x94, 0x61, 0x2b, 0xab, 0x64, 0x7e, 0x0c, 0xed, 0x13, 0xe7,
	0x42, 0xcb, 0x3a, 0xfd, 0x20, 0x93, 0x75, 0x52, 0xc2, 0x32, 0x99, 0x71, 0x7a, 0x06, 0x95, 0x13,
	0xe7, 0xe2, 0x2e, 0xf1, 0xa1, 0xf5, 0x23, 0xe9, 0x0e, 0xe0, 0xd3, 0x23, 0xf6, 0xf8, 0x10, 0xaa,
	0x8c, 0xbb, 0xba, 0x46, 0xe3, 0x04, 0x84, 0x5b, 0xff, 0x2c, 0x7a, 0x73, 0xd4, 0x6f, 0xb2, 0x56,
	0xc4, 0xc8, 0x5b, 0x11, 0x16, 0x8b, 0x5e, 0x06, 0x93, 0x24, 0x98, 0xc1, 0x41, 0x81, 0x50, 0x2b,
	0x45, 0xb6, 0x85, 0x1f, 0xaa, 0xaa, 0x26, 0xeb, 0x45, 0x11, 0x64, 0x41, 0x2b, 0x82, 0x3c, 0x80,
	0xfa, 0x05, 0x8d, 0x87, 0x4c, 0xa0, 0x91, 0xc8, 0x31, 0x9a, 0x17, 0x34, 0x66, 0xc2, 0x8f, 0x12,
	0x4e, 0xd4, 0x14, 0x4e, 0x7c, 0x02, 0x6d, 0xce, 0x67, 0x7e, 0x2a, 0x6e, 0x9f, 0x75, 0x56, 0xab,
	0x9c, 0x90, 0xbc, 0xfe, 0x19, 0x34, 0x53, 0x56, 0xe8, 0x4e, 0x11, 0xe7, 0xba, 0x64, 0x66, 0xb9,
	0x80, 0x99, 0xff, 0xb2, 0x00, 0x55, 0x36, 0xbc, 0x6b, 0x38, 0x4f, 0xc7, 0x8e, 0xe7, 0x27, 0x8a,
	0xc9, 0x06, 0x29, 0x63, 0xab, 0x2a, 0x63, 0xbb, 0x50, 0x93, 0xd6, 0x8e, 0x5b, 0x6a, 0x39, 0xcc,
	0xc9, 0x6a, 0xf1, 0xae, 0x16, 0xbf, 0xf6, 0xfd, 0x2c, 0xbe, 0xf9, 0x7d, 0x2d, 0x7e, 0xfd, 0xfb,
	0x59, 0x7c, 0x28, 0xb0, 0xf8, 0xeb, 0x50, 0x0b, 0xa6, 0xf1, 0x90, 0x85, 0x65, 0x0d, 0xae, 0x14,
	0xc1, 0x34, 0x3e, 0x9c, 0xa1, 0x92, 0x46, 0xb3, 0x29, 0x0d, 0x87, 0xdc, 0xc4, 0xa2, 0x59, 0x36,
	0xed, 0x06, 0xc2, 0x8e, 0x11, 0xa4, 0x1a, 0xed, 0xa6, 0x6e, 0xb4, 0x1f, 0x40, 0xfd, 0xd2, 0x89,
	0x86, 0x9c, 0xff, 0x3c, 0xa3, 0x65, 0x5e, 0x3a, 0x51, 0x1f, 0x45, 0x20, 0x90, 0x5c, 0x0c, 0xed,
	0x04, 0x79, 0x84, 0x92, 0x60, 0x96, 0x9a, 0x2f, 0xc8, 0xcd, 0xb1, 0x18, 0x65, 0x0c, 0xfc, 0x72,
	0xb1, 0x81, 0x27, 0x9a, 0x81, 0x57, 0xdf, 0xc9, 0xe0, 0x1c, 0xd3, 0x4d, 0xca, 0x3b, 0x79, 0x78,
	0xce, 0x36, 0xc3, 0x57, 0x60, 0xe8, 0x55, 0x44, 0x9b, 0x1c, 0x70, 0x78, 0xce, 0x2c, 0xfc, 0x28,
	0x98, 0x9c, 0x7b, 0xe1, 0x98, 0xba, 0xc2, 0xfe, 0xa6, 0x00, 0xc6, 0x3a, 0x2f, 0x1a, 0x9e, 0x3b,
	0x57, 0x14, 0x8d, 0x2f, 0x26, 0xed, 0x5e, 0x38, 0x57, 0x94, 0x45, 0xa1, 0x5e, 0x34, 0x74, 0xdc,
	0xb1, 0x37, 0x41, 0xb3, 0x6b, 0xda, 0x35, 0x2f, 0xda, 0x62, 0x43, 0xa5, 0x97, 0xa8, 0xab, 0xf6,
	0x12, 0x59, 0x5f, 0xb2, 0x1b, 0x15, 0x23, 0x7f, 0x6e, 0xf5, 0xd4, 0x13, 0xc5, 0x2e, 0x2b, 0x8a,
	0x6d, 0x3d, 0x81, 0x66, 0x4a, 0xa1, 0xb8, 0x18, 0x73, 0x0c, 0xad, 0x63, 0x1a, 0xef, 0x3a, 0xb1,
	0x73, 0xeb, 0x3a, 0x45, 0x39, 0x32, 0x94, 0x5b, 0x45, 0xb9, 0x3e, 0x56, 0x0b, 0x96, 0x12, 0xa2,
	0x2c, 0xee, 0xf8, 0x73, 0x03, 0x08, 0x0b, 0xea, 0xa9, 0x4f, 0x99, 0xae, 0xdd, 0xba, 0x52, 0x0f,
	0xcc, 0x8c, 0x89, 0x4a, 0xc6, 0xec, 0xa3, 0xd1, 0xa5, 0x13, 0x2b, 0x95, 0x32, 0x36, 0xe4, 0xe5,
	0xfa, 0x68, 0x76, 0x16, 0x85, 0xde, 0xe8, 0x8c, 0x86, 0xdc, 0x51, 0xe1, 0x77, 0xba, 0x95, 0x82,
	0x99, 0x9f, 0x62, 0x6d, 0x40, 0x47, 0xdb, 0x4c, 0x31, 0x73, 0x7e, 0x6d, 0x80, 0x29, 0xe7, 0xdd,
	0x18, 0x29, 0xc9, 0x1d, 0x95, 0xb5, 0x1d, 0x31, 0x5f, 0x17, 0x97, 0x4e, 0x36, 0x54, 0x11, 0xbe,
	0xae, 0x84, 0xa2, 0xdf, 0xa4, 0x69, 0x55, 0x35, 0xa3, 0x55, 0xd6, 0x57, 0xb0, 0xba, 0xe7, 0x45,
	0xb1, 0xdc, 0xc6, 0xed, 0x81, 0xdb, 0x13, 0x68, 0x25, 0x5f, 0xf3, 0x32, 0x11, 0x77, 0x32, 0x9a,
	0x09, 0xf4, 0x70, 0xe2, 0x5f, 0x5b, 0x7f, 0x08, 0x24, 0x43, 0x97, 0xe7, 0xc0, 0xea, 0xb1, 0x84,
	0xe8, 0xf1, 0x5c, 0xc2, 0xaf, 0x74, 0x42, 0x61, 0x5d, 0x71, 0x6d, 0x87, 0x2f, 0x75, 0x67, 0x81,
	0x17, 0xb1, 0xd0, 0xfa, 0x08, 0x56, 0x73, 0xb4, 0x8a, 0xe5, 0x75, 0x06, 0x64, 0x97, 0xfa, 0xff,
	0xa7, 0x6a, 0xc6, 0xb4, 0x47, 0x5b, 0xa3, 0x70, 0x37, 0xcf, 0x9f, 0x01, 0xa4, 0x8d, 0x9f, 0xa4,
	0x06, 0x95, 0xed, 0xd3, 0xaf, 0x3b, 0x25, 0x62, 0x42, 0x75, 0x70, 0xf0, 0xe2, 0xb0, 0x63, 0xb0,
	0x5f, 0xc7, 0xbf, 0x18, 0x1c, 0x75, 0xca, 0xcf, 0x4f, 0x61, 0x49, 0xed, 0x0d, 0x21, 0x0d, 0xa8,
	0x9d, 0x1e, 0xfc, 0xe2, 0xe0, 0xf0, 0xf5, 0x41, 0xa7, 0x44, 0x96, 0xc0, 0xdc, 0x39, 0x3d, 0x3e,
	0x39, 0xdc, 0xef, 0xdb, 0x1d, 0x83, 0x8d, 0x8e, 0x4f, 0x8f, 0x8e, 0xf6, 0x06, 0x7d, 0xbb, 0x53,
	0x26, 0x00, 0x8b, 0xc7, 0xfd, 0xbd, 0xbd, 0xbe, 0xdd, 0xa9, 0x90, 0x0e, 0x2c, 0x1d, 0x9f, 0x1e,
	0xf5, 0xed, 0xa1, 0x80, 0x54, 0x9f, 0x07, 0x7c, 0x07, 0xbc, 0x6d, 0x8a, 0xd4, 0x61, 0xa1, 0xbf,
	0x7f, 0x74, 0xc2, 0xf6, 0x50, 0x83, 0xca, 0x41, 0xff, 0x75, 0xc7, 0x20, 0x6d, 0x68, 0x0c, 0x0e,
	0x86, 0x47, 0xf6, 0xe1, 0x4b, 0xbb, 0x7f, 0x7c, 0xdc, 0x29, 0x93, 0x26, 0xd4, 0x8f, 0x4f, 0xb7,
	0xf7, 0x07, 0x27, 0x27, 0xfd, 0xdd, 0x4e, 0x85, 0xe1, 0x0f, 0x0f, 0x86, 0xbb, 0xfd, 0xbd, 0xc1,
	0x57, 0x7d, 0xfb, 0xeb, 0x4e, 0x95, 0xe1, 0x77, 0x0e, 0xf7, 0x8f, 0xf6, 0xfa, 0x0c, 0xbf, 0x80,
	0xc3, 0xad, 0x83, 0x1d, 0xb6, 0xe0, 0x6e, 0x67, 0xf1, 0xf9, 0x10, 0xda, 0x99, 0x4e, 0x31, 0xb6,
	0xc3, 0x1d, 0xbb, 0xbf, 0x75, 0xd2, 0xe7, 0x27, 0x49, 0x96, 0x32, 0x70, 0xef, 0xb8, 0x54, 0xa7,
	0xcc, 0x30, 0xc9, 0x22, 0x15, 0x3c, 0xb1, 0x58, 0xa4, 0x53, 0x45, 0x0a, 0xb8, 0x46, 0x67, 0xe1,
	0xf9, 0xfb, 0x22, 0x49, 0x79, 0x72, 0x3d, 0x45, 0x2e, 0x6d, 0x4d, 0xdc, 0x30, 0xf0, 0xdc, 0x4e,
	0x89, 0xcd, 0x1a, 0xe0, 0xeb, 0xd3, 0x31, 0x36, 0xff, 0xbd, 0x0a, 0x0d, 0xdc, 0x07, 0x0d, 0xdf,
	0x78, 0x23, 0x4a, 0x36, 0x01, 0xd2, 0xce, 0x58, 0x02, 0x69, 0x33, 0x4e, 0x6f, 0x4d, 0x94, 0xfb,
	0x33, 0x7d, 0xb3, 0x56, 0x89, 0xfc, 0x3e, 0x98, 0xb2, 0x83, 0x99, 0x88, 0x26, 0xb8, 0x4c, 0x4f,
	0x75, 0x6f, 0x35, 0x0b, 0x16, 0x9f, 0xfe, 0x14, 0x73, 0x15, 0x49, 0xe3, 0x29, 0x59, 0x4b, 0x1d,
	0x17, 0xb5, 0xa7, 0x56, 0x7e, 0xaf, 0x77, 0xa8, 0x5a, 0x25, 0xf2, 0x09, 0xd4, 0x44, 0xdf, 0x16,
	0x11, 0x53, 0xf4, 0xde, 0xb1, 0x1e, 0xc9, 0x40, 0xf9, 0x67, 0x2f, 0xf1, 0xc5, 0x57, 0x04, 0xde,
	0x13, 0xf1, 0xd4, 0x9c, 0xfe, 0xbf, 0x5e, 0x77, 0x2e, 0x8e, 0x13, 0xda, 0x85, 0x25, 0xb5, 0x0d,
	0x8e, 0xdc, 0x97, 0xad, 0x59, 0xb9, 0x56, 0xba, 0xde, 0xfa, 0x3c, 0x94, 0x46, 0x45, 0xf6, 0xc1,
	0xa9, 0x54, 0x32, 0xbd, 0x74, 0x2a, 0x15, 0xbd, 0x6d, 0xae, 0x44, 0x78, 0x6f, 0x95, 0xd6, 0x40,
	0x46, 0xde, 0x4d, 0x8e, 0x3f, 0xaf, 0x4f, 0xad, 0xf7, 0xa0, 0x08, 0xcd, 0x29, 0x6e, 0x41, 0x43,
	0xe9, 0xd6, 0x22, 0xdd, 0x64, 0x76, 0xa6, 0xbb, 0x4c, 0xea, 0x46, 0xb6, 0xb5, 0xcb, 0x2a, 0x6d,
	0xfe, 0x57, 0x19, 0x56, 0xf6, 0x83, 0x09, 0x8d, 0x3d, 0xde, 0x35, 0x23, 0xf5, 0x8c, 0x0b, 0x0e,
	0x9b, 0xb1, 0x52, 0xc1, 0x29, 0x5d, 0x5c, 0x8a, 0xe0, 0x92, 0xae, 0x21, 0xce, 0x29, 0xb5, 0x53,
	0x47, 0x72, 0x6a, 0x4e, 0x2f, 0x90, 0xe4, 0x54, 0xae, 0xb1, 0xc7, 0x2a, 0x91, 0x9f, 0x63, 0xcf,
	0x98, 0xd2, 0xe0, 0x42, 0x14, 0x46, 0xe4, 0xda, 0x68, 0x7a, 0xf7, 0xe7, 0x23, 0x39, 0xad, 0x9f,
	0x40, 0x3d, 0x69, 0x29, 0x91, 0xea, 0x9b, 0xed, 0x72, 0x91, 0xea, 0xab, 0xf7, 0x9e, 0x24, 0x7a,
	0x98, 0xf6, 0x82, 0x28, 0x7a, 0x98, 0x6b, 0x36, 0x51, 0xf4, 0x30, 0xd3, 0x3c, 0x62, 0x95, 0x36,
	0xff, 0x7a, 0x01, 0x5a, 0x49, 0xf3, 0x00, 0xe7, 0xf0, 0x36, 0x40, 0xda, 0x3a, 0x42, 0x14, 0x6e,
	0x68, 0x85, 0x11, 0x79, 0xb8, 0x39, 0x9d, 0x07, 0x5c, 0x01, 0xd8, 0x95, 0xbd, 0x95, 0xc8, 0xba,
	0xde, 0x14, 0xa0, 0xde, 0xf0, 0x01, 0xf3, 0x9a, 0x94, 0xee, 0x10, 0xe5, 0xae, 0xe5, 0x7b, 0x46,
	0x6e, 0xde, 0xcd, 0x2b, 0x68, 0x6a, 0xfd, 0x03, 0x92, 0xd2, 0xbc, 0xc6, 0x05, 0x49, 0x69, 0x4e,
	0xc3, 0x01, 0x3f, 0x97, 0x52, 0x47, 0x93, 0x8a, 0x9d, 0x2f, 0xde, 0x49, 0xc5, 0xce, 0x15, 0xdd,
	0xd8, 0xcb, 0x05, 0x69, 0x81, 0x50, 0xe1, 0x8c, 0x5e, 0x60, 0xec, 0xdd, 0xcb, 0x23, 0xf8, 0xf7,
	0x5f, 0x61, 0x98, 0x9f, 0xa9, 0xae, 0x91, 0xf7, 0x92, 0xe9, 0xf3, 0x0b, 0x7a, 0xbd, 0x77, 0x8b,
	0x27, 0xa8, 0xaf, 0x80, 0x56, 0x26, 0x53, 0x5e, 0x81, 0x79, 0x25, 0x37, 0xe5, 0x15, 0xc8, 0x57,
	0xd7, 0xf8, 0x49, 0xd3, 0xda, 0x98, 0x3c, 0x69, 0xae, 0xc2, 0x26, 0x4f, 0x9a, 0x29, 0xa3, 0x59,
	0xa5, 0xcd, 0x7f, 0x2d, 0xc3, 0xf2, 0xd1, 0x2c, 0xba, 0xe4, 0x45, 0x12, 0xa9, 0x9e, 0x9f, 0x82,
	0x29, 0x8b, 0x57, 0xd2, 0x68, 0x64, 0x8a, 0x59, 0x3d, 0x51, 0xb2, 0x57, 0x4a, 0x4c, 0x56, 0x89,
	0x7d, 0x27, 0x4b, 0x57, 0x24, 0x5d, 0xf2, 0xf6, 0xef, 0x3e, 0x87, 0x7a, 0x52, 0x59, 0x22, 0xe9,
	0x7b, 0xa5, 0x55, 0x84, 0x14, 0x69, 0x69, 0x15, 0x9d, 0x12, 0xf9, 0x25, 0x74, 0xb2, 0xd5, 0x1e,
	0xc9, 0xd5, 0x82, 0xea, 0x52, 0xef, 0x9d, 0x22, 0xb4, 0x20, 0xb9, 0x0d, 0x0d, 0xa5, 0x62, 0x23,
	0x75, 0x30, 0x5f, 0x39, 0x92, 0x97, 0x2b, 0x5f, 0xde, 0x29, 0x6d, 0xfe, 0x59, 0x19, 0xda, 0x32,
	0x93, 0x2f, 0x19, 0xfb, 0x53, 0x69, 0xc1, 0xb1, 0xec, 0xb3, 0xae, 0x5e, 0x03, 0xa5, 0x38, 0x22,
	0x8f, 0x9a, 0x29, 0xb6, 0x24, 0xe2, 0xa6, 0xfa, 0xf7, 0xb9, 0xe2, 0x8a, 0x22, 0x6e, 0xaa, 0x7f,
	0xff, 0x19, 0x98, 0xb2, 0xe8, 0x41, 0xee, 0x29, 0xf6, 0x25, 0xad, 0xa4, 0xf4, 0x56, 0xb2, 0x60,
	0xfe, 0xe5, 0x17, 0x68, 0x6e, 0x64, 0xdd, 0x43, 0x31, 0x37, 0x99, 0x52, 0x88, 0x62, 0x1b, 0x94,
	0x85, 0x37, 0xff, 0xbe, 0x0c, 0x0d, 0xc6, 0x0c, 0xc9, 0x88, 0x5d, 0x7c, 0xe5, 0x95, 0x44, 0xaa,
	0xa4, 0x98, 0xcf, 0xdc, 0xca, 0x7b, 0x9e, 0xcd, 0xba, 0x5a, 0x25, 0xf2, 0x0d, 0x3c, 0xb8, 0x21,
	0x7d, 0x49, 0x36, 0xf8, 0x87, 0xb7, 0xe7, 0x54, 0x7b, 0x1f, 0xdc, 0x61, 0x26, 0x5f, 0xf2, 0x12,
	0xba, 0x45, 0x19, 0x45, 0xf2, 0x24, 0x4f, 0x65, 0x4e, 0x92, 0xb3, 0xf7, 0xf8, 0xb6, 0x69, 0x9c,
	0x65, 0x7f, 0x65, 0x00, 0x60, 0xe6, 0x8f, 0x73, 0xec, 0x4b, 0x14, 0x80, 0x4c, 0x3d, 0x2a, 0x02,
	0xc8, 0x64, 0x23, 0xa5, 0xf0, 0x33, 0x49, 0x43, 0xab, 0x44, 0x5e, 0x20, 0xcf, 0x95, 0x84, 0xa4,
	0x62, 0x59, 0xf3, 0x69, 0xca, 0x42, 0x3a, 0x9b, 0xff, 0x56, 0x85, 0x06, 0x73, 0x25, 0x52, 0x63,
	0xd6, 0x51, 0xcf, 0x82, 0x99, 0x2c, 0x4d, 0xb5, 0x95, 0x24, 0xa1, 0x54, 0x2f, 0x2d, 0x61, 0x66,
	0x95, 0xc8, 0x97, 0xd0, 0xe2, 0x73, 0x5f, 0x38, 0x57, 0xbf, 0x1b, 0x85, 0xcf, 0xb8, 0xa3, 0x8b,
	0xdf, 0xde, 0xcb, 0x4e, 0xb9, 0xed, 0x4b, 0x99, 0x62, 0x90, 0x5f, 0x66, 0x92, 0x16, 0xf2, 0x4b,
	0x2d, 0x13, 0xc1, 0x3d, 0x5c, 0x91, 0x20, 0x90, 0x8e, 0x92, 0x9e, 0x84, 0x90, 0x97, 0x41, 0xcb,
	0x22, 0xa0, 0x85, 0x53, 0x22, 0x77, 0x29, 0xca, 0x7c, 0x66, 0x41, 0x6a, 0x7e, 0x36, 0xcc, 0xb7,
	0x4a, 0x64, 0x1f, 0xda, 0x99, 0x80, 0x92, 0xbc, 0x23, 0x5b, 0x7e, 0xe7, 0xc5, 0xac, 0xbd, 0x5e,
	0x01, 0x36, 0xf1, 0x75, 0xb4, 0x28, 0x5a, 0x5a, 0xef, 0x79, 0x21, 0x7b, 0xaf, 0x3b, 0x17, 0x97,
	0x1c, 0x4d, 0x09, 0x2b, 0xe5, 0xd1, 0xf2, 0xd1, 0xac, 0x3c, 0x5a, 0x36, 0x06, 0xb5, 0x4a, 0xdb,
	0x9d, 0xdf, 0x7c, 0xf7, 0xd0, 0xf8, 0xed, 0x77, 0x0f, 0x8d, 0xff, 0xf8, 0xee, 0xa1, 0xf1, 0x97,
	0xff, 0xf9, 0xb0, 0x74, 0xb6, 0x88, 0xff, 0x0a, 0xfd, 0xd1, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff,
	0xb1, 0xd7, 0xf1, 0x16, 0x23, 0x3a, 0x00, 0x00,
}
